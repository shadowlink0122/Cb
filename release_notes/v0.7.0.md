# Cb言語 v0.7.0 リリースノート

# Cb言語 v0.7.0 リリースノート

## 🎉 メジャー機能追加: 多次元配列戻り値処理の完全対応

**リリース日**: 2025年9月29日  
**バージョン**: v0.7.0  
**テスト成功率**: 100% (1116/1116 テスト成功)

---

## ✨ 主な新機能

### 🔧 多次元配列戻り値処理の完全実装

typedef配列関数からの多次元配列戻り値が完全にサポートされました。

#### 修正前の問題
```cb
typedef Matrix2D = int[2][2];

Matrix2D create_matrix() {
    Matrix2D result;
    result[0][0] = 1; result[0][1] = 2;
    result[1][0] = 3; result[1][1] = 4;
    return result;
}

int main() {
    Matrix2D matrix = create_matrix();
    // 修正前: 以下で境界エラーが発生
    printf("Row 1: [%d, %d]", matrix[1][0], matrix[1][1]);
    //     ^^^^^^^^^^^^^^^^
    //     Error: Array index out of bounds: flat_index=2
    return 0;
}
```

#### 修正後の動作
```cb
typedef Matrix2D = int[2][2];

Matrix2D create_matrix() {
    Matrix2D result;
    result[0][0] = 1; result[0][1] = 2;
    result[1][0] = 3; result[1][1] = 4;
    return result;
}

int main() {
    Matrix2D matrix = create_matrix();
    printf("Matrix (2x2):\n");
    printf("Row 0: [%d, %d]\n", matrix[0][0], matrix[0][1]);
    printf("Row 1: [%d, %d]\n", matrix[1][0], matrix[1][1]);
    
    // 出力:
    // Matrix (2x2):
    // Row 0: [1, 2]
    // Row 1: [3, 4]  ← 修正により正常動作
    
    return 0;
}
```

---

## 🔧 技術的改善

### 1. Variable Manager改善
**ファイル**: `src/backend/interpreter/managers/variable_manager.cpp`

**問題**: 配列戻り値処理で`ret.int_array_3d[0][0]`として1次元配列のみを処理
```cpp
// 修正前
if (!ret.int_array_3d.empty() && !ret.int_array_3d[0].empty() && 
    !ret.int_array_3d[0][0].empty()) {
    var.array_values = ret.int_array_3d[0][0];  // 1次元のみ
    var.array_size = var.array_values.size();
}
```

**解決**: 多次元配列の全要素を展開して`multidim_array_values`に設定
```cpp
// 修正後
std::string actual_type = interpreter_->type_manager_->resolve_typedef(ret.array_type_name);
bool is_multidim = (actual_type.find("[][]") != std::string::npos || 
                   ret.array_type_name.find("[][]") != std::string::npos ||
                   ret.int_array_3d.size() > 1 || 
                   (ret.int_array_3d.size() == 1 && ret.int_array_3d[0].size() > 1));

if (is_multidim) {
    // 多次元配列の場合 - 全要素を展開
    var.multidim_array_values.clear();
    for (const auto &plane : ret.int_array_3d) {
        for (const auto &row : plane) {
            for (const auto &element : row) {
                var.multidim_array_values.push_back(element);
            }
        }
    }
    var.array_size = var.multidim_array_values.size();
    var.is_multidimensional = true;
    
    // 配列の次元情報を設定
    if (!ret.int_array_3d[0].empty()) {
        var.array_dimensions.clear();
        var.array_dimensions.push_back(ret.int_array_3d[0].size());     // 行数
        var.array_dimensions.push_back(ret.int_array_3d[0][0].size()); // 列数
    }
}
```

### 2. Statement Executor強化
**ファイル**: `src/backend/interpreter/executor/statement_executor.cpp`

**追加機能**: ReturnException処理で多次元配列判定・次元情報設定を実装
```
平均テスト実行時間: 13.77ms
最速テスト: 7.20ms
テスト成功率: 100%
コードカバレッジ: Union型機能完全カバー
```

## 🎯 具体的な実装例

### リテラル値Union
```cb
typedef HttpStatus = 200 | 404 | 500;
typedef Direction = "up" | "down" | "left" | "right";

int main() {
    HttpStatus status = 200;  // OK
    Direction dir = "up";     // OK
    
    // HttpStatus invalid = 301; // エラー: 許可されていない値
    return 0;
}
```

### カスタム型Union with 再帰的typedef
```cb
typedef UserID = int;
typedef ProductID = string;
typedef ID = UserID | ProductID;

int main() {
    UserID uid = 12345;
    ID general_id = uid;  // OK: UserID → ID は互換性あり
    
    return 0;
}
```

### 構造体Union
```cb
struct User { int id; string name; }
struct Product { string code; int price; }
typedef Entity = User | Product;

int main() {
    User alice = {id: 1, name: "Alice"};
    Entity entity = alice;  // OK: User → Entity
    
    return 0;
}
```

### エラーハンドリング例
```cb
typedef RestrictedUnion = int | string;

int main() {
    RestrictedUnion valid1 = 42;        // OK
    RestrictedUnion valid2 = "hello";   // OK
    
    bool flag = true;
    // RestrictedUnion invalid = flag;  // 実行時エラー: bool型は許可されていない
    
    return 0;
}
```

## 🐛 バグ修正

### 型システムの修正
- **再帰的typedef解決**: 無限ループ回避と継承チェーン対応
- **混合Union検証**: リテラル値と型の正確な区別
- **エラーメッセージ**: より具体的で分かりやすいエラー表示

### パーサーの改善
- **Union typedef構文**: 完全なBNF対応
- **AST生成**: Union型専用ノード追加
- **構文エラー**: 不正なUnion構文の適切な検出

## 🔄 互換性

### 後方互換性 ✅
- **既存コード**: v0.6.0以前のコードは完全に互換性維持
- **構造体**: 既存の構造体システムは変更なし
- **基本型**: プリミティブ型の動作は変更なし

### 新機能の影響
- **新構文**: Union typedef は新機能のため既存コードに影響なし
- **エラー検証**: より厳密な型チェックにより安全性向上
- **パフォーマンス**: 型検証の最適化により速度向上

## 📚 ドキュメント更新

### 更新されたドキュメント
- **README.md**: Union型システムの説明とサンプル追加
- **docs/spec.md**: 詳細な仕様とBNF記法追加
- **統合テスト**: 157個の新規テストケース追加

### 新規ドキュメント
- **Union型ガイド**: TypeScript開発者向け移行ガイド
- **エラーハンドリング**: 13種類の異常系対応マニュアル

## 🚀 次期バージョン予定 (v0.8.0)

### 計画中の機能
- **enum型の完全実装**: Union型との連携強化
- **interface/trait**: 抽象化システム
- **ジェネリクス**: 型パラメータ化機能
- **Result型**: 安全なエラーハンドリング

### パフォーマンス改善
- **コンパイル時最適化**: Union型の静的解決
- **メモリ使用量削減**: 型情報の効率的な格納
- **並列型チェック**: マルチスレッド型検証

## 🙏 謝辞

v0.7.0のリリースにあたり、TypeScript風Union型システムの完全実装を達成することができました。

### 技術的成果
- **925個のテスト**: 100%成功率達成
- **型安全性**: 実行時型エラーの完全な検出
- **開発者体験**: 直感的なUnion型構文の提供

この機能により、Cb言語はより表現力豊かで安全なプログラミング言語として大きく前進しました。

---

## 📖 詳細情報

- **GitHub**: https://github.com/shadowlink0122/Cb
- **ドキュメント**: [docs/spec.md](../docs/spec.md)
- **サンプルコード**: [sample/](../sample/)
- **テストケース**: [tests/cases/union/](../tests/cases/union/)

**Happy Coding with Union Types! 🎉**
