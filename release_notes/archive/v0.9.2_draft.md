# Cb言語 v0.9.2 リリースノート

## リリース日
2025年10月10日

## 概要
v0.9.2では、**Long型オーバーフロー修正**、**Const型安全性の強化**、**配列の参照渡し**、**構造体メンバの再帰的代入**を実施しました。Fibonacci計算でのLong型の正しい扱いを修正し、const修飾子による型安全性を部分的に実装し、配列と構造体の操作性を大幅に改善しました。

---

## ✨ 新機能と修正

### 1. 🔴 Long型オーバーフロー修正（重要なバグ修正）

**問題**: Fibonacci計算でF(48)以降の値が正しく計算されない

**根本原因**:
- `TYPE_LONG`の配列要素読み取り時に、int64_tをint32_tとして扱っていた
- 大きな整数リテラル(>INT32_MAX)がTYPE_INTと誤判定されていた

**修正内容**:

1. **evaluator.cpp (lines 919-933)**: TYPE_LONG配列の読み取り処理
```cpp
// Before (誤り)
case TYPE_LONG: {
    int32_t long_val = static_cast<int32_t>(raw_value & 0xFFFFFFFF);
    typed_value = static_cast<int64_t>(long_val);
}

// After (正しい)
case TYPE_LONG: {
    typed_value = raw_value;  // 64bit値をそのまま使用
    break;
}
case TYPE_INT: {
    int32_t int_val = static_cast<int32_t>(raw_value & 0xFFFFFFFF);
    typed_value = static_cast<int64_t>(int_val);
    break;
}
```

2. **eval.cpp (lines 70-84)**: 大きな整数リテラルの型推論
```cpp
// INT32の範囲を超える値は自動的にTYPE_LONGに
if (value < INT32_MIN || value > INT32_MAX) {
    int_type = InferredType(TYPE_LONG, "long");
} else if (inferred_type.type_info != TYPE_UNKNOWN) {
    int_type = inferred_type;
} else {
    int_type = InferredType(TYPE_INT, "int");
}
```

**修正ファイル**:
- `src/backend/interpreter/evaluator/core/evaluator.cpp`
- `src/backend/interpreter/evaluator/literals/eval.cpp`

**検証結果**:
```
F(48) = 4807526976 ✅ (修正前: 512559680 ❌)
F(92) = 7540113804746346496 ✅
大きなリテラル 5000000000 ✅ (修正前: 705032704 ❌)
```

---

### 2. 🛡️ Const型安全性の部分実装

**実装内容**:
- `const T*` (pointed-to constness) のチェック
- `T* const` (pointer constness) のチェック
- 関数パラメータでのconst違反検出

**検証されたケース**:

1. **Pointed-to constness** (`const T*`)
```cb
const int* ptr = &x;
*ptr = 100;  // ❌ Error: Cannot modify value through const pointer
```

2. **Pointer constness** (`T* const`)
```cb
int* const ptr = &x;
ptr = &y;  // ❌ Error: Cannot reassign const pointer
```

3. **関数パラメータでのチェック**
```cb
void func(int* p) { *p = 100; }
void main() {
    const int* ptr = &x;
    func(ptr);  // ❌ Error: Cannot pass const T* to T*
}
```

**テストケース**:
- `tests/cases/const_pointer_safety/` - 8件の安全性テスト

**実装ファイル**:
- `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
- `src/backend/interpreter/evaluator/functions/call_impl.cpp`

**制限事項**:
- ⚠️ 関数戻り値でのconst情報は現在未実装
- ⚠️ 完全なRust Pin相当の保証はv0.10.0で実装予定

---

### 3. 🔄 配列の参照渡し（関数引数）

**実装内容**:
- 関数に配列を渡す際、C/C++と同様に参照として渡される
- 関数内での配列要素の変更が呼び出し元に反映される
- `Variable`構造体の`is_reference`フラグを活用した実装

**コード例**:
```cb
void modify(int[3] arr) {
    arr[0] = 100;  // 呼び出し元の配列が変更される
}

void main() {
    int[3] nums = [1, 2, 3];
    println(nums[0]);  // 1
    modify(nums);
    println(nums[0]);  // 100
}
```

**実装ファイル**:
- `src/backend/interpreter/evaluator/functions/call_impl.cpp`
- `src/backend/interpreter/managers/variables/manager.cpp`
- `src/backend/interpreter/evaluator/access/array.cpp`
- `src/backend/interpreter/managers/common/operations.cpp`

**テストケース**:
- ポインタ配列のスワップテスト
- const配列パラメータのエラーチェック

**注意事項**:
- ⚠️ 配列参照**型**（`int[N]&`形式の型宣言）は未実装
- ⚠️ 明示的な参照型宣言は v0.10.0 で実装予定

---

### 4. 🏗️ 構造体メンバの再帰的代入

**実装内容**:
- ネストした構造体メンバへの直接代入をサポート
- 4レベル以上の深いネストにも対応
- 新しい解決ヘルパークラスによる実装

**コード例**:
```cb
struct Inner { int value; string name; };
struct Middle { Inner data; int count; };
struct Outer { Middle mid; int id; };

void main() {
    Outer obj;
    obj = {mid: {data: {value: 10, name: "test"}, count: 5}, id: 1};
    
    // ネストしたメンバへの直接代入
    obj.mid.data.value = 100;
    obj.mid.data.name = "updated";
    
    // 4レベルのネスト
    struct Level4 { int x; };
    struct Level3 { Level4 l4; };
    struct Level2 { Level3 l3; };
    struct Level1 { Level2 l2; };
    
    Level1 deep;
    deep = {l2: {l3: {l4: {x: 42}}}};
    deep.l2.l3.l4.x = 999;  // 動作OK
}
```

**実装ファイル**:
- `src/backend/interpreter/executors/assignments/member_assignment.cpp`
- `src/backend/interpreter/executors/assignments/recursive_member_resolver.h`（新規）
- `src/backend/interpreter/executors/assignments/nested_path_resolver.h`（新規）
- `src/backend/interpreter/executors/assignments/member_path_builder.h`（新規）
- `src/backend/interpreter/managers/structs/member_variables.cpp`
- `src/backend/interpreter/managers/variables/initialization.cpp`

**テストケース**:
- `tests/cases/struct/test_nested_member_assignment.cb`

---

## 🐛 バグ修正

### 1. Long型の配列要素読み取り
- **問題**: TYPE_LONG配列の要素がint32_tとして読み取られていた
- **影響**: Fibonacci(48)以降の計算結果が不正確
- **修正**: 64bit値としてそのまま扱うように修正

### 2. 大きな整数リテラルの型推論
- **問題**: 5000000000のような大きな値がTYPE_INTと誤判定
- **影響**: オーバーフローによる値の破損
- **修正**: INT32範囲外の値は自動的にTYPE_LONGに分類

---

## 📊 テスト結果

### 統合テスト
```
Total:  2365
Passed: 2365 ✅
Failed: 0
```

### ユニットテスト
```
Total:  30
Passed: 30 ✅
Failed: 0
```

### 合計
```
総テスト数: 2395
成功率: 100% ✅
```

**主要なテスト分類**:
- Pointer Tests: 388件
- Array Tests: 500+件（配列参照渡しテスト含む）
- Struct Tests: 200+件（ネストメンバ代入テスト含む）
- Function Tests: 300+件
- Const Safety Tests: 8件（新規）
- その他: 1000+件

---

## 🔄 後方互換性

- ✅ **完全な後方互換性**: v0.9.1のコードは全て動作
- ✅ **破壊的変更なし**: APIの変更なし
- ✅ **Long型の修正**: より正確な動作を提供

---

## 📈 コード変更統計

```
主要な変更ファイル:
1. Long型修正:
   - evaluator.cpp: TYPE_LONG処理の修正
   - eval.cpp: 整数リテラル型推論の改善

2. Const型安全性:
   - simple_assignment.cpp: const安全性チェック追加
   - call_impl.cpp: 関数パラメータのconst検証

3. 配列参照渡し:
   - call_impl.cpp: 配列参照処理の実装（+45行）
   - manager.cpp: assign_array_parameter実装（+40行）
   - array.cpp: 参照解決追加（+8行）
   - operations.cpp: assign_array_element_safe改善（+32行）

4. 構造体メンバ再帰処理:
   - member_assignment.cpp: リファクタリング（-103行）
   - recursive_member_resolver.h: 新規作成（+189行）
   - nested_path_resolver.h: 新規作成（+139行）
   - member_path_builder.h: 新規作成（+72行）
   - member_variables.cpp: 機能追加（+47行）
   - initialization.cpp: 機能追加（+102行）

総追加行数: 約600行
総削除行数: 約120行
```

---

## 🎯 次バージョン（v0.10.0）の計画

### 実装予定機能

1. **配列参照型（`int[N]&`形式）**
   - 明示的な配列参照型宣言のサポート
   - 構文: `void modify(int[3]& arr) { ... }`
   - 型安全性の向上

2. **Const型安全性の完全実装**
   - 関数戻り値でのconst情報保持
   - 完全なRust Pin<&T>相当の保証
   
3. **高度なポインタ機能**
   - ポインタ演算の境界チェック改善
   - 動的メモリ管理（`new`/`delete`）
   - ポインタキャスト（`static_cast<T>()`）

4. **スタックトレース**
   - 実行時エラーでの呼び出し履歴表示
   - デバッグの改善

---

## 🔗 関連ドキュメント

- `README.md` - プロジェクト概要とクイックスタート
- `docs/spec.md` - 言語仕様書（v0.9.2対応）
- `docs/architecture.md` - アーキテクチャ設計
- `release_notes/v0.9.1.md` - 前バージョンのリリースノート
- `release_notes/v0.9.0.md` - v0.9.0リリースノート

---

## 🛠️ 技術的な詳細

### Long型の内部表現

Cb言語では以下の整数型をサポートしています:

| 型 | ビット幅 | 範囲 |
|----|---------|------|
| tiny | 8bit | -128 ~ 127 |
| short | 16bit | -32,768 ~ 32,767 |
| int | 32bit | -2,147,483,648 ~ 2,147,483,647 |
| long | 64bit | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

v0.9.2の修正により、long型が完全に64bit値として扱われるようになりました。

### Const修飾子の型システム

Const修飾子には2種類あります:

1. **Pointed-to constness** (`const T*`)
   - ポインタが指す先の値を変更不可
   - ポインタ自体は再代入可能

2. **Pointer constness** (`T* const`)
   - ポインタ自体を再代入不可
   - ポインタが指す先の値は変更可能

3. **Both** (`const T* const`)
   - 両方の制約を持つ（Rust Pin<&T>相当）

---

## 👥 貢献者

- shadowlink0122

---

## 📄 ライセンス

このプロジェクトは従来通りのライセンスの下で公開されています。

---

**リリース日**: 2025年10月10日  
**Git branch**: feature/v0.9.2  
**Base version**: v0.9.1  
**Tag**: v0.9.2

---

## 🔍 変更の詳細

### コミット履歴（主要な変更）

1. **fix: Long型配列の読み取り修正**
   - evaluator.cppでTYPE_LONGを64bitとして扱うように修正
   - Fibonacci(92)まで正確に計算可能に

2. **fix: 大きな整数リテラルの型推論改善**
   - eval.cppでINT32範囲外の値をTYPE_LONGに自動分類
   - 5000000000のような大きな値が正しく扱えるように

3. **feat: Const型安全性の部分実装**
   - const T*とT* constの違反を検出
   - 関数パラメータでのconst検証を追加

4. **feat: 配列を参照として関数に渡す実装** (コミット e1a0431)
   - 配列は関数引数として自動的に参照渡しに
   - ポインタ配列のスワップが正常動作
   - const配列パラメータの制約も適用

5. **feat: 構造体メンバの再帰処理** (コミット bfdb4fa)
   - ネストした構造体メンバへの代入をサポート
   - 新しいヘルパークラスで実装を整理
   - 4レベル以上の深いネストに対応

---

これで v0.9.2 の全機能とバグ修正が完了しました。次バージョン（v0.10.0）では、より高度なポインタ機能と完全なconst型安全性に取り組む予定です。
