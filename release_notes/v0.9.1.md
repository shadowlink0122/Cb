# Cb言語 v0.9.1 リリースノート

## リリース日
2025年10月9日

## 概要
v0.9.1では、**Phase 5-8のコードベース大規模リファクタリング**と**const pointer safety機能**、**多次元配列ポインタ機能**を実装しました。

### 主要な変更点
1. **Const Pointer Safety**
   - `const T*`, `T* const`, `const T* const`の完全サポート
   - const違反の検出と防止
   
2. **多次元配列ポインタ**
   - `&matrix[i][j]`形式のポインタ取得
   - 多次元配列要素のアドレス操作

3. **Phase 5-8リファクタリング完了**
   - ディレクトリ構造の再編成（230ファイル、+46,382行、-25,649行）
   - evaluator, executors, handlers, managersの階層化
   - DRY原則の徹底適用（TypeHelpers導入）

### テスト結果
- **2,447件の統合テスト** - 全て合格 ✅
- **50件のユニットテスト** - 全て合格 ✅
- **合計2,497テスト** - 100%成功

## ✨ 新機能

### 1. Const Pointer Safety（const安全性の強化）

const変数の安全性を徹底する機能を実装しました。C言語と同様の`const T*`、`T* const`、`const T* const`の3種類をサポートし、const違反を完全に検出・防止します。

#### サポートされるconst修飾パターン

| 型 | 意味 | 例 |
|---|---|---|
| `const int*` | ポインタが指す先がconst | `const int* ptr = &x;` |
| `int* const` | ポインタ自体がconst | `int* const ptr = &x;` |
| `const int* const` | 両方const | `const int* const ptr = &x;` |

#### 検出される違反パターン

**1. const変数のアドレス → 非constポインタ**
```cb
const int x = 42;
int* ptr = &x;  // ❌ Error
```

**2. const T*のアドレス → T**
```cb
const int* ptr1 = &x;
int** ptr2 = &ptr1;  // ❌ Error
```

**3. T* constのアドレス → T**
```cb
int* const ptr1 = &x;
int** ptr2 = &ptr1;  // ❌ Error
```

#### 正しい使い方

```cb
const int x = 42;
const int* ptr = &x;  // ✅ OK
*ptr;  // 読み取り可能
```

#### エラーメッセージ例

```
Error: Cannot assign address of const variable 'x' to non-const pointer 'ptr'. 
Use 'const int*' instead of 'int*'
```

#### 実装詳細
- **主要ファイル**: 
  - `src/backend/interpreter/executors/assignments/const_check_helpers.h` - const検証ロジック
  - `src/backend/interpreter/executors/assignments/simple_assignment.cpp` - 代入時チェック
  - `src/backend/interpreter/executors/declarations/variable_declaration.cpp` - 宣言時チェック
  
- **ASTフラグ**: 
  - `is_const_pointer` - ポインタ自体のconst
  - `pointed_is_const` - 指す先のconst

- **テスト**: 
  - `tests/cases/const_pointer/` - 基本テスト
  - `tests/cases/const_pointer_safety/` - 安全性テスト（25テスト）

---

### 2. 多次元配列ポインタ

多次元配列の要素に対するアドレス操作をサポートしました。

#### 機能概要

```cb
int[3][3] matrix = {{1,2,3},{4,5,6},{7,8,9}};
int* ptr = &matrix[1][1];  // ✅ OK: 要素[1][1]のアドレス取得
println(*ptr);  // 5
```

#### 実装詳細
- **ファイル**: `src/backend/interpreter/evaluator/access/address_ops.cpp`
- `&matrix[i][j]`形式のポインタ取得をサポート
- ArrayAccessNode→AddressOperatorNodeの処理
- ポインタ経由の値アクセスも正常動作

#### サンプルコード
```cb
int[2][3] arr = {{1,2,3},{4,5,6}};
int* p1 = &arr[0][0];  // 先頭要素
int* p2 = &arr[1][2];  // 最後の要素
println(*p1);  // 1
println(*p2);  // 6
```

## 🔧 リファクタリング（Phase 5-8完了）

v0.9.1では、コードベース全体の大規模な再編成を実施しました。Phase 1-4の計画段階を経て、Phase 5-8で実装を完了させました。

### 変更規模
- **230ファイル変更**
- **+46,382行追加**
- **-25,649行削除**
- **純増: +20,733行**（コメント、ドキュメント、テスト含む）

### 主要な変更

#### 1. ディレクトリ構造の再編成

**新しい階層構造**:
```
src/backend/interpreter/
├── evaluator/              ← 新規: 評価ロジック
│   ├── access/            (アクセス操作)
│   ├── literals/          (リテラル評価)
│   └── operations/        (演算操作)
├── executors/              ← 新規: 実行ロジック
│   ├── assignments/       (代入処理)
│   ├── declarations/      (宣言処理)
│   └── statements/        (文実行)
├── handlers/               ← 新規: ハンドラー
│   ├── array/             (配列操作)
│   ├── function/          (関数呼び出し)
│   └── struct/            (構造体操作)
└── managers/               ← 新規: マネージャー
    ├── memory/            (メモリ管理)
    ├── scope/             (スコープ管理)
    └── type/              (型管理)
```

**削除されたファイル**: `interpreter.cpp` (5,000行超の巨大ファイル)

#### 2. DRY原則の徹底

**TypeHelpers導入**:
重複していた型チェックロジックを`TypeHelpers`に集約しました。

```cpp
// Before: 各ファイルで重複実装
bool isNumeric = (type == "int" || type == "long" || ...);

// After: TypeHelpersで統一
bool isNumeric = TypeHelpers::isNumericType(type);
```

**統合された関数**:
- `isNumericType()` - 数値型チェック
- `isIntegerType()` - 整数型チェック
- `isFloatingPointType()` - 浮動小数点型チェック
- `isPointerType()` - ポインタ型チェック
- `isArrayType()` - 配列型チェック
- `needsCast()` - キャスト必要性判定

**効果**:
- コードの重複排除（約500行削減）
- メンテナンス性向上
- バグ混入リスク低減

#### 3. レイヤー化アーキテクチャ

**責務の分離**:
- **Evaluator**: 式の評価（値の計算）
- **Executor**: 文の実行（副作用の実行）
- **Handler**: 複雑な操作の処理（関数呼び出し、配列操作等）
- **Manager**: 状態の管理（スコープ、メモリ、型情報等）

**利点**:
- 単一責任原則の徹底
- テストの容易性向上
- 依存関係の明確化

## 📊 メトリクス

### コミット構成（squash後）

#### Commit 1: Refactoring (Phase 5-8)
```
230 files changed
+46,382 insertions
-25,649 deletions
```

**主な変更**:
- ディレクトリ構造再編成
- interpreter.cpp分割（5,000行→複数の小ファイル）
- TypeHelpers導入とDRY原則適用

#### Commit 2: Features (v0.9.1)
```
70 files changed
+2,558 insertions
-333 deletions
```

**主な変更**:
- Const pointer safety実装
- 多次元配列ポインタ実装
- 25個の新規テスト追加

### テスト結果

```
統合テスト: 2,447件 - 100% 合格 ✅
ユニットテスト: 50件 - 100% 合格 ✅
合計: 2,497テスト - 100% 成功
```

### ビルド時間
- 並列ビルド（`make -j4`）: 約15秒
- 全テスト実行: 約2-3分

## 🔄 後方互換性

- ✅ **完全な後方互換性**: v0.9.0のコードは全て動作
- ✅ **破壊的変更なし**: APIの変更なし
- ✅ **テスト100%合格**: 全2,497テストが合格

## 🛠️ ビルドシステム

### Makefile
- 並列ビルド対応（`make -j4`）
- 分割されたオブジェクトファイルの管理
- テストターゲット（`make test`）

### ビルド手順
```bash
make clean
make -j4
make test
```

## 📝 技術的な改善

### 解決した課題

#### 1. CI/CD対応
- **Lintエラー**: デバッグコードの削除
- **コンパイル警告**: 全て修正
  - pragma directives（GCC/Clang互換性）
  - format specifiers（PRId64使用）
  - sign comparisons（static_cast使用）
- **ヘッダー不足**: `<optional>`, `<functional>`追加

#### 2. Const検証ロジック
- `const_check_helpers.h`で統一的なconst検証
- `is_const_pointer`と`pointed_is_const`フラグの導入
- 代入、宣言、初期化の全段階でチェック

#### 3. 多次元配列アドレス取得
- `ArrayAccessNode`→`AddressOperatorNode`の連携
- メモリレイアウトの正確な計算
- ポインタ経由の値アクセスのサポート

## 🎯 今後の計画（v0.9.2以降）

### 残りの高度なポインタ機能
3. 構造体配列メンバーの関数戻り値代入
4. 多次元配列の関数戻り値からメンバー代入
5. 多重ポインタ（`int**`, `int***`）
6. 配列参照型（`int[N]&`）

### 動的メモリ管理
7. new演算子
8. delete演算子
9. キャスト演算子
10. 動的配列アクセス `[]`

詳細は `docs/todo/v0.9.2_plan.md` を参照してください。

## 🔗 関連ドキュメント

- `README.md` - プロジェクト概要とクイックスタート
- `docs/spec.md` - 言語仕様書（v0.9.1対応）
- `docs/architecture.md` - アーキテクチャ設計
- `docs/README.md` - ドキュメント索引
- `docs/todo/v0.9.2_plan.md` - 次バージョン計画

## 👥 貢献者

- shadowlink0122

## 📄 ライセンス

このプロジェクトは従来通りのライセンスの下で公開されています。

---

**次のバージョン (v0.9.2) 予定**:
- 構造体配列メンバーの関数戻り値代入
- 多次元配列の関数戻り値からメンバー代入
- 多重ポインタ（`int**`, `int***`）
- 配列参照型（`int[N]&`）

**リリース日**: 2025年10月9日  
**Git branch**: refactor  
**Base commit**: 851adef (feat: Enable struct value members with forward declaration)
