# Cbè¨€èª v0.12.0 ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆ

**ãƒªãƒªãƒ¼ã‚¹æ—¥**: 2025å¹´1æœˆ  
**ãƒ†ãƒ¼ãƒ**: å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯å®Œå…¨å®Ÿè£…ã¨ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®æ‹¡å¼µ

---

## ğŸ‰ ä¸»è¦æ©Ÿèƒ½

### 1. Future<T>ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹åŒ–

**æ¦‚è¦**:
- `Future<T>`ãŒçµ„ã¿è¾¼ã¿å‹ã«ãªã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®šç¾©ã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã—ãŸ
- `Option<T>`ã€`Result<T,E>`ã¨åŒæ§˜ã«ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã¨ã—ã¦æä¾›

**å¤‰æ›´ç‚¹**:
```cb
// v0.12.0ä»¥å‰ï¼ˆå¿…è¦ã ã£ãŸå®šç¾©ï¼‰
struct Future<T> {
    T value;
    bool is_ready;
}

// v0.13.0ä»¥é™ï¼ˆå®šç¾©ä¸è¦ï¼‰
async Future<int> my_task() {
    return 42;
}
```

**æŠ€è¡“è©³ç´°**:
- `RecursiveParser::initialize_builtin_types()`ã§ç™»éŒ²
- `Interpreter::register_builtin_struct_future()`ã§åŒæœŸ
- Parserã¨Interpreteré–“ã§è‡ªå‹•åŒæœŸ

---

### 2. è‡ªå‹•yieldæ©Ÿèƒ½

**æ¦‚è¦**:
- yieldæ–‡ã‚’æ˜ç¤ºçš„ã«æ›¸ã‹ãªãã¦ã‚‚ã€å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå®Ÿè¡Œå¾Œã«è‡ªå‹•çš„ã«yield
- é•·æ™‚é–“å®Ÿè¡Œã•ã‚Œã‚‹é–¢æ•°ã§ã‚‚å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ãŒè‡ªå‹•çš„ã«å‹•ä½œ

**å‹•ä½œ**:
```cb
// yieldæ–‡ãªã—: å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå¾Œã«è‡ªå‹•yield
async Future<int> task1() {
    println("Statement 1");  // â† è‡ªå‹•yield
    println("Statement 2");  // â† è‡ªå‹•yield
    println("Statement 3");  // â† è‡ªå‹•yield
    return 10;
}

// æ˜ç¤ºçš„ãªyieldæ–‡ã‚ã‚Š: å¾“æ¥é€šã‚Šã®å‹•ä½œ
async Future<int> task2() {
    println("Before yield");
    yield;  // â† æ˜ç¤ºçš„ãªyield
    println("After yield");
    return 20;
}
```

**å®Ÿè£…**:
- `has_yield_statement()`ã§ASTå†…ã®yieldæ–‡ã‚’æ¤œå‡º
- `AsyncTask::auto_yield`ãƒ•ãƒ©ã‚°ã§è‡ªå‹•yieldæœ‰åŠ¹åŒ–
- `SimpleEventLoop::execute_one_step()`ã§å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå¾Œã«yield

---

### 3. awaitã«ã‚ˆã‚‹è‡ªå‹•Event Loopå®Ÿè¡Œ

**æ¦‚è¦**:
- `await`å¼ãŒFutureã®å®Œäº†ã‚’å¾…ã¤éš›ã€è‡ªå‹•çš„ã«SimpleEventLoopã‚’å®Ÿè¡Œ
- å¾“æ¥ã®`run_event_loop()`å‘¼ã³å‡ºã—ãŒä¸è¦ã«

**ä½¿ç”¨ä¾‹**:
```cb
// v0.12.0ä»¥é™ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ï¼‰
void main() {
    Future<int> f1 = task1();
    Future<int> f2 = task2();
    
    int r1 = await f1;  // â† SimpleEventLoopè‡ªå‹•å®Ÿè¡Œ
    int r2 = await f2;  // â† SimpleEventLoopè‡ªå‹•å®Ÿè¡Œ
    
    println("Results: {r1}, {r2}");
}
```

**æ—§æ–¹å¼**ï¼ˆv0.12.0ä»¥å‰ï¼‰:
```cb
void main() {
    Future<int> f1 = task1();
    Future<int> f2 = task2();
    
    run_event_loop();  // â† æ˜ç¤ºçš„ãªå‘¼ã³å‡ºã—ãŒå¿…è¦ã ã£ãŸ
    
    int r1 = f1.value;
    int r2 = f2.value;
}
```

---

## ğŸ”§ æŠ€è¡“çš„æ”¹å–„

### Parser/InterpreteråŒæœŸã®å¼·åŒ–

- `sync_struct_definitions_from_parser()`ã§Parserã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚’Interpreterã«åŒæœŸ
- ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®ä¸€è²«æ€§ã‚’ä¿è¨¼

### Event Loopå®Ÿè£…

- `SimpleEventLoop::has_yield_statement()`: ASTå†…ã®yieldæ–‡ã‚’å†å¸°çš„ã«æ¤œå‡º
- `SimpleEventLoop::register_task()`: ã‚¿ã‚¹ã‚¯ç™»éŒ²æ™‚ã«auto_yieldåˆ¤å®š
- `SimpleEventLoop::execute_one_step()`: auto_yieldãƒ•ãƒ©ã‚°ã«åŸºã¥ãå®Ÿè¡Œåˆ¶å¾¡

---

## ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœ

ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒæˆåŠŸ:

| ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ | èª¬æ˜ | çµæœ |
|------------|------|------|
| `test_future_basic.cb` | ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Future<T>ã®åŸºæœ¬å‹•ä½œ | âœ… |
| `phase1_syntax_test.cb` | async/awaitæ§‹æ–‡ | âœ… |
| `phase1_multiple_async.cb` | è¤‡æ•°asyncé–¢æ•° | âœ… |
| `phase2_yield_test.cb` | yieldæ–‡ã«ã‚ˆã‚‹å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ | âœ… |
| `phase2_auto_yield_test.cb` | è‡ªå‹•yieldæ©Ÿèƒ½ | âœ… |
| `phase2_builtin_future_test.cb` | ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Future<T>ï¼ˆå®šç¾©ãªã—ï¼‰ | âœ… |

---

## ğŸ¯ é–‹ç™ºè€…ã¸ã®å½±éŸ¿

### ç ´å£Šçš„å¤‰æ›´

**ãªã—**: æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã¯å¼•ãç¶šãå‹•ä½œã—ã¾ã™ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®`struct Future<T>`ãŒã‚ã‚‹å ´åˆã€ãã‚ŒãŒå„ªå…ˆçš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ï¼ˆãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚ˆã‚Šå„ªå…ˆï¼‰ã€‚

### æ¨å¥¨ã•ã‚Œã‚‹å¤‰æ›´

1. **Future<T>å®šç¾©ã®å‰Šé™¤**:
   ```cb
   // å‰Šé™¤ã§ãã‚‹
   // struct Future<T> {
   //     T value;
   //     bool is_ready;
   // }
   ```

2. **run_event_loop()ã®å‰Šé™¤**:
   ```cb
   // å‰Šé™¤ã§ãã‚‹
   // run_event_loop();
   
   // awaitã§è‡ªå‹•å®Ÿè¡Œã•ã‚Œã‚‹
   int result = await future;
   ```

---

## ğŸ“ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°

- `docs/features/async_await_design.md`: Phase 2.0å®Œå…¨å®Ÿè£…ãƒ¬ãƒãƒ¼ãƒˆè¿½åŠ 
- ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹: Future<T>å®šç¾©ã‚’å‰Šé™¤ã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚’ä½¿ç”¨

---

## ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆv0.13.0äºˆå®šï¼‰

- **I/Oçµ±åˆ**: éåŒæœŸãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿æ›¸ã
- **ä¸¦è¡Œå®Ÿè¡Œ**: è¤‡æ•°ã‚¿ã‚¹ã‚¯ã®çœŸã®ä¸¦è¡Œå®Ÿè¡Œ
- **spawn()**: æ–°ã—ã„ã‚¿ã‚¹ã‚¯ç”Ÿæˆ

---

## ğŸ†• v0.12.0ã§è¿½åŠ ã•ã‚ŒãŸæ©Ÿèƒ½

### sleep() çµ„ã¿è¾¼ã¿é–¢æ•°

**æ¦‚è¦**:
- å®Ÿè¡Œã‚’æŒ‡å®šã•ã‚ŒãŸãƒŸãƒªç§’æ•°ã ã‘ä¸€æ™‚åœæ­¢ã™ã‚‹çµ„ã¿è¾¼ã¿é–¢æ•°
- OSãƒã‚¤ãƒ†ã‚£ãƒ–ã®sleepæ©Ÿèƒ½ã‚’ä½¿ç”¨ï¼ˆWindows: `Sleep()`, POSIX: `usleep()`ï¼‰
- importãªã—ã§ç›´æ¥ä½¿ç”¨å¯èƒ½

**ä½¿ç”¨ä¾‹**:
```cb
int main() {
    println("é–‹å§‹");
    sleep(1000);  // 1ç§’ï¼ˆ1000ãƒŸãƒªç§’ï¼‰å¾…æ©Ÿ
    println("1ç§’å¾Œ");
    
    // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³
    int i = 5;
    while (i > 0) {
        println("%d...", i);
        sleep(1000);
        i = i - 1;
    }
    println("ç™ºå°„!");
    
    return 0;
}
```

**ã‚·ã‚°ãƒãƒãƒ£**:
```cb
void sleep(int milliseconds);
```

**å¼•æ•°**:
- `milliseconds` (int): å¾…æ©Ÿã™ã‚‹ãƒŸãƒªç§’æ•°ï¼ˆè² ã®å€¤ã¯ã‚¨ãƒ©ãƒ¼ï¼‰

**æˆ»ã‚Šå€¤**: ãªã—

**æ³¨æ„äº‹é …**:
- ã“ã®é–¢æ•°ã¯å®Ÿè¡Œã‚’**ãƒ–ãƒ­ãƒƒã‚¯**ã—ã¾ã™
- éåŒæœŸå‡¦ç†ã«ã¯é©ã—ã¦ã„ã¾ã›ã‚“ï¼ˆå°†æ¥çš„ã«`async sleep()`ã‚’å®Ÿè£…äºˆå®šï¼‰
- ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œï¼ˆWindows/Linux/macOSï¼‰

**å®Ÿè£…è©³ç´°**:
- `src/backend/interpreter/evaluator/functions/call_impl.cpp`ã«å®Ÿè£…
- ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«:
  ```cpp
  #ifdef _WIN32
      Sleep(milliseconds);  // Windows
  #else
      usleep(milliseconds * 1000);  // POSIX
  #endif
  ```

---

## â±ï¸ stdlib/std/timeãƒ‘ãƒƒã‚±ãƒ¼ã‚¸

**æ¦‚è¦**:
æ™‚é–“æ“ä½œã®ãŸã‚ã®åŒ…æ‹¬çš„ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¿½åŠ ã€‚`sleep()`é–¢æ•°ã‚’ãƒ©ãƒƒãƒ—ã—ãŸé«˜ãƒ¬ãƒ™ãƒ«APIã¨ã€æ™‚é–“è¨ˆç®—ã®ãŸã‚ã®ä¾¿åˆ©ãªé–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚

### ä¸»ãªæ©Ÿèƒ½

#### 1. æ™‚é–“å®šæ•°
```cb
import stdlib.std.time;

void main() {
    sleep(SECOND);       // 1000ms
    sleep(MINUTE);       // 60000ms
    sleep(HOUR);         // 3600000ms
    sleep(SECOND * 5);   // 5ç§’
}
```

**å®šç¾©**:
- `MILLISECOND = 1`
- `SECOND = 1000`
- `MINUTE = 60000`
- `HOUR = 3600000`

#### 2. ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
```cb
import stdlib.std.time;

void main() {
    sleep_seconds(3);    // 3ç§’å¾…æ©Ÿ
    sleep_minutes(2);    // 2åˆ†å¾…æ©Ÿ
}
```

**æä¾›ã•ã‚Œã‚‹é–¢æ•°**:
- `void sleep_seconds(int seconds)` - ç§’å˜ä½ã§ã‚¹ãƒªãƒ¼ãƒ—
- `void sleep_minutes(int minutes)` - åˆ†å˜ä½ã§ã‚¹ãƒªãƒ¼ãƒ—

#### 3. æ™‚é–“å¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
```cb
import stdlib.std.time;

void main() {
    int ms = minutes_to_milliseconds(5);  // 300000
    int s = milliseconds_to_seconds(5000);  // 5
}
```

**å¤‰æ›é–¢æ•°**:
- `int milliseconds_to_seconds(int ms)` - ãƒŸãƒªç§’ â†’ ç§’
- `int seconds_to_milliseconds(int seconds)` - ç§’ â†’ ãƒŸãƒªç§’
- `int minutes_to_milliseconds(int minutes)` - åˆ† â†’ ãƒŸãƒªç§’
- `int hours_to_milliseconds(int hours)` - æ™‚ â†’ ãƒŸãƒªç§’

#### 4. Durationæ§‹é€ ä½“
```cb
import stdlib.std.time;

void main() {
    // 125432ãƒŸãƒªç§’ã‚’æ§‹é€ åŒ–ã•ã‚ŒãŸæœŸé–“ã«å¤‰æ›
    Duration d = create_duration(125432);
    format_duration(d);  // "2m 5s 432ms" ã¨è¡¨ç¤º
    
    // é€†å¤‰æ›
    int total = duration_to_milliseconds(d);  // 125432
}
```

**Durationæ§‹é€ ä½“**:
```cb
struct Duration {
    int hours;
    int minutes;
    int seconds;
    int milliseconds;
};
```

**Durationé–¢é€£é–¢æ•°**:
- `Duration create_duration(int total_ms)` - ãƒŸãƒªç§’ã‹ã‚‰Durationä½œæˆ
- `int duration_to_milliseconds(Duration d)` - Durationã‚’ãƒŸãƒªç§’ã«å¤‰æ›
- `void format_duration(Duration d)` - äººé–“ãŒèª­ã¿ã‚„ã™ã„å½¢å¼ã§è¡¨ç¤º

### å®Ÿç”¨ä¾‹

#### ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼é¢¨å‡¦ç†
```cb
import stdlib.std.time;

void main() {
    int steps = 5;
    int i = 0;
    
    while (i < steps) {
        int percent = (i * 100) / steps;
        println("[%d%%] å‡¦ç†ä¸­...", percent);
        sleep(SECOND / 2);  // 0.5ç§’
        i = i + 1;
    }
    println("[100%%] å®Œäº†!");
}
```

#### ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒãƒ¼
```cb
import stdlib.std.time;

void main() {
    println("ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³é–‹å§‹");
    
    int count = 10;
    while (count > 0) {
        println("%dç§’", count);
        sleep_seconds(1);
        count = count - 1;
    }
    
    println("ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ!");
}
```

#### å‡¦ç†æ™‚é–“ã®è¡¨ç¤º
```cb
import stdlib.std.time;

void main() {
    int elapsed_ms = 125432;  // ä½•ã‚‰ã‹ã®å‡¦ç†æ™‚é–“
    
    Duration d = create_duration(elapsed_ms);
    print("å‡¦ç†æ™‚é–“: ");
    format_duration(d);  // "2m 5s 432ms"
}
```

### ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹æˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**:
- `stdlib/std/time.cb` - ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æœ¬ä½“
- `tests/cases/stdlib/test_time.cb` - åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ

**ä¾å­˜é–¢ä¿‚**:
- `sleep()` ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ã«ä¾å­˜ï¼ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸è¦ï¼‰
- ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¸ã®ä¾å­˜ãªã—

**ä½¿ç”¨æ–¹æ³•**:
```cb
import stdlib.std.time;

// ã“ã‚Œã§time.cbã§å®šç¾©ã•ã‚ŒãŸå…¨ã¦ã®å®šæ•°ã¨é–¢æ•°ãŒä½¿ç”¨å¯èƒ½
```

---

## ğŸ™ è¬è¾

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€Cbè¨€èªã¯**ãƒ¢ãƒ€ãƒ³ãªéåŒæœŸå‡¦ç†æ©Ÿèƒ½**ã‚’æŒã¤æœ€å…ˆç«¯ã®è¨€èªã«ãªã‚Šã¾ã—ãŸã€‚

å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ã®å®Œå…¨å®Ÿè£…ã¨ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®æ‹¡å¼µã«ã‚ˆã‚Šã€é–‹ç™ºè€…ä½“é¨“ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã—ãŸã€‚

**Happy Async Programming!** ğŸ‰
