# Cbè¨€èª v0.12.0 ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆ

**ãƒªãƒªãƒ¼ã‚¹æ—¥**: 2025å¹´1æœˆ  
**ãƒ†ãƒ¼ãƒ**: å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯å®Œå…¨å®Ÿè£…ã¨ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®æ‹¡å¼µ

---

## ğŸ‰ ä¸»è¦æ©Ÿèƒ½

### 1. Future<T>ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹åŒ–

**æ¦‚è¦**:
- `Future<T>`ãŒçµ„ã¿è¾¼ã¿å‹ã«ãªã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®šç¾©ã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã—ãŸ
- `Option<T>`ã€`Result<T,E>`ã¨åŒæ§˜ã«ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã¨ã—ã¦æä¾›

**å¤‰æ›´ç‚¹**:
```cb
// v0.12.0ä»¥å‰ï¼ˆå¿…è¦ã ã£ãŸå®šç¾©ï¼‰
struct Future<T> {
    T value;
    bool is_ready;
}

// v0.13.0ä»¥é™ï¼ˆå®šç¾©ä¸è¦ï¼‰
async Future<int> my_task() {
    return 42;
}
```

**æŠ€è¡“è©³ç´°**:
- `RecursiveParser::initialize_builtin_types()`ã§ç™»éŒ²
- `Interpreter::register_builtin_struct_future()`ã§åŒæœŸ
- Parserã¨Interpreteré–“ã§è‡ªå‹•åŒæœŸ

---

### 2. è‡ªå‹•yieldæ©Ÿèƒ½

**æ¦‚è¦**:
- yieldæ–‡ã‚’æ˜ç¤ºçš„ã«æ›¸ã‹ãªãã¦ã‚‚ã€å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå®Ÿè¡Œå¾Œã«è‡ªå‹•çš„ã«yield
- é•·æ™‚é–“å®Ÿè¡Œã•ã‚Œã‚‹é–¢æ•°ã§ã‚‚å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ãŒè‡ªå‹•çš„ã«å‹•ä½œ

**å‹•ä½œ**:
```cb
// yieldæ–‡ãªã—: å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå¾Œã«è‡ªå‹•yield
async Future<int> task1() {
    println("Statement 1");  // â† è‡ªå‹•yield
    println("Statement 2");  // â† è‡ªå‹•yield
    println("Statement 3");  // â† è‡ªå‹•yield
    return 10;
}

// æ˜ç¤ºçš„ãªyieldæ–‡ã‚ã‚Š: å¾“æ¥é€šã‚Šã®å‹•ä½œ
async Future<int> task2() {
    println("Before yield");
    yield;  // â† æ˜ç¤ºçš„ãªyield
    println("After yield");
    return 20;
}
```

**å®Ÿè£…**:
- `has_yield_statement()`ã§ASTå†…ã®yieldæ–‡ã‚’æ¤œå‡º
- `AsyncTask::auto_yield`ãƒ•ãƒ©ã‚°ã§è‡ªå‹•yieldæœ‰åŠ¹åŒ–
- `SimpleEventLoop::execute_one_step()`ã§å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå¾Œã«yield

---

### 3. awaitã«ã‚ˆã‚‹è‡ªå‹•Event Loopå®Ÿè¡Œ

**æ¦‚è¦**:
- `await`å¼ãŒFutureã®å®Œäº†ã‚’å¾…ã¤éš›ã€è‡ªå‹•çš„ã«SimpleEventLoopã‚’å®Ÿè¡Œ
- å¾“æ¥ã®`run_event_loop()`å‘¼ã³å‡ºã—ãŒä¸è¦ã«

**ä½¿ç”¨ä¾‹**:
```cb
// v0.12.0ä»¥é™ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ï¼‰
void main() {
    Future<int> f1 = task1();
    Future<int> f2 = task2();
    
    int r1 = await f1;  // â† SimpleEventLoopè‡ªå‹•å®Ÿè¡Œ
    int r2 = await f2;  // â† SimpleEventLoopè‡ªå‹•å®Ÿè¡Œ
    
    println("Results: {r1}, {r2}");
}
```

**æ—§æ–¹å¼**ï¼ˆv0.12.0ä»¥å‰ï¼‰:
```cb
void main() {
    Future<int> f1 = task1();
    Future<int> f2 = task2();
    
    run_event_loop();  // â† æ˜ç¤ºçš„ãªå‘¼ã³å‡ºã—ãŒå¿…è¦ã ã£ãŸ
    
    int r1 = f1.value;
    int r2 = f2.value;
}
```

---

## ğŸ”§ æŠ€è¡“çš„æ”¹å–„

### Parser/InterpreteråŒæœŸã®å¼·åŒ–

- `sync_struct_definitions_from_parser()`ã§Parserã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚’Interpreterã«åŒæœŸ
- ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®ä¸€è²«æ€§ã‚’ä¿è¨¼

### Event Loopå®Ÿè£…

- `SimpleEventLoop::has_yield_statement()`: ASTå†…ã®yieldæ–‡ã‚’å†å¸°çš„ã«æ¤œå‡º
- `SimpleEventLoop::register_task()`: ã‚¿ã‚¹ã‚¯ç™»éŒ²æ™‚ã«auto_yieldåˆ¤å®š
- `SimpleEventLoop::execute_one_step()`: auto_yieldãƒ•ãƒ©ã‚°ã«åŸºã¥ãå®Ÿè¡Œåˆ¶å¾¡

---

## ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœ

ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒæˆåŠŸ:

| ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ | èª¬æ˜ | çµæœ |
|------------|------|------|
| `test_future_basic.cb` | ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Future<T>ã®åŸºæœ¬å‹•ä½œ | âœ… |
| `phase1_syntax_test.cb` | async/awaitæ§‹æ–‡ | âœ… |
| `phase1_multiple_async.cb` | è¤‡æ•°asyncé–¢æ•° | âœ… |
| `phase2_yield_test.cb` | yieldæ–‡ã«ã‚ˆã‚‹å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ | âœ… |
| `phase2_auto_yield_test.cb` | è‡ªå‹•yieldæ©Ÿèƒ½ | âœ… |
| `phase2_builtin_future_test.cb` | ãƒ“ãƒ«ãƒˆã‚¤ãƒ³Future<T>ï¼ˆå®šç¾©ãªã—ï¼‰ | âœ… |

---

## ğŸ¯ é–‹ç™ºè€…ã¸ã®å½±éŸ¿

### ç ´å£Šçš„å¤‰æ›´

**ãªã—**: æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã¯å¼•ãç¶šãå‹•ä½œã—ã¾ã™ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®`struct Future<T>`ãŒã‚ã‚‹å ´åˆã€ãã‚ŒãŒå„ªå…ˆçš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ï¼ˆãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚ˆã‚Šå„ªå…ˆï¼‰ã€‚

### æ¨å¥¨ã•ã‚Œã‚‹å¤‰æ›´

1. **Future<T>å®šç¾©ã®å‰Šé™¤**:
   ```cb
   // å‰Šé™¤ã§ãã‚‹
   // struct Future<T> {
   //     T value;
   //     bool is_ready;
   // }
   ```

2. **run_event_loop()ã®å‰Šé™¤**:
   ```cb
   // å‰Šé™¤ã§ãã‚‹
   // run_event_loop();
   
   // awaitã§è‡ªå‹•å®Ÿè¡Œã•ã‚Œã‚‹
   int result = await future;
   ```

---

## ğŸ“ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°

- `docs/features/async_await_design.md`: Phase 2.0å®Œå…¨å®Ÿè£…ãƒ¬ãƒãƒ¼ãƒˆè¿½åŠ 
- ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹: Future<T>å®šç¾©ã‚’å‰Šé™¤ã€ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã‚’ä½¿ç”¨

---

## ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆv0.13.0äºˆå®šï¼‰

- **I/Oçµ±åˆ**: éåŒæœŸãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿æ›¸ã
- **ä¸¦è¡Œå®Ÿè¡Œ**: è¤‡æ•°ã‚¿ã‚¹ã‚¯ã®çœŸã®ä¸¦è¡Œå®Ÿè¡Œ
- **spawn()**: æ–°ã—ã„ã‚¿ã‚¹ã‚¯ç”Ÿæˆ

---

## ğŸ†• v0.12.0ã§è¿½åŠ ã•ã‚ŒãŸæ©Ÿèƒ½

### sleep() çµ„ã¿è¾¼ã¿é–¢æ•°

**æ¦‚è¦**:
- å®Ÿè¡Œã‚’æŒ‡å®šã•ã‚ŒãŸãƒŸãƒªç§’æ•°ã ã‘ä¸€æ™‚åœæ­¢ã™ã‚‹çµ„ã¿è¾¼ã¿é–¢æ•°
- OSãƒã‚¤ãƒ†ã‚£ãƒ–ã®sleepæ©Ÿèƒ½ã‚’ä½¿ç”¨ï¼ˆWindows: `Sleep()`, POSIX: `usleep()`ï¼‰
- importãªã—ã§ç›´æ¥ä½¿ç”¨å¯èƒ½

**ä½¿ç”¨ä¾‹**:
```cb
int main() {
    println("é–‹å§‹");
    sleep(1000);  // 1ç§’ï¼ˆ1000ãƒŸãƒªç§’ï¼‰å¾…æ©Ÿ
    println("1ç§’å¾Œ");
    
    // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³
    int i = 5;
    while (i > 0) {
        println("%d...", i);
        sleep(1000);
        i = i - 1;
    }
    println("ç™ºå°„!");
    
    return 0;
}
```

**ã‚·ã‚°ãƒãƒãƒ£**:
```cb
void sleep(int milliseconds);
```

**å¼•æ•°**:
- `milliseconds` (int): å¾…æ©Ÿã™ã‚‹ãƒŸãƒªç§’æ•°ï¼ˆè² ã®å€¤ã¯ã‚¨ãƒ©ãƒ¼ï¼‰

**æˆ»ã‚Šå€¤**: ãªã—

**æ³¨æ„äº‹é …**:
- ã“ã®é–¢æ•°ã¯å®Ÿè¡Œã‚’**ãƒ–ãƒ­ãƒƒã‚¯**ã—ã¾ã™
- éåŒæœŸå‡¦ç†ã«ã¯é©ã—ã¦ã„ã¾ã›ã‚“ï¼ˆå°†æ¥çš„ã«`async sleep()`ã‚’å®Ÿè£…äºˆå®šï¼‰
- ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œï¼ˆWindows/Linux/macOSï¼‰

**å®Ÿè£…è©³ç´°**:
- `src/backend/interpreter/evaluator/functions/call_impl.cpp`ã«å®Ÿè£…
- ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«:
  ```cpp
  #ifdef _WIN32
      Sleep(milliseconds);  // Windows
  #else
      usleep(milliseconds * 1000);  // POSIX
  #endif
  ```

---

## ğŸ™ è¬è¾

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€Cbè¨€èªã¯**ãƒ¢ãƒ€ãƒ³ãªéåŒæœŸå‡¦ç†æ©Ÿèƒ½**ã‚’æŒã¤æœ€å…ˆç«¯ã®è¨€èªã«ãªã‚Šã¾ã—ãŸã€‚

å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ã®å®Œå…¨å®Ÿè£…ã¨ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹ã®æ‹¡å¼µã«ã‚ˆã‚Šã€é–‹ç™ºè€…ä½“é¨“ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã—ãŸã€‚

**Happy Async Programming!** ğŸ‰
