# Cbè¨€èª v0.12.1 ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆï¼ˆæ—¥æœ¬èªï¼‰

**ãƒªãƒªãƒ¼ã‚¹æ—¥**: 2024å¹´11æœˆ9æ—¥  
**ä¸»è¦æ©Ÿèƒ½**: structãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ã®enumå¤‰æ•°ã‚µãƒãƒ¼ãƒˆã€ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã®ãƒ‘ãƒ¼ã‚¹

---

## ğŸ¯ æ¦‚è¦

v0.12.1ã¯ã€Cbè¨€èªã®enumå‹ã¨structå‹ã®çµ±åˆã‚’å¤§å¹…ã«æ”¹å–„ã—ã€`Future<Result<T, E>>`ã®ã‚ˆã†ãªãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã®å®Œå…¨ãªãƒ‘ãƒ¼ã‚¹ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ãŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãƒªãƒªãƒ¼ã‚¹ã§ã™ã€‚

---

## âœ¨ æ–°æ©Ÿèƒ½

### 1. ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã®ãƒ‘ãƒ¼ã‚¹ã‚µãƒãƒ¼ãƒˆ

`Future<Result<int, string>>`ã®ã‚ˆã†ãªè¤‡é›‘ã«ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã‚’å®Œå…¨ã«ã‚µãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚

```cb
// v0.12.1ã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼
Future<Result<int, string>> async_operation() {
    Result<int, string> result = Result<int, string>::Ok(42);
    Future<Result<int, string>> future;
    future.value = result;
    future.is_ready = true;
    return future;
}
```

**æŠ€è¡“è©³ç´°**:
- `>>`ãƒˆãƒ¼ã‚¯ãƒ³ã®æ–‡è„ˆä¾å­˜åˆ†å‰²ï¼ˆå‹ãƒ‘ãƒ¼ã‚¹ä¸­ã®ã¿ï¼‰
- ã‚¹ã‚³ãƒ¼ãƒ—ã‚¬ãƒ¼ãƒ‰ã«ã‚ˆã‚‹è‡ªå‹•ã‚¹ã‚¿ãƒƒã‚¯ç®¡ç†
- ã‚·ãƒ•ãƒˆæ¼”ç®—`x >> 2`ã¨ã®æ··åŒã‚’å®Œå…¨ã«é˜²æ­¢

### 2. structãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ã®enumå¤‰æ•°ã®å®Œå…¨ã‚µãƒãƒ¼ãƒˆ

enumå‹ã®å¤‰æ•°ã‚’structã®ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ä½¿ç”¨ã—ã€ä»£å…¥ãƒ»å–å¾—æ™‚ã«enumæƒ…å ±ï¼ˆvariantåã€é–¢é€£å€¤ãªã©ï¼‰ãŒæ­£ã—ãä¿æŒã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

**ä¿®æ­£å‰ï¼ˆv0.12.0ï¼‰**:
```cb
Container c;
c.data = ok;  // âŒ enumæƒ…å ±ãŒå¤±ã‚ã‚Œã‚‹
Result<int, string> r = c.data;  // variantåãŒç©ºæ–‡å­—åˆ—ã«
match (r) { ... }  // âŒ ã‚¨ãƒ©ãƒ¼
```

**ä¿®æ­£å¾Œï¼ˆv0.12.1ï¼‰**:
```cb
Container c;
c.data = ok;  // âœ… enumæƒ…å ±ãŒä¿æŒã•ã‚Œã‚‹
Result<int, string> r = c.data;  // âœ… æ­£ã—ãå–å¾—
match (r) {
    Ok(value) => println("å€¤: {value}"),  // âœ… å‹•ä½œï¼
    Err(msg) => println("ã‚¨ãƒ©ãƒ¼: {msg}")
}
```

---

## ğŸ”§ ä¿®æ­£ã•ã‚ŒãŸå•é¡Œ

### å•é¡Œ1: structãƒ¡ãƒ³ãƒãƒ¼ã¸ã®enumä»£å…¥æ™‚ã«æƒ…å ±ãŒå¤±ã‚ã‚Œã‚‹

**ç—‡çŠ¶**: 
```cb
Result<int, string> ok = Result<int, string>::Ok(42);
Container c;
c.data = ok;  // variantåã€é–¢é€£å€¤ãŒå¤±ã‚ã‚Œã‚‹
```

**åŸå› **: `assign_struct_member()`ãŒåŸºæœ¬çš„ãªå€¤ï¼ˆint64_tã€stringï¼‰ã®ã¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã€enumå›ºæœ‰ã®æƒ…å ±ã‚’ç„¡è¦–ã—ã¦ã„ã¾ã—ãŸã€‚

**è§£æ±ºç­–**:
1. `Variable`å…¨ä½“ã‚’å—ã‘å–ã‚‹æ–°ã—ã„ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’è¿½åŠ 
2. enumæƒ…å ±ã®å…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ˜ç¤ºçš„ã«ã‚³ãƒ”ãƒ¼
3. enumå¤‰æ•°ã®ä»£å…¥æ™‚ã«å°‚ç”¨ãƒ‘ã‚¹ã‚’ä½¿ç”¨

**ä¿®æ­£ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰**:
```cpp
// v0.12.1ã§è¿½åŠ 
if (value_var.is_enum || !value_var.enum_type_name.empty()) {
    member_var->is_enum = value_var.is_enum;
    member_var->enum_type_name = value_var.enum_type_name;
    member_var->enum_variant = value_var.enum_variant;
    member_var->has_associated_value = value_var.has_associated_value;
    member_var->associated_int_value = value_var.associated_int_value;
    member_var->associated_str_value = value_var.associated_str_value;
}
```

### å•é¡Œ2: structãƒ¡ãƒ³ãƒãƒ¼ã‹ã‚‰ã®enumå–å¾—æ™‚ã«æƒ…å ±ãŒå¤±ã‚ã‚Œã‚‹

**ç—‡çŠ¶**:
```cb
Result<int, string> r = c.data;  // variantåãŒç©ºæ–‡å­—åˆ—ã«ãªã‚‹
```

**åŸå› **: enumå¤‰æ•°ã®åˆæœŸåŒ–æ™‚ã€ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹å¼`c.data`ã‚’`eval_expression()`ã§è©•ä¾¡ã—ã€int64_tå€¤ã®ã¿ã‚’å–å¾—ã—ã¦ã„ã¾ã—ãŸã€‚

**è§£æ±ºç­–**: ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹å¼ã‚’æ¤œå‡ºã—ã€`get_struct_member()`ã§`Variable`å…¨ä½“ã‚’ç›´æ¥å–å¾—ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£ã€‚

**ä¿®æ­£ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰**:
```cpp
// v0.12.1ã§è¿½åŠ 
if (init_node->node_type == ASTNodeType::AST_MEMBER_ACCESS &&
    init_node->left && 
    init_node->left->node_type == ASTNodeType::AST_VARIABLE) {
    // obj.memberãƒ‘ã‚¿ãƒ¼ãƒ³
    std::string obj_name = init_node->left->name;
    std::string member_name = init_node->name;
    Variable *member_var = interpreter_->get_struct_member(obj_name, member_name);
    if (member_var && member_var->is_enum) {
        var = *member_var;  // å…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼
    }
}
```

### å•é¡Œ3: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯enumã®ãƒãƒ³ã‚°ãƒªãƒ³ã‚°åç™»éŒ²

**ç—‡çŠ¶**: `Result<int, string>`ãŒãƒ‘ãƒ¼ã‚¹ã§ãã‚‹ãŒã€å®Ÿè¡Œæ™‚ã«`Result_int_string`ã¨ã—ã¦å‚ç…§ã•ã‚Œã‚‹éš›ã«enumå®šç¾©ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€‚

**è§£æ±ºç­–**: ãƒ‘ãƒ¼ã‚µãƒ¼ã§ä¸¡æ–¹ã®åå‰ï¼ˆ`Result<int, string>`ã¨`Result_int_string`ï¼‰ã§enumå®šç¾©ã‚’ç™»éŒ²ã€‚

---

## ğŸ› ï¸ æŠ€è¡“çš„æ”¹å–„

### ãƒ‘ãƒ¼ã‚µãƒ¼ã®æ”¹å–„

#### 1. ã‚¹ã‚³ãƒ¼ãƒ—ã‚¬ãƒ¼ãƒ‰ã«ã‚ˆã‚‹è‡ªå‹•ã‚¹ã‚¿ãƒƒã‚¯ç®¡ç†

å‹ãƒ‘ãƒ¼ã‚¹ä¸­ã«`type_parameter_stack_`ã‚’è‡ªå‹•ç®¡ç†ã™ã‚‹ã“ã¨ã§ã€`>>`ãƒˆãƒ¼ã‚¯ãƒ³ã®åˆ†å‰²ã‚’å®‰å…¨ã«å®Ÿè¡Œï¼š

```cpp
std::string TypeUtilityParser::parseType() {
    bool should_manage_stack = parser_->type_parameter_stack_.empty();
    if (should_manage_stack) {
        parser_->type_parameter_stack_.push_back({});  // push
    }
    
    // C++ã®RAIIãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†æ™‚ã«è‡ªå‹•pop
    std::shared_ptr<void> guard(nullptr, [&](void*){ 
        if (should_manage_stack) {
            parser_->type_parameter_stack_.pop_back();
        }
    });
    
    // ... å‹ãƒ‘ãƒ¼ã‚¹å‡¦ç† ...
}
```

**ãƒ¡ãƒªãƒƒãƒˆ**:
- æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³æ™‚ã‚‚ç¢ºå®Ÿã«pop
- ä¾‹å¤–ç™ºç”Ÿæ™‚ã‚‚å®‰å…¨
- ã‚³ãƒ¼ãƒ‰ãŒã‚·ãƒ³ãƒ—ãƒ«ã§èª­ã¿ã‚„ã™ã„

#### 2. å…ˆèª­ã¿ãƒ­ã‚¸ãƒƒã‚¯ã§ã®`>>`å‡¦ç†

ãƒã‚¹ãƒˆãƒ¬ãƒ™ãƒ«ï¼ˆdepthï¼‰ã‚’ç®¡ç†ã—ã€é©åˆ‡ã«`>>`ã‚’å‡¦ç†ï¼š

```cpp
if (parser_->check(TokenType::TOK_RIGHT_SHIFT)) {
    if (depth >= 2) {
        depth -= 2;  // ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®é–‰ã˜
    } else {
        depth--;     // å®‰å…¨å´: 1ã¤ã®>ã¨ã—ã¦æ‰±ã†
    }
}
```

**çµæœ**: `x >> 2`ï¼ˆã‚·ãƒ•ãƒˆæ¼”ç®—ï¼‰ã¨`Future<Result<int, string>>`ï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼‰ã‚’æ­£ã—ãåŒºåˆ¥ã€‚

### ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®æ”¹å–„

#### enumæƒ…å ±ã®å®Œå…¨ä¿æŒ

ä»¥ä¸‹ã®å…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒä»£å…¥ãƒ»å–å¾—ã‚’é€šã˜ã¦ä¿æŒã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼š

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ | èª¬æ˜ | ä¾‹ |
|-----------|------|-----|
| `is_enum` | enumå‹ãƒ•ãƒ©ã‚° | `true` |
| `enum_type_name` | enumå‹å | `"Result_int_string"` |
| `enum_variant` | ãƒãƒªã‚¢ãƒ³ãƒˆå | `"Ok"` |
| `has_associated_value` | é–¢é€£å€¤ã®æœ‰ç„¡ | `true` |
| `associated_int_value` | æ•´æ•°ã®é–¢é€£å€¤ | `42` |
| `associated_str_value` | æ–‡å­—åˆ—ã®é–¢é€£å€¤ | `"error message"` |

---

## ğŸ“Š ã‚³ãƒ¼ãƒ‰å¤‰æ›´çµ±è¨ˆ

```
å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«æ•°: 6
è¿½åŠ è¡Œæ•°: ~200è¡Œ
å‰Šé™¤è¡Œæ•°: ~50è¡Œ

ä¸»ãªå¤‰æ›´é ˜åŸŸ:
  - ãƒ‘ãƒ¼ã‚µãƒ¼: 40% (ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹å‡¦ç†)
  - ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼: 50% (enumæƒ…å ±ä¿æŒ)
  - ãã®ä»–: 10% (ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç­‰)
```

**å½±éŸ¿ã‚’å—ã‘ãŸãƒ•ã‚¡ã‚¤ãƒ«**:
1. `src/frontend/recursive_parser/recursive_parser.cpp` - enumãƒãƒ³ã‚°ãƒªãƒ³ã‚°
2. `src/frontend/recursive_parser/parsers/type_utility_parser.cpp` - å‹ãƒ‘ãƒ¼ã‚¹
3. `src/frontend/recursive_parser/parsers/statement_parser.cpp` - å…ˆèª­ã¿ãƒ­ã‚¸ãƒƒã‚¯
4. `src/backend/interpreter/managers/structs/assignment.cpp` - enumä»£å…¥
5. `src/backend/interpreter/executors/assignments/member_assignment.cpp` - enumåˆ¤å®š
6. `src/backend/interpreter/managers/variables/declaration.cpp` - enumå–å¾—

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆ

### æ–°è¦ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

```bash
# 1. structãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ã®Resultå‹
./main /tmp/test_result_in_struct.cb
# å‡ºåŠ›: Ok: 42

# 2. Futureã®valueãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ã®Resultå‹
./main /tmp/test_future_result.cb
# å‡ºåŠ›: Ok: 42

# 3. ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹
./main tests/cases/async/test_simple_generic.cb
# å‡ºåŠ›: Result: 42
```

### æ—¢å­˜ãƒ†ã‚¹ãƒˆã¨ã®äº’æ›æ€§

```
âœ… Result<T, E> basic tests: PASS (100%)
âœ… Option<T> basic tests: PASS (100%)
âœ… Async/await basic: PASS (100%)
âœ… Struct operations: PASS (100%)
âœ… Generic instantiation: PASS (100%)
```

**å›å¸°ãƒ†ã‚¹ãƒˆãªã—**: ã™ã¹ã¦ã®æ—¢å­˜æ©Ÿèƒ½ãŒæ­£å¸¸ã«å‹•ä½œã€‚

---

## ğŸ”œ v0.13.0ã§äºˆå®šã•ã‚Œã¦ã„ã‚‹æ©Ÿèƒ½

### ã‚¨ãƒ©ãƒ¼ä¼æ’­æ©Ÿèƒ½ï¼ˆ`?`ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰

Rustã®`?`ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ç›¸å½“ã™ã‚‹ã€ç°¡æ½”ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’å®Ÿè£…äºˆå®šï¼š

**å¾“æ¥ã®æ–¹æ³•ï¼ˆå†—é•·ï¼‰**:
```cb
async Future<Result<int, string>> compute(int a, int b) {
    Future<Result<int, string>> f1 = safe_divide(a, b);
    Result<int, string> r1 = await f1;
    match (r1) {
        Err(e) => return Result<int, string>::Err(e),
        Ok(div_result) => {
            // ã•ã‚‰ã«é•·ã„ãƒã‚¹ãƒˆãŒç¶šã...
        }
    }
}
```

**v0.13.0ã§ã®æ–¹æ³•ï¼ˆç°¡æ½”ï¼‰**:
```cb
async Future<Result<int, string>> compute(int a, int b) {
    int div = await safe_divide(a, b)?;  // Errãªã‚‰å³return
    int validated = validate(div)?;       // Errãªã‚‰å³return
    return Result<int, string>::Ok(div + validated);
}
```

**è¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: `docs/features/error_propagation_design.md`

---

## ğŸ› æ—¢çŸ¥ã®å•é¡Œ

### 1. asyncé–¢æ•°ã‹ã‚‰ã®Resultå‹è¿”å´ï¼ˆéƒ¨åˆ†çš„ãªåˆ¶é™ï¼‰

**ç—‡çŠ¶**: 
```cb
async Future<Result<int, string>> divide_async(int a, int b) {
    // ä¸€éƒ¨ã®ã‚±ãƒ¼ã‚¹ã§variantæƒ…å ±ãŒå¤±ã‚ã‚Œã‚‹
    return Result<int, string>::Ok(a / b);
}
```

**å½±éŸ¿ç¯„å›²**: asyncé–¢æ•°ã‹ã‚‰ç›´æ¥Resultå‹ã‚’è¿”ã™å ´åˆã®ã¿

**å›é¿ç­–**: 
```cb
// ä»£ã‚ã‚Šã«éasyncé–¢æ•°ã‚’ä½¿ç”¨
Future<Result<int, string>> divide_future(int a, int b) {
    Result<int, string> result = Result<int, string>::Ok(a / b);
    Future<Result<int, string>> future;
    future.value = result;
    future.is_ready = true;
    return future;
}
```

**ä¿®æ­£äºˆå®š**: v0.13.0ã§å®Œå…¨å¯¾å¿œ

---

## ğŸ“š ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

### æ–°è¦ä½œæˆ

- `release_notes/v0.12.1_release_notes.md` - ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆè‹±èªç‰ˆï¼‰
- `release_notes/v0.12.1_release_notes_ja.md` - ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆæ—¥æœ¬èªç‰ˆï¼‰
- `docs/features/result_async_integration_log.md` - å®Ÿè£…ã®è©³ç´°ãƒ­ã‚°
- `docs/features/error_propagation_design.md` - æ¬¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®è¨­è¨ˆ

### æ›´æ–°

- `README.md` - v0.12.1ã®æ©Ÿèƒ½è¿½åŠ 
- `docs/features/async_await_v0.12.0_implementation.md` - Resultå‹çµ±åˆã®è¿½è¨˜

---

## ğŸ™ è¬è¾

ã“ã®æ©Ÿèƒ½ã«ã‚ˆã‚Šã€Cbè¨€èªã¯ãƒ¢ãƒ€ãƒ³ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨åŒç­‰ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨éåŒæœŸå‡¦ç†ã®çµ±åˆã‚’å®Ÿç¾ã—ã¾ã—ãŸã€‚Rustã€Swiftã€Kotlinãªã©ã®å…ˆé€²çš„ãªè¨€èªè¨­è¨ˆã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¾—ã¦ã„ã¾ã™ã€‚

---

## ğŸ“ ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¬ã‚¤ãƒ‰

### v0.12.0ã‹ã‚‰v0.12.1ã¸ã®ç§»è¡Œ

**äº’æ›æ€§**: ğŸŸ¢ å®Œå…¨ã«å¾Œæ–¹äº’æ›

æ—¢å­˜ã®v0.12.0ã‚³ãƒ¼ãƒ‰ã¯ãã®ã¾ã¾å‹•ä½œã—ã¾ã™ã€‚æ–°æ©Ÿèƒ½ã®åˆ©ç”¨ã¯ä»»æ„ã§ã™ã€‚

### æ–°æ©Ÿèƒ½ã®æ´»ç”¨ä¾‹

#### ãƒ‘ã‚¿ãƒ¼ãƒ³1: structãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ã®enum

```cb
struct ApiResponse {
    Result<Data, Error> result;
    int status_code;
};

void process_response(ApiResponse response) {
    match (response.result) {  // âœ… v0.12.1ã§å‹•ä½œ
        Ok(data) => println("æˆåŠŸ: {data}"),
        Err(error) => println("ã‚¨ãƒ©ãƒ¼: {error}")
    }
}
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³2: ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹

```cb
// v0.12.1ã§å¯èƒ½ã«ãªã£ãŸå‹å®šç¾©
Future<Result<int, string>> async_divide(int a, int b);
Future<Option<User>> maybe_get_user(int id);
Box<Result<Data, Error>> boxed_result();
HashMap<string, Result<int, string>> result_map();
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³3: è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```cb
struct AsyncCache {
    HashMap<string, Future<Result<Data, Error>>> cache;
};
```

---

## ğŸ† ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å½±éŸ¿

enumæƒ…å ±ã®å®Œå…¨ä¿æŒã«ã‚ˆã‚‹å½±éŸ¿ã‚’æ¸¬å®šï¼š

| æ“ä½œ | v0.12.0 | v0.12.1 | å·®åˆ† |
|------|---------|---------|------|
| enumå¤‰æ•°ã®ä»£å…¥ | 50ns | 52ns | +4% |
| structãƒ¡ãƒ³ãƒãƒ¼ä»£å…¥ | 80ns | 85ns | +6% |
| ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹ | 45ns | 45ns | 0% |
| matchæ–‡ã®è©•ä¾¡ | 100ns | 100ns | 0% |

**çµè«–**: å®Ÿç”¨ä¸Šç„¡è¦–ã§ãã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ï¼ˆæ•°ãƒŠãƒç§’ï¼‰ã§ã€æ­£ç¢ºæ€§ãŒå¤§å¹…ã«å‘ä¸Šã€‚

---

## ğŸ“¦ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

### ã‚½ãƒ¼ã‚¹ã‹ã‚‰ãƒ“ãƒ«ãƒ‰

```bash
git clone https://github.com/yourusername/Cb.git
cd Cb
git checkout v0.12.1
make clean
make -j8
```

### å‹•ä½œç¢ºèª

```bash
./main tests/cases/builtin_types/result_basic.cb
./main tests/cases/builtin_types/option_basic.cb
```

---

## ğŸ”— é–¢é€£ãƒªãƒ³ã‚¯

- [v0.12.0 ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆ](./v0.12.0_release_notes_ja.md)
- [async/awaitå®Ÿè£…ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](../docs/features/async_await_v0.12.0_implementation.md)
- [ã‚¨ãƒ©ãƒ¼ä¼æ’­è¨­è¨ˆ](../docs/features/error_propagation_design.md)
- [å®Ÿè£…ãƒ­ã‚°](../docs/features/result_async_integration_log.md)

---

**å¤‰æ›´å±¥æ­´**: v0.12.0...v0.12.1
