# Cb言語 v0.9.2 リリースノート（最終版）

## リリース日
2025年10月10日

## 概要
v0.9.2では、**Long型オーバーフロー修正**（重要なバグ修正）、**Const型安全性の部分実装**、**配列の参照渡し**、**ネスト構造体初期化の改善**を実施しました。Fibonacci計算でのLong型の正しい扱いを修正し、const修飾子による型安全性を実装し、構造体の宣言時初期化を大幅に改善しました。

---

## ✨ 新機能と修正

### 1. 🔴 Long型オーバーフロー修正（重要なバグ修正）

**問題**: Fibonacci計算でF(48)以降の値が正しく計算されない

**修正結果**:
```cb
// 修正前
F(48) = 512559680 (誤り)

// 修正後
F(48) = 4807526976 ✅
F(92) = 7540113804746346496 ✅
```

**修正内容**:
1. `TYPE_LONG`配列の読み取り処理を64bit値として正しく扱う
2. 大きな整数リテラル(>INT32_MAX)を自動的に`TYPE_LONG`に分類

---

### 2. 🛡️ Const型安全性の部分実装

**実装内容**:
- `const T*` (pointed-to constness) のチェック
- `T* const` (pointer constness) のチェック
- 関数パラメータでのconst違反検出

```cb
const int* ptr = &x;
*ptr = 100;  // ❌ Error: Cannot modify value through const pointer

int* const ptr2 = &y;
ptr2 = &z;  // ❌ Error: Cannot reassign const pointer
```

**制限事項**:
- 関数戻り値でのconst情報は現在保持されない（v0.10.0で修正予定）

---

### 3. 🔄 配列の参照渡し（関数引数）

関数に配列を渡す際、C/C++と同様に自動的に参照として渡されます。

```cb
void modify(int[3] arr) {
    arr[0] = 100;  // 呼び出し元の配列が変更される
}

void main() {
    int[3] nums = [1, 2, 3];
    modify(nums);
    println(nums[0]);  // 100
}
```

---

### 4. 🏗️ ネスト構造体の宣言時初期化改善

**新機能**: 宣言時のメンバーアクセス初期化に対応

```cb
struct Outer { struct Middle { struct Inner { int x; } val; } val; };

Outer o1 = {val: {val: {x: 99}}};
Middle mid = o1.val;  // struct_membersが正しくコピーされる
println(mid.val.x);   // 99 ✅
```

**実装内容**:
- `src/backend/interpreter/managers/variables/declaration.cpp` (lines 490+)
- `AST_MEMBER_ACCESS`初期化処理の追加
- メンバーパスの構築とstruct_membersの深いコピー
- 再帰的なネストメンバー変数の作成

**テスト**: 14個の新規テストケースを追加

---

## 📊 テスト結果

### 統計
- **統合テスト**: 2,379個（100%成功）🎉
- **ユニットテスト**: 30個（100%成功）🎉
- **総テスト数**: 2,409個（100%成功）🎉

### 新規追加テスト
1. **ネスト構造体初期化テスト**: 14個
   - `tests/cases/nested_struct_init/declaration_member_access.cb` (4テスト)
   - `tests/cases/nested_struct_init/comprehensive.cb` (5テスト)
   - `tests/cases/nested_struct_init/edge_cases.cb` (5テスト)
   
2. **C互換性テスト**: 1個
   - `tests/cases/c_compatibility/triple_arrow.cb`

---

## 🔧 実装詳細

### 主要な変更ファイル

1. **Long型修正**:
   - `src/backend/interpreter/evaluator/core/evaluator.cpp`
   - `src/backend/interpreter/evaluator/literals/eval.cpp`

2. **Const型安全性**:
   - `src/backend/interpreter/managers/variables/declaration.cpp`

3. **ネスト構造体初期化**:
   - `src/backend/interpreter/managers/variables/declaration.cpp` (490-560行)
   - `src/backend/interpreter/managers/structs/assignment.cpp`

4. **テストフレームワーク**:
   - `tests/integration/nested_struct_init/test_nested_struct_init.hpp`

---

## 🐛 既知の問題

### 制限事項
1. **関数戻り値でのconst情報損失**
   ```cb
   const int* const get_ptr() { return &global_x; }
   int* ptr = get_ptr();  // ⚠️ エラーにならない（v0.10.0で修正予定）
   ```

2. **配列参照型（明示的型宣言）未実装**
   ```cb
   void modify(int[3]& arr) { }  // ❌ 構文エラー
   // 現在は自動的に参照として渡されるが、明示的型宣言は未サポート
   ```

---

## 📈 パフォーマンス

- **統合テスト実行時間**: 約830ms（前バージョン比 +0.8%）
- **メモリ使用量**: 変化なし
- **コンパイル時間**: 変化なし

---

## 🔜 v0.10.0計画

### 最優先課題
1. **Const型安全性の完全実装**（2週間）
   - 関数パラメータでのconst型チェック
   - 関数戻り値でのconst型チェック
   - Rust `Pin<&T>`相当の完全な不変性保証

2. **配列参照型の明示的宣言**（1週間）
   - `int[N]&` 形式の型宣言サポート
   - パーサー拡張と型システム統合

3. **スタックトレース機能**（1週間）
   - エラー発生時の関数呼び出し履歴表示
   - デバッグの効率化

---

## 🙏 謝辞

このリリースに貢献してくださったすべての方々に感謝します。

---

## 📝 変更履歴

### コミット統計
- **変更ファイル数**: 8個
- **追加行数**: +600行
- **削除行数**: -120行
- **純増**: +480行

### 主要なコミット
- `fix: Long型配列読み取りを64bit値として扱う`
- `fix: 大きな整数リテラルをTYPE_LONGに分類`
- `feat: 宣言時のメンバーアクセス初期化に対応`
- `test: ネスト構造体初期化テスト14個追加`
- `docs: ネスト構造体初期化のREADME作成`

---

**リリース承認**: shadowlink0122  
**レビュー**: AI Assistant  
**日付**: 2025年10月10日
