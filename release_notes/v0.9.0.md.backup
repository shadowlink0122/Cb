# Cb言語 v0.9.0 リリースノート


**リリース日**: 2025年10月5日  ## 🩹 バグ修正

**バージョン**: v0.9.0 - ポインタシステム完全実装版

**リリース日**: 2025年10月2日  

---**バージョン**: v0.9.0  

**テスト成功率**: 100%

## 🎯 概要

---

v0.9.0では、ポインタシステムの2つの主要な制限事項を解消し、127個の包括的なテストを追加しました。これにより、Cbのポインタ機能が実用レベルに到達しました。

### 構造体メンバーの Union 値が 0 に戻ってしまう問題

---

#### 🎯 期待値

## ✨ 新機能構造体に含まれる Union 型メンバーへ数値を代入・複合代入した際、代入後の値が保持され、`println` などで正しい値が表示される。



### 1. ポインタ宣言時初期化#### 🐛 不具合

`tests/cases/union/struct_union_compound_assignment.cb` などで、構造体を関数に渡して戻した後、Union メンバーを出力すると `10` ではなく `0` が表示され、複合代入結果が失われていた。

これまで制限事項だったポインタの宣言時初期化が可能になりました。

#### ✅ 修正ポイント

#### 以前（v0.8.x）- 構造体と直アクセス変数間の同期処理で、Union メンバーの `type_name` と `current_type`、数値／文字列などの値を完全にコピーするよう `sync_struct_members_from_direct_access` を改修

```
- メンバー定義のメタ情報（ポインタ深度・参照・unsigned 指定など）を再適用し、戻り構造体をそのまま代入しても情報が欠落しないように調整

int[5] arr = [10, 20, 30, 40, 50];

int* ptr;---

ptr = &arr[0];  // 別行で代入が必要
```
### 構造体メンバーの文字列配列が `0` で表示される問題



#### 現在（v0.9.0）✅#### � 期待値

```
構造体メンバーとして保持している `string` 型の配列を `println`/`printf` すると、代入した文字列がそのまま出力される。

int[5] arr = [10, 20, 30, 40, 50];

int* ptr = &arr[0];  // 宣言と同時に初期化可能！#### 🐛 不具合

```
tests/cases/struct/struct_function_array_members.cb` など、構造体から返された `string[]` メンバーを出力すると `[honor, active]` のような期待値ではなく `[0, 0]` の初期値が表示されていた。



**利点**:#### ✅ 修正ポイント

- コードが簡潔になる- `output_manager` が構造体メンバー配列を文字列として展開する際に、型の基底情報を正しく参照するように調整

- 未初期化ポインタのリスク軽減- 直接アクセス中の変数と構造体メンバーとの同期処理で、`TYPE_ARRAY_BASE` を含む型情報を分解し、実際の要素型を用いてコピーを行うように修正

- C/C++との互換性向上- デバッグ目的で追加されていた `std::cerr` 出力をすべて削除し、テスト実行時に余計なログが混ざらないように整理



**実装箇所**:---

- `src/backend/interpreter/managers/variable_manager.cpp` (lines 2881-2901)

## �🌟 新機能: unsigned プリミティブの正式サポート

---

- `tiny`/`short`/`int`/`long`/`char` に unsigned 指定を追加し、0 からそれぞれ 255・65535・4294967295・18446744073709551615・255 までの範囲をサポート

### 2. 16進数アドレス表示- `TypeManager::check_type_range` が unsigned フラグに基づいて最大値を切り替え、`VariableManager::assign_variable` など変数管理経路で自動的に適用

- 透過的なメンバーアクセスや配列・構造体同期を含むすべての代入パスで unsigned の範囲チェックと 0 への丸め処理を保証

ポインタ値が16進数形式で表示されるようになりました。- `tests/cases/unsigned/` 以下に境界値の成功／失敗ケースを追加し、`tests/integration/unsigned/test_unsigned.hpp` で一括検証



#### 以前（v0.8.x）## 🔧 変更ファイル

```- バグ修正

ptr = -9223372036854775808  // 負の大きな数値（読みにくい）	- 構造体メンバーの Union 値

```		- `src/backend/interpreter/core/interpreter.cpp`

		- `src/backend/interpreter/managers/variable_manager.cpp`

#### 現在（v0.9.0）✅	- 構造体メンバーの文字列配列

```		- `src/backend/interpreter/core/interpreter.cpp`

ptr = 0x7fff5fbff8ac  // 16進数アドレス（直感的）		- `src/backend/interpreter/managers/variable_manager.cpp`

```		- `src/backend/interpreter/output/output_manager.cpp`

- 新機能

**利点**:	- `src/backend/interpreter/managers/type_manager.cpp`

- アドレス値が直感的に理解できる	- `src/backend/interpreter/managers/type_manager.h`

- デバッグが容易になる	- `src/backend/interpreter/managers/variable_manager.cpp`

- C/C++との互換性向上	- `src/backend/interpreter/core/interpreter.h`

	- `src/backend/interpreter/common/common_operations.cpp`

**実装箇所**:	- `tests/cases/unsigned/*`

- `src/backend/interpreter/output/output_manager.cpp` (lines 109-130, 137-148, 387-401)	- `tests/integration/unsigned/test_unsigned.hpp`



**技術詳細**:---

- タグビット（MSB）を自動的に除去: `value & ~(1ULL << 63)`

- `std::hex` を使用して16進数フォーマット## 🧪 テスト

- すべての出力箇所で一貫した表示- `make`

- `./main tests/cases/struct/struct_function_array_members.cb`

---- `./main tests/cases/union/struct_union_compound_assignment.cb`

- `make test`

## 🧪 テストの追加

すべてのテストが成功し、Union メンバーが複合代入後も正しい値を保持することを確認しました。

### 新規テストケース（127個）

---

5つの包括的なテストファイルを追加:

## 📌 影響範囲

#### 1. `test_declaration_init_comprehensive.cb` (10テスト)- 構造体に Union 型メンバーを含み、値を複合代入で更新するすべてのプログラム

- 宣言時初期化の動作確認- 構造体を関数境界を越えて受け渡し、戻り値を再代入するシナリオ

- ポインタ演算との組み合わせ

- 複数ポインタの同時管理他の型（配列、多次元配列、interface など）への影響は確認されていません。

- 値の変更とアドレス表示

---

```

// 例: 宣言時初期化**Cb言語開発チーム**  

int[5] arr = [10, 20, 30, 40, 50];2025年10月2日

int* ptr = &arr[0];
println("*ptr =", *ptr);  // 10
```

#### 2. `test_address_display_comprehensive.cb` (6テスト)
- 16進数形式の確認
- アドレス遷移の追跡
- 複数ポインタのアドレス比較
- ポインタ自身のアドレス取得

```
// 例: アドレス表示
int value = 42;
int* ptr = &value;
println("ptr =", ptr);      // 0x7fff5fbff8ac (例)
println("&ptr =", &ptr);    // 0x7fff5fbff8b0 (例)
```

#### 3. `test_struct_pointer_operations.cb` (6テスト)
- 構造体ポインタの基本操作
- デリファレンス構文 `(*ptr).member`
- ポインタ経由での値変更
- 複数構造体ポインタの管理

```
// 例: 構造体ポインタ
struct Point { int x; int y; };
Point p = {x: 10, y: 20};
Point* ptr = &p;
(*ptr).x = 30;
```

#### 4. `test_interface_impl_pointer_comprehensive.cb` (5テスト)
- Interfaceポインタの基本操作
- ポリモーフィックメソッド呼び出し
- implブロック内でのポインタ操作
- 複数implメソッドの連続呼び出し

```
// 例: Interfaceポインタ
interface Shape { int area(); };
struct Rectangle { int width; int height; };

impl Shape for Rectangle {
    int area() { return self.width * self.height; }
};

Rectangle rect = {width: 10, height: 5};
Shape* shape_ptr = &rect;
int a = (*shape_ptr).area();  // 50
```

#### 5. `test_pointer_boundary_comprehensive.cb` (7テスト)
- 境界ケースの検証
- 複数の宣言時初期化
- チェーン代入
- 前方・後方移動
- 回文チェックアルゴリズム
- 16進数表示の一貫性

```
// 例: 回文チェック
int[5] palindrome = [1, 2, 3, 2, 1];
int* left = &palindrome[0];
int* right = &palindrome[4];
// 両端から中央に向かって比較...
```

### テスト統計

| 項目 | v0.8.1 | v0.9.0 | 増加 |
|------|--------|--------|------|
| 統合テスト | 2222個 | **2349個** | +127個 |
| 単体テスト | 30個 | 30個 | - |
| **合計** | **2252個** | **2379個** | **+127個** |
| **成功率** | 100% | **100%** | - |

---

## 🐛 修正されたバグ

### 1. 構文エラーの修正

**問題**: テストコードで `or` 演算子と末尾セミコロン不足

**修正内容**:
- `or` → `||` に置換（3ファイル）
- struct/interface/impl定義の末尾に `;` を追加

**影響を受けたファイル**:
- `test_declaration_init_comprehensive.cb`
- `test_address_display_comprehensive.cb`
- `test_interface_impl_pointer_comprehensive.cb`

### 2. 配列境界エラーの修正

**問題**: 10要素配列に対して10回インクリメントして境界外アクセス

**修正内容**:
- ループを9回に変更
- 10番目の要素は個別にアクセス

```
// 修正前
for (int i = 0; i < 10; i++) {
    ptr++;  // 10回目で境界外
}

// 修正後
for (int i = 0; i < 9; i++) {
    ptr++;  // 9回まで
}
int last = *ptr;  // 10番目は個別アクセス
```

### 3. 出力フォーマット不整合の修正

**問題**: テスト出力に先頭スペースがあるが、アサーション文字列にはない

**修正内容**:
- すべてのアサーション文字列に適切な先頭スペースを追加

```cpp
// 修正前
INTEGRATION_ASSERT(output, "(*ptr).x = 30");

// 修正後
INTEGRATION_ASSERT(output, "  (*ptr).x = 30");
```

---

## 🔧 実装の詳細

### 1. 宣言時初期化の実装

**ファイル**: `src/backend/interpreter/managers/variable_manager.cpp`

**実装箇所** (lines 2881-2901):
```cpp
// ポインタ型の場合、型情報を確実に設定
if (node->type_info == TYPE_POINTER) {
    var.type = TYPE_POINTER;
    
    // ポインタ型の初期化式がある場合は評価して代入
    if (node->init_expr || node->right) {
        ASTNode* init_node = node->init_expr ? node->init_expr.get() : node->right.get();
        TypedValue typed_value = interpreter_->expression_evaluator_->evaluate_typed_expression(init_node);
        var.value = typed_value.value;
        var.is_assigned = true;
    }
}
```

**ポイント**:
- `TYPE_POINTER` の場合に特別処理
- `init_expr` または `right` ノードを評価
- `evaluate_typed_expression` で式を評価して値を取得
- `var.is_assigned = true` で初期化済みフラグを設定

### 2. 16進数アドレス表示の実装

**ファイル**: `src/backend/interpreter/output/output_manager.cpp`

**実装箇所** (3箇所):

#### (1) `write_typed_value` ラムダ (lines 109-130)
```cpp
auto write_typed_value = [&](const TypedValue &typed) {
    if (typed.is_numeric()) {
        int64_t numeric_val = typed.as_numeric();
        if (value_type == TYPE_POINTER && (numeric_val & (1LL << 63))) {
            uint64_t clean_value = static_cast<uint64_t>(numeric_val) & ~(1ULL << 63);
            std::ostringstream oss;
            oss << "0x" << std::hex << clean_value;
            io_interface_->write_string(oss.str().c_str());
            return;
        }
        // ... 通常の数値処理
    }
};
```

#### (2) `evaluate_numeric_and_write` ラムダ (lines 137-148)
```cpp
auto evaluate_numeric_and_write = [&](ASTNode *expr_node) {
    TypedValue typed = interpreter_->expression_evaluator_->evaluate_typed_expression(expr_node);
    if (value_type == TYPE_POINTER && typed.is_numeric()) {
        int64_t numeric_val = typed.as_numeric();
        if (numeric_val & (1LL << 63)) {
            uint64_t clean_value = static_cast<uint64_t>(numeric_val) & ~(1ULL << 63);
            std::ostringstream oss;
            oss << "0x" << std::hex << clean_value;
            io_interface_->write_string(oss.str().c_str());
            return;
        }
    }
    // ... 通常の処理
};
```

#### (3) AST_VARIABLE ハンドラ (lines 387-401)
```cpp
case AST_VARIABLE: {
    auto &var = interpreter_->variable_manager_->get_variable(arg->value);
    if (var.type == TYPE_POINTER) {
        int64_t ptr_val = std::get<int64_t>(var.value);
        if (ptr_val & (1LL << 63)) {
            uint64_t clean_value = static_cast<uint64_t>(ptr_val) & ~(1ULL << 63);
            std::ostringstream oss;
            oss << "0x" << std::hex << clean_value;
            io_interface_->write_string(oss.str().c_str());
        } else {
            io_interface_->write_long(ptr_val);
        }
    } else {
        // ... 通常の変数出力
    }
    break;
}
```

**共通のロジック**:
1. ポインタ型かチェック (`value_type == TYPE_POINTER` または `var.type == TYPE_POINTER`)
2. タグビット（MSB）の有無を確認 (`numeric_val & (1LL << 63)`)
3. タグビットを除去 (`& ~(1ULL << 63)`)
4. 16進数フォーマットで出力 (`std::hex`)

---

## 📊 パフォーマンス

### テスト実行時間

- **全テスト実行**: 約2秒（2379個）
- **ポインタテストのみ**: 約0.3秒（127個）

### メモリ使用量

- ポインタ変数のオーバーヘッド: なし（既存のint64_tを使用）
- タグビットによる型識別（メモリ効率的）

---

## 📝 ドキュメント更新

### 更新されたドキュメント

1. **完全仕様書** (`docs/spec.md`)
   - 全機能を包括的にドキュメント化（新規作成）
   - ポインタシステムの詳細セクション追加
   - すべての型、演算子、制御構造を網羅

2. **README.md**
   - v0.9.0の新機能を反映
   - テスト数を2349個に更新
   - ポインタのサンプルコード追加

3. **アーカイブ化** (`docs/archive/`)
   - 24個の古い実装ドキュメントを移動
   - 現在有効なドキュメントのみを残す

---

## 🔄 移行ガイド

### v0.8.x から v0.9.0 への移行

#### 互換性

✅ **完全な後方互換性**: v0.8.xのすべてのコードがv0.9.0でも動作します。

#### 推奨される変更

##### 1. ポインタ初期化の簡略化

```
// 旧スタイル（v0.8.x）
int[5] arr = [1, 2, 3, 4, 5];
int* ptr;
ptr = &arr[0];

// 新スタイル（v0.9.0推奨）✅
int[5] arr = [1, 2, 3, 4, 5];
int* ptr = &arr[0];
```

##### 2. デバッグ出力の読みやすさ向上

v0.9.0では、ポインタ値が自動的に16進数で表示されるため、デバッグが容易になります。

```
int* ptr = &value;
println("ptr =", ptr);  // v0.8.x: -922... / v0.9.0: 0x7fff...
```

---

## ✅ 既に実装済みの機能（v0.9.0時点）

v0.9.0リリース時点で、以下の機能はすでに完全実装されています：

### 浮動小数点数型 ✅
- **float型**: 単精度浮動小数点数（32bit）
- **double型**: 倍精度浮動小数点数（64bit）
- **演算**: 四則演算、比較演算、複合代入
- **配列**: float配列、double配列、多次元配列
- **構造体メンバー**: 構造体内でfloat/doubleメンバー使用可能
- **テスト**: `tests/cases/float_double_unsigned/` で包括的にテスト済み

```
float f = 3.14f;
double d = 2.71828;
float[5] farr = [1.1, 2.2, 3.3, 4.4, 5.5];
```

### ネストした構造体 ✅
- **ネスト定義**: 構造体メンバーに別の構造体を含む
- **多階層ネスト**: 3階層以上のネスト構造
- **初期化**: ネストした構造体リテラルでの初期化
- **メンバーアクセス**: `outer.inner.value` 形式のチェーンアクセス
- **ポインタ経由**: `(*ptr).nested.member` でのアクセス
- **テスト**: `tests/cases/struct/test_nested_*.cb` で包括的にテスト済み

```
struct Point { int x; int y; };
struct Circle {
    Point center;
    int radius;
};

Circle c = {center: {x: 10, y: 20}, radius: 5};
int cx = c.center.x;  // ネストしたメンバーへのアクセス
```

### enum型 ✅
- **enum定義**: 列挙型の定義と値の自動割り当て
- **明示的な値**: `RED = 0` 形式での値指定
- **スコープアクセス**: `Color::RED` 形式でのアクセス
- **typedef enum**: `typedef enum Color { ... } Color;` 形式
- **テスト**: `tests/cases/enum/` で包括的にテスト済み

```
enum Color {
    RED = 0,
    GREEN = 1,
    BLUE = 2
};

Color c = Color::RED;
```

### アロー演算子 ✅
- **構文**: `ptr->member` でポインタメンバーアクセス
- **ネストアクセス**: `ptr->nested->value` 形式の連鎖
- **代入**: `ptr->member = value` での値変更
- **Interfaceポインタ**: `shape_ptr->area()` でのメソッド呼び出し
- **テスト**: `tests/cases/pointer/test_arrow_*.cb` で包括的にテスト済み

```
Point* ptr = &p;
ptr->x = 30;  // (*ptr).x = 30 と同等
int y = ptr->y;
```

---

## 🚀 今後の予定

### v0.10.0（予定）

- **動的配列**: 可変長配列のサポート
- **スマートポインタ**: `unique_ptr`, `shared_ptr` の実装
- **参照型の強化**: `int&` による参照渡しの完全サポート

### v1.0.0に向けて

- **ジェネリクス**: テンプレート・ジェネリクス機能
- **非同期処理**: goroutine風の並行処理
- **標準ライブラリ**: コレクション、I/O、ネットワーク
- **エラー処理**: try-catch風のエラーハンドリング

---

## 📞 フィードバック

バグ報告や機能リクエストは、GitHubのIssueでお願いします。

---

## 🙏 謝辞

v0.9.0のリリースにあたり、ポインタシステムの包括的なテストケース作成とデバッグに多大な時間を費やしました。

すべてのテストが100%成功することを確認し、Cb言語の品質を維持できたことを嬉しく思います。

---

**Cb言語 v0.9.0 - ポインタシステム完全実装版**  
リリース日: 2025年10月5日

🎉 **2349個の統合テスト + 30個の単体テスト = 100%成功** 🎉
