# Cbè¨€èªãƒ‘ãƒ¼ã‚µãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆv0.12.1ï¼‰

## ğŸ“ å…¨ä½“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        RecursiveParser                          â”‚
â”‚                     (ãƒ¡ã‚¤ãƒ³ãƒ‘ãƒ¼ã‚µãƒ¼ã‚¯ãƒ©ã‚¹)                        â”‚
â”‚                                                                 â”‚
â”‚  å½¹å‰²: ãƒ‘ãƒ¼ã‚µãƒ¼å…¨ä½“ã®èª¿æ•´ã€ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã€çŠ¶æ…‹ç®¡ç†                  â”‚
â”‚  v0.11.0ã®æ”¹å–„: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã€æ–‡å­—åˆ—è£œé–“ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¯¾å¿œ         â”‚
â”‚                                                                 â”‚
â”‚  ä¸»è¦ãƒ¡ãƒ³ãƒãƒ¼:                                                   â”‚
â”‚  - RecursiveLexer lexer_;          // å­—å¥è§£æï¼ˆæ–‡å­—åˆ—è£œé–“å¯¾å¿œï¼‰ â”‚
â”‚  - Token current_token_;            // ç¾åœ¨ã®ãƒˆãƒ¼ã‚¯ãƒ³             â”‚
â”‚  - typedef_map_;                    // typedefç®¡ç†              â”‚
â”‚  - struct_definitions_;             // æ§‹é€ ä½“å®šç¾©ï¼ˆGenericå¯¾å¿œï¼‰  â”‚
â”‚  - enum_definitions_;               // enumå®šç¾©ï¼ˆGenericå¯¾å¿œï¼‰   â”‚
â”‚  - interface_definitions_;          // interfaceå®šç¾©            â”‚
â”‚  - generic_struct_instances_;       // Genericæ§‹é€ ä½“ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹  â”‚
â”‚  - generic_function_instances_;     // Genericé–¢æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹    â”‚
â”‚  - unique_ptr<T> parsers_[5];       // åˆ†é›¢ãƒ‘ãƒ¼ã‚µãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹    â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         friend å®£è¨€ã«ã‚ˆã‚Šå†…éƒ¨çŠ¶æ…‹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚ å§”è­²
                              â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                                          â”‚
        â–¼                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ExpressionParserâ”‚                       â”‚ StatementParser â”‚
â”‚  (å¼è§£æ)       â”‚                       â”‚  (æ–‡è§£æ)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 19ãƒ¡ã‚½ãƒƒãƒ‰      â”‚                       â”‚ 11ãƒ¡ã‚½ãƒƒãƒ‰       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ parseExpression       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â€¢ parseAssignment       â”‚   DeclarationParser       â”‚    â”‚
â”‚ â€¢ parseTernary          â”‚    (å®£è¨€è§£æ)              â”‚    â”‚
â”‚ â€¢ parseLogicalOr        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚ â€¢ parseLogicalAnd       â”‚ 6ãƒ¡ã‚½ãƒƒãƒ‰                  â”‚    â”‚
â”‚ â€¢ parseBitwiseOr        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚ â€¢ parseBitwiseXor       â”‚ â€¢ parseVariableDecl       â”‚    â”‚
â”‚ â€¢ parseBitwiseAnd       â”‚ â€¢ parseTypedefVariableDeclâ”‚    â”‚
â”‚ â€¢ parseComparison       â”‚ â€¢ parseFunctionDecl       â”‚    â”‚
â”‚ â€¢ parseShift            â”‚ â€¢ parseFuncDeclAfterName  â”‚    â”‚
â”‚ â€¢ parseAdditive         â”‚ â€¢ parseTypedefDecl        â”‚    â”‚
â”‚ â€¢ parseMultiplicative   â”‚ â€¢ parseFuncPointerTypedef â”‚    â”‚
â”‚ â€¢ parseUnary            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚ â€¢ parsePostfix                    â”‚                      â”‚
â”‚ â€¢ parsePrimary                    â”‚                      â”‚
â”‚ â€¢ parseMemberAccess               â–¼                      â”‚
â”‚ â€¢ parseArrowAccess      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â€¢ parseStructLiteral    â”‚     TypeParser            â”‚    â”‚
â”‚ â€¢ parseArrayLiteral     â”‚      (å‹è§£æ)              â”‚    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
                          â”‚ 7ãƒ¡ã‚½ãƒƒãƒ‰                  â”‚    â”‚
                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
                          â”‚ â€¢ parseType               â”‚    â”‚
                          â”‚ â€¢ resolveParsedTypeInfo   â”‚    â”‚
                          â”‚ â€¢ resolveArrayType        â”‚    â”‚
                          â”‚ â€¢ getPointerLevel         â”‚    â”‚
                          â”‚ â€¢ isValidType             â”‚    â”‚
                          â”‚ â€¢ isStructType            â”‚    â”‚
                          â”‚ â€¢ isEnumType              â”‚    â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                                      â”‚                    â”‚
                                      â–¼                    â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
                          â”‚     StructParser          â”‚    â”‚
                          â”‚    (æ§‹é€ ä½“è§£æ)            â”‚    â”‚
                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
                          â”‚ 10ãƒ¡ã‚½ãƒƒãƒ‰                 â”‚    â”‚
                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚ â€¢ parseStatement        â”‚ â€¢ parseStructDecl         â”‚    â”‚
â”‚ â€¢ parseCompoundStatementâ”‚ â€¢ parseStructTypedefDecl  â”‚    â”‚
â”‚ â€¢ parseIfStatement      â”‚ â€¢ parseForwardDecl        â”‚    â”‚
â”‚ â€¢ parseForStatement     â”‚ â€¢ parseUnionDecl          â”‚    â”‚
â”‚ â€¢ parseWhileStatement   â”‚ â€¢ parseUnionTypedefDecl   â”‚    â”‚
â”‚ â€¢ parseReturn           â”‚ â€¢ parseEnumDecl           â”‚    â”‚
â”‚ â€¢ parseBreak            â”‚ â€¢ parseEnumTypedefDecl    â”‚    â”‚
â”‚ â€¢ parseContinue         â”‚ â€¢ parseStructMembers      â”‚    â”‚
â”‚ â€¢ parseAssert           â”‚ â€¢ parseUnionMembers       â”‚    â”‚
â”‚ â€¢ parsePrintln          â”‚ â€¢ detectCircularRef       â”‚    â”‚
â”‚ â€¢ parsePrint            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
                                                           â”‚
                                                           â”‚
                                                           â–¼
```

## ğŸ”„ Phaseåˆ¥ã®é€²åŒ–

### Phase 0: Baseline (v0.9.0)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      RecursiveParser           â”‚
â”‚         5589è¡Œ                  â”‚
â”‚                                â”‚
â”‚  å…¨ã¦ã®ãƒ‘ãƒ¼ã‚µãƒ¼æ©Ÿèƒ½ãŒ           â”‚
â”‚  å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã«å®Ÿè£…             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase 1: ãƒ‘ãƒ¼ã‚µãƒ¼åˆ†é›¢ã®åŸºç›¤æ§‹ç¯‰ âœ…
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      RecursiveParser           â”‚
â”‚         5589è¡Œ                  â”‚
â”‚                                â”‚
â”‚  + unique_ptr<T> parsers_[5]   â”‚
â”‚  + friend å®£è¨€                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â†’ ExpressionParser (ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿)
         â”œâ”€â†’ StatementParser (ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿)
         â”œâ”€â†’ DeclarationParser (ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿)
         â”œâ”€â†’ TypeParser (ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿)
         â””â”€â†’ StructParser (ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿)
```

### Phase 2: å§”è­²ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£… âœ…
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      RecursiveParser           â”‚
â”‚         5606è¡Œ                  â”‚
â”‚                                â”‚
â”‚  å®Ÿè£…ã¯å…¨ã¦ã“ã“ã«æ®‹ã‚‹            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–² å§”è­²å‘¼ã³å‡ºã—
         â”‚
         â”œâ”€â†’ ExpressionParser (å§”è­²ã®ã¿)
         â”œâ”€â†’ StatementParser (å§”è­²ã®ã¿)
         â”œâ”€â†’ DeclarationParser (å§”è­²ã®ã¿)
         â”œâ”€â†’ TypeParser (å§”è­²ã®ã¿)
         â””â”€â†’ StructParser (å§”è­²ã®ã¿)
```

### Phase 3: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ âœ…
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      RecursiveParser           â”‚
â”‚         5606è¡Œ                  â”‚
â”‚                                â”‚
â”‚  å®Ÿè£…ã¯å…¨ã¦ã“ã“ã«æ®‹ã‚‹            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–² å§”è­²å‘¼ã³å‡ºã—
         â”‚
         â”œâ”€â†’ ExpressionParser (å§”è­² + 300è¡Œã‚³ãƒ¡ãƒ³ãƒˆ)
         â”œâ”€â†’ StatementParser (å§”è­² + 150è¡Œã‚³ãƒ¡ãƒ³ãƒˆ)
         â”œâ”€â†’ DeclarationParser (å§”è­² + 120è¡Œã‚³ãƒ¡ãƒ³ãƒˆ)
         â”œâ”€â†’ TypeParser (å§”è­² + 200è¡Œã‚³ãƒ¡ãƒ³ãƒˆ)
         â””â”€â†’ StructParser (å§”è­² + 180è¡Œã‚³ãƒ¡ãƒ³ãƒˆ)

ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€‘: 804msï¼ˆBaselineã‚ˆã‚Š3.1%é«˜é€ŸåŒ–ï¼‰
```

### Phase 5: ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…ã®ç§»è¡Œï¼ˆäºˆå®šï¼‰
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      RecursiveParser           â”‚
â”‚         ~3000è¡Œ                 â”‚
â”‚                                â”‚
â”‚  ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã€çŠ¶æ…‹ç®¡ç†ã®ã¿      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–² å†…éƒ¨çŠ¶æ…‹ã‚¢ã‚¯ã‚»ã‚¹
         â”‚
         â”œâ”€â†’ ExpressionParser (~1000è¡Œå®Ÿè£…)
         â”œâ”€â†’ StatementParser (~700è¡Œå®Ÿè£…)
         â”œâ”€â†’ DeclarationParser (~800è¡Œå®Ÿè£…)
         â”œâ”€â†’ TypeParser (~400è¡Œå®Ÿè£…)
         â””â”€â†’ StructParser (~600è¡Œå®Ÿè£…)

ã€åˆè¨ˆã€‘: ~6500è¡Œï¼ˆ-80è¡Œã€æ§‹é€ åŒ–ã«ã‚ˆã‚Šé‡è¤‡å‰Šæ¸›ï¼‰
```

## ğŸ“Š ãƒ¡ã‚½ãƒƒãƒ‰åˆ†å¸ƒï¼ˆPhase 3å®Œäº†æ™‚ç‚¹ï¼‰

### ExpressionParserï¼ˆ19ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- **å½¹å‰²**: å¼ã®è§£æã€æ¼”ç®—å­ã®å„ªå…ˆé †ä½å‡¦ç†
- **æ¼”ç®—å­å„ªå…ˆé †ä½**: 14ãƒ¬ãƒ™ãƒ«
  1. ä»£å…¥æ¼”ç®—å­ï¼ˆLevel 1ï¼‰
  2. ä¸‰é …æ¼”ç®—å­ï¼ˆLevel 2ï¼‰
  3. è«–ç†ORï¼ˆLevel 3ï¼‰
  4. è«–ç†ANDï¼ˆLevel 4ï¼‰
  5. ãƒ“ãƒƒãƒˆORï¼ˆLevel 5ï¼‰
  6. ãƒ“ãƒƒãƒˆXORï¼ˆLevel 6ï¼‰
  7. ãƒ“ãƒƒãƒˆANDï¼ˆLevel 7ï¼‰
  8. æ¯”è¼ƒæ¼”ç®—å­ï¼ˆLevel 8ï¼‰
  9. ã‚·ãƒ•ãƒˆæ¼”ç®—å­ï¼ˆLevel 9ï¼‰
  10. åŠ æ¸›ç®—ï¼ˆLevel 10ï¼‰
  11. ä¹—é™¤ç®—ï¼ˆLevel 11ï¼‰
  12. å˜é …æ¼”ç®—å­ï¼ˆLevel 12ï¼‰
  13. å¾Œç½®æ¼”ç®—å­ï¼ˆLevel 13ï¼‰
  14. ãƒ—ãƒ©ã‚¤ãƒãƒªå¼ï¼ˆLevel 14ï¼‰

### StatementParserï¼ˆ11ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- **å½¹å‰²**: æ–‡ã®è§£æã€åˆ¶å¾¡æ§‹é€ 
- **ã‚«ãƒ†ã‚´ãƒª**:
  - åˆ¶å¾¡æ§‹æ–‡: if, for, whileï¼ˆ3ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - ã‚¸ãƒ£ãƒ³ãƒ—æ–‡: return, break, continueï¼ˆ3ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - å‡ºåŠ›: println, printï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - ãã®ä»–: statement, compoundStatement, assertï¼ˆ3ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰

### DeclarationParserï¼ˆ6ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- **å½¹å‰²**: å®£è¨€ã®è§£æ
- **ã‚«ãƒ†ã‚´ãƒª**:
  - å¤‰æ•°å®£è¨€: variable, typedefVariableï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - é–¢æ•°å®£è¨€: function, functionAfterNameï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - Typedef: typedef, functionPointerTypedefï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰

### TypeParserï¼ˆ7ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- **å½¹å‰²**: å‹ã®è§£æã¨æ¤œè¨¼
- **ã‚«ãƒ†ã‚´ãƒª**:
  - è§£æ: parseTypeï¼ˆ1ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - è§£æ±º: resolveParsedTypeInfo, resolveArrayTypeï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - æ¤œè¨¼: getPointerLevel, isValidType, isStructType, isEnumTypeï¼ˆ4ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰

### StructParserï¼ˆ10ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- **å½¹å‰²**: æ§‹é€ ä½“ã¨enumã€unionã®è§£æ
- **ã‚«ãƒ†ã‚´ãƒª**:
  - æ§‹é€ ä½“: structDecl, structTypedefDecl, forwardDeclï¼ˆ3ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - Union: unionDecl, unionTypedefDeclï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - Enum: enumDecl, enumTypedefDeclï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - ãƒ¡ãƒ³ãƒãƒ¼: structMembers, unionMembersï¼ˆ2ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  - æ¤œè¨¼: detectCircularReferenceï¼ˆ1ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰

## ğŸ”§ æŠ€è¡“çš„ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

### 1. friendå®£è¨€ã«ã‚ˆã‚‹å†…éƒ¨çŠ¶æ…‹ã‚¢ã‚¯ã‚»ã‚¹
```cpp
class RecursiveParser {
    friend class ExpressionParser;
    friend class StatementParser;
    friend class DeclarationParser;
    friend class TypeParser;
    friend class StructParser;
    
private:
    Token current_token_;         // åˆ†é›¢ãƒ‘ãƒ¼ã‚µãƒ¼ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    RecursiveLexer lexer_;
    // ... ä»–ã®privateãƒ¡ãƒ³ãƒãƒ¼
};
```

**åˆ©ç‚¹**:
- æ®µéšçš„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ãŒå¯èƒ½
- æ—¢å­˜å®Ÿè£…ã‚’ä¿æŒã—ãªãŒã‚‰æ§‹é€ æ”¹å–„
- Phase 5ã§å®Ÿè£…ç§»è¡Œæ™‚ã«å¾ã€…ã«friendå®£è¨€ã‚’å‰Šé™¤å¯èƒ½

### 2. unique_ptrã«ã‚ˆã‚‹è‡ªå‹•ãƒ¡ãƒ¢ãƒªç®¡ç†
```cpp
class RecursiveParser {
private:
    std::unique_ptr<ExpressionParser> expression_parser_;
    std::unique_ptr<StatementParser> statement_parser_;
    // ...
};
```

**åˆ©ç‚¹**:
- è‡ªå‹•çš„ãªãƒ¡ãƒ¢ãƒªè§£æ”¾
- æ‰€æœ‰æ¨©ã®æ˜ç¢ºåŒ–
- ã‚³ãƒ”ãƒ¼ç¦æ­¢ã«ã‚ˆã‚‹å®‰å…¨æ€§

### 3. å§”è­²ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆPhase 2-3ï¼‰
```cpp
// ExpressionParser
ASTNode* ExpressionParser::parseExpression() {
    return parser_->parseExpression();  // RecursiveParserã«å§”è­²
}
```

**åˆ©ç‚¹**:
- æ—¢å­˜å®Ÿè£…ã‚’å®Œå…¨ä¿æŒ
- æ®µéšçš„ãªç§»è¡ŒãŒå¯èƒ½
- ãƒ†ã‚¹ãƒˆã®100%åˆæ ¼ã‚’ä¿è¨¼

### 4. å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆPhase 5äºˆå®šï¼‰
```cpp
// ExpressionParserï¼ˆPhase 5ä»¥é™ï¼‰
ASTNode* ExpressionParser::parseExpression() {
    // RecursiveParserã‹ã‚‰ç§»è¡Œã•ã‚ŒãŸå®Ÿè£…
    ASTNode* left = parseAssignment();
    
    while (parser_->check(TOKEN_COMMA)) {
        parser_->advance();
        // å†…éƒ¨çŠ¶æ…‹ã‚¢ã‚¯ã‚»ã‚¹ã¯ parser_-> çµŒç”±
        ASTNode* right = parseAssignment();
        // ...
    }
    
    return left;
}
```

**å¤‰æ›ãƒ«ãƒ¼ãƒ«**:
- `current_token_` â†’ `parser_->current_token_`
- `advance()` â†’ `parser_->advance()`
- `check()` â†’ `parser_->check()`
- `match()` â†’ `parser_->match()`
- `error()` â†’ `parser_->error()`

## ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æ¨ç§»

```
900ms â”¤
      â”‚
850ms â”¤         â—Phase2 (863ms)
      â”‚        /
800ms â”¤       /    â—Phase3 (804ms) â† 22%æ”¹å–„ï¼
      â”‚â—Baseline (830ms)    \
750ms â”¤      \               \
      â”‚       \               â—Phase1 (833ms)
700ms â”¤        \______________
      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
       Phase0  Phase1  Phase2  Phase3
```

**æ”¹å–„è¦å› **:
1. Phase 1-2: æ§‹é€ åŒ–ã«ã‚ˆã‚‹ã‚ãšã‹ãªå¢—åŠ ï¼ˆ+30msï¼‰
2. Phase 3: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰æ•´ç†ï¼ˆ-59msã€22%æ”¹å–„ï¼‰
3. æœ€çµ‚çµæœ: Baselineã‚ˆã‚Š3.1%é«˜é€ŸåŒ–

## ğŸ¯ Phase 5ã®ç›®æ¨™

### ã‚³ãƒ¼ãƒ‰é‡ã®å‰Šæ¸›ç›®æ¨™

| ãƒ•ã‚¡ã‚¤ãƒ« | ç¾åœ¨ | Phase 5å¾Œ | å‰Šæ¸›ç‡ |
|---------|------|-----------|--------|
| recursive_parser.cpp | 5606è¡Œ | ~3000è¡Œ | -46% |
| expression_parser.cpp | 398è¡Œ | ~1000è¡Œ | +151% |
| statement_parser.cpp | 211è¡Œ | ~700è¡Œ | +232% |
| declaration_parser.cpp | 162è¡Œ | ~800è¡Œ | +394% |
| type_parser.cpp | 252è¡Œ | ~400è¡Œ | +59% |
| struct_parser.cpp | 234è¡Œ | ~600è¡Œ | +156% |
| **åˆè¨ˆ** | **6863è¡Œ** | **~6500è¡Œ** | **-5%** |

**æœŸå¾…åŠ¹æœ**:
- recursive_parser.cppãŒç´„2600è¡Œå‰Šæ¸›
- å„ãƒ‘ãƒ¼ã‚µãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒ1000è¡Œä»¥ä¸‹
- é‡è¤‡ã‚³ãƒ¼ãƒ‰ã®å‰Šæ¸›ã«ã‚ˆã‚Šå…¨ä½“ã§ç´„350è¡Œå‰Šæ¸›

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®æœ€çµ‚å½¢

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            RecursiveParser (3000è¡Œ)                   â”‚
â”‚            - ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†                              â”‚
â”‚            - çŠ¶æ…‹ç®¡ç†ï¼ˆtypedef, structç­‰ï¼‰             â”‚
â”‚            - ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–² å†…éƒ¨çŠ¶æ…‹ã‚¢ã‚¯ã‚»ã‚¹
                      â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                 â”‚                 â”‚
    â–¼                 â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Expr    â”‚     â”‚ Stmt    â”‚     â”‚ Decl    â”‚
â”‚ Parser  â”‚     â”‚ Parser  â”‚     â”‚ Parser  â”‚
â”‚ 1000è¡Œ  â”‚     â”‚ 700è¡Œ   â”‚     â”‚ 800è¡Œ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
              â–¼               â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Type    â”‚     â”‚ Struct  â”‚
         â”‚ Parser  â”‚     â”‚ Parser  â”‚
         â”‚ 400è¡Œ   â”‚     â”‚ 600è¡Œ   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è¨­è¨ˆåŸå‰‡**:
1. **å˜ä¸€è²¬ä»»ã®åŸå‰‡**: å„ãƒ‘ãƒ¼ã‚µãƒ¼ã¯æ˜ç¢ºãªè²¬ä»»ã‚’æŒã¤
2. **1000è¡Œãƒ«ãƒ¼ãƒ«**: å„ãƒ•ã‚¡ã‚¤ãƒ«ã¯1000è¡Œä»¥ä¸‹ã‚’ç¶­æŒ
3. **ãƒ†ã‚¹ãƒˆé§†å‹•**: å„ç§»è¡Œå¾Œã«å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼ã‚’ç¢ºèª

---

## ğŸ†• v0.11.0ã®æ©Ÿèƒ½è¿½åŠ 

### ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å¯¾å¿œ

**Parserå´ã®å¤‰æ›´**:
- `parseGenericParams()`: å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è§£æ
- `parseGenericArgs()`: å‹å¼•æ•°ã®è§£æ
- struct/enum/é–¢æ•°å®£è¨€ã§ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹æ–‡ã‚µãƒãƒ¼ãƒˆ
- `impl Struct<T, A: Allocator> {}` æ§‹æ–‡ã®è§£æ

**Interpreterå´ã®å¤‰æ›´**:
- Genericæ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã‚·ã‚¹ãƒ†ãƒ 
- Genericé–¢æ•°ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
- å‹åã®ãƒãƒ³ã‚°ãƒªãƒ³ã‚°/ã‚¢ãƒ³ãƒãƒ³ã‚°ãƒªãƒ³ã‚°
- ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹é«˜é€ŸåŒ–

### æ–‡å­—åˆ—è£œé–“å¯¾å¿œ

**Lexerå´ã®å¤‰æ›´**:
- `{}` å†…ã®å¼è§£æ
- ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­ã®è§£æï¼ˆ`:d`, `:x`, `:.2f` ãªã©ï¼‰
- ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ `{{` ã¨ `}}` ã®å‡¦ç†

**Interpreterå´ã®å¤‰æ›´**:
- å®Ÿè¡Œæ™‚ã®å¼è©•ä¾¡
- å‹ã«å¿œã˜ãŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå‡¦ç†
- æ–‡å­—åˆ—é€£çµã®æœ€é©åŒ–

### ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¯¾å¿œ

**Parserå´ã®å¤‰æ›´**:
- `~self()` æ§‹æ–‡ã®è§£æï¼ˆæ³¨æ„: `fn deinit()` ã§ã¯ãªã„ï¼‰
- implãƒ–ãƒ­ãƒƒã‚¯å†…ã§ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å®£è¨€
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ `self()` ã¨ã®ä½µç”¨

**Interpreterå´ã®å¤‰æ›´**:
- ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†ï¼ˆ`push_destructor_scope()`, `pop_destructor_scope()`ï¼‰
- LIFOé †åºã§ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å®Ÿè¡Œ
- break/continueæ™‚ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
- returnæ–‡å®Ÿè¡Œå‰ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆdefer â†’ ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ â†’ returnï¼‰
- ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å‹åã‚¢ãƒ³ãƒãƒ³ã‚°ãƒ«

### ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°

**matchæ–‡ã®å®Ÿè£…**:
- Enumå°‚ç”¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
- variantåã«ã‚ˆã‚‹åˆ†å²
- é–¢é€£å€¤ã®æŠ½å‡ºï¼ˆdestructuringï¼‰
- ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ `_` ã®ã‚µãƒãƒ¼ãƒˆ

**ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³**:
```cb
match (option) {
    Some(value) => println("Value: {value}"),
    None => println("No value")
}

match (result) {
    Ok(val) => println("Success: {val}"),
    Err(e) => println("Error: {e}")
}
```

### é…åˆ—æ“ä½œçµ„ã¿è¾¼ã¿é–¢æ•°

**array_get() / array_set()**:
- å®Ÿè¡Œæ™‚å¢ƒç•Œãƒã‚§ãƒƒã‚¯ä»˜ãé…åˆ—ã‚¢ã‚¯ã‚»ã‚¹
- ç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’åœæ­¢
- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã®è©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±æä¾›

**ä½¿ç”¨ä¾‹**:
```cb
int[5] arr = [1, 2, 3, 4, 5];
int val = array_get(arr, 2, 5);  // å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹
array_set(arr, 3, 100, 5);       // å®‰å…¨ãªè¨­å®š
```

### ãƒ¡ãƒ¢ãƒªç®¡ç†é–¢æ•°

**malloc() / free()**:
- Cè¨€èªã‚¹ã‚¿ã‚¤ãƒ«ã®å‹•çš„ãƒ¡ãƒ¢ãƒªç®¡ç†
- `void*` å‹ã®è¿”å´
- æ‰‹å‹•ã§ã®å‹ã‚­ãƒ£ã‚¹ãƒˆãŒå¿…è¦

**å®Ÿè£…çŠ¶æ³**:
- âœ… malloc/free: å®Ÿè£…æ¸ˆã¿
- ğŸ”„ new/delete: è¨ˆç”»ä¸­ï¼ˆå‹å®‰å…¨ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿è‡ªå‹•å‘¼ã³å‡ºã—ï¼‰

---

## ğŸ“Š ãƒ†ã‚¹ãƒˆçµ±è¨ˆã®æ¨ç§»

| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | çµ±åˆãƒ†ã‚¹ãƒˆ | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ | åˆè¨ˆ | æˆåŠŸç‡ |
|-----------|-----------|--------------|------|--------|
| v0.9.0 | 2,349 | 30 | 2,379 | 100% |
| v0.9.1 | 2,447 | 30 | 2,477 | 100% |
| v0.9.2 | 2,798 | 30 | 2,828 | 100% |
| v0.10.0 | 2,924 | 30 | 2,954 | 100% |
| **v0.11.0** | **3,341** | **30** | **3,371** | **100%** |

---

## ğŸ†• v0.11.0 Part 1a ã®ä¸»è¦å¤‰æ›´ï¼ˆ2025å¹´11æœˆ5æ—¥ï¼‰

### æ¨™æº–ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å®Œæˆ

#### Map<K, V> - AVLè‡ªå·±å¹³è¡¡äºŒåˆ†æ¢ç´¢æœ¨
**å®Ÿè£…æ—¥**: 2025å¹´11æœˆ5æ—¥

**å®Ÿè£…å†…å®¹**:
- AVLãƒ„ãƒªãƒ¼ã«ã‚ˆã‚‹è‡ªå·±å¹³è¡¡äºŒåˆ†æ¢ç´¢æœ¨
- ã™ã¹ã¦ã®æ“ä½œã§O(log n)ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä¿è¨¼
- 4ã¤ã®å›è»¢ã‚±ãƒ¼ã‚¹ï¼ˆLL, LR, RR, RLï¼‰ã«ã‚ˆã‚‹è‡ªå‹•ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°
- ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹å¯¾å¿œ: Map<K, V>ã§ä»»æ„ã®å‹çµ„ã¿åˆã‚ã›
- ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚‹è‡ªå‹•ãƒ¡ãƒ¢ãƒªè§£æ”¾

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¤œè¨¼**:
- 1000è¦ç´ æŒ¿å…¥: ãƒ„ãƒªãƒ¼é«˜ã•10ï¼ˆç†è«–æœ€é©å€¤: 9.97ï¼‰
- 200å›æ¤œç´¢: 100%æˆåŠŸç‡
- 500è¦ç´ å‰Šé™¤: æ­£å¸¸å‹•ä½œ

**API**:
- `init()`: åˆæœŸåŒ–
- `insert(K key, V value)`: O(log n)
- `get(K key, V default)`: O(log n)
- `contains(K key)`: O(log n)
- `try_remove(K key)`: O(log n)
- `clear()`: å…¨å‰Šé™¤
- `size()`: è¦ç´ æ•°å–å¾—

**ãƒ†ã‚¹ãƒˆ**:
- test_basic.cb: 10ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æˆåŠŸ
- test_stress.cb: 4ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆæˆåŠŸ
- stdlib-test: å…¨28ãƒ†ã‚¹ãƒˆæˆåŠŸ

#### ãƒ†ã‚¹ãƒˆæ§‹é€ ã®å†ç·¨æˆ
**å®Ÿè£…æ—¥**: 2025å¹´11æœˆ5æ—¥

**ç›®çš„**: stdlib/ã®éšå±¤ã¨ãƒ†ã‚¹ãƒˆéšå±¤ã‚’ä¸€è‡´ã•ã›ã€ä¿å®ˆæ€§å‘ä¸Š

**æ–°æ§‹é€ **:
```
tests/cases/stdlib/collections/
â”œâ”€â”€ map/           # Map<K, V>ãƒ†ã‚¹ãƒˆ
â”œâ”€â”€ vector/        # Vector<T>ãƒ†ã‚¹ãƒˆ
â””â”€â”€ queue/         # Queue<T>ãƒ†ã‚¹ãƒˆ
```

**å¤‰æ›´å†…å®¹**:
- å„ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã«å°‚ç”¨ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ
- å„ãƒ•ã‚©ãƒ«ãƒ€ã«README.mdã‚’è¿½åŠ 
- Makefileã¨C++ãƒ†ã‚¹ãƒˆã®ãƒ‘ã‚¹ã‚’æ›´æ–°
- å…¨16ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç§»å‹•

**ãƒ†ã‚¹ãƒˆçµæœ**:
- C++ãƒ†ã‚¹ãƒˆ: 28/28æˆåŠŸ
- Cbãƒ†ã‚¹ãƒˆ: 3/3æˆåŠŸ
- make stdlib-test: å®Œå…¨æˆåŠŸ

---

### Vector<T>ã®åŒæ–¹å‘ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆå®Ÿè£…

**å®Ÿè£…å†…å®¹**:
- å¾“æ¥ã®é…åˆ—ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ãƒãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹åŒæ–¹å‘ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆã«å®Œå…¨ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- O(1)ã§ã®å…ˆé ­ãƒ»æœ«å°¾ã¸ã®æŒ¿å…¥/å‰Šé™¤ã‚’å®Ÿç¾
- ãƒãƒ¼ãƒ‰ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: `[prev (sizeof(void*))][next (sizeof(void*))][data (sizeof(T))]`

**APIå¤‰æ›´**:
- **å‰Šé™¤ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰**: `init()`, `reserve()`, `get_capacity()`
- **æ–°è¦è¿½åŠ **: `push_front()`, `pop_front()`, `delete_at()`, `find()`, `sort()`
- **ä¿æŒ**: `push_back()`, `pop_back()`, `get()`, `set()`, `get_length()`, `clear()`

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**:
- å…ˆé ­è¿½åŠ : O(n) â†’ O(1)
- æœ«å°¾è¿½åŠ : O(1) â†’ O(1)ï¼ˆå¤‰ã‚ã‚‰ãšï¼‰
- ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¯ã‚»ã‚¹: O(1) â†’ O(n)ï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ï¼‰

**ãƒ†ã‚¹ãƒˆ**:
- æ–°è¦ãƒ†ã‚¹ãƒˆ: 7å€‹ï¼ˆãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆæ©Ÿèƒ½ï¼‰
- æ—¢å­˜ãƒ†ã‚¹ãƒˆ: ã™ã¹ã¦åˆæ ¼ï¼ˆ27/27ï¼‰

### importæ–‡ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«æ§‹æ–‡å»ƒæ­¢

**å®Ÿè£…å†…å®¹**:
- æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«importï¼ˆ`import "path/to/file.cb";`ï¼‰ã‚’å»ƒæ­¢
- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‘ã‚¹æ§‹æ–‡ï¼ˆ`import module.path.name;`ï¼‰ã«çµ±ä¸€
- ãƒ‘ãƒ¼ã‚µãƒ¼ãƒ¬ãƒ™ãƒ«ã§ã®ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã‚’è¿½åŠ 

**å¤‰æ›´ã•ã‚ŒãŸç®‡æ‰€**:
- `statement_parser.cpp`: æ–‡å­—åˆ—ãƒˆãƒ¼ã‚¯ãƒ³æ¤œå‡ºæ™‚ã«ã‚¨ãƒ©ãƒ¼ã‚’å ±å‘Š
- `recursive_parser.cpp`: æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«importã®å‡¦ç†ã‚’å‰Šé™¤

**å½±éŸ¿ç¯„å›²**:
- 41ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°
- å…¨ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã€ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ›´æ–°

**ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**:
```
Error: String literal import syntax is deprecated. 
Use 'import module.path.name;' instead of 'import "path/to/file.cb";'
```

**ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:
```bash
# æ—§æ§‹æ–‡ã‹ã‚‰æ–°æ§‹æ–‡ã¸ã®è‡ªå‹•å¤‰æ›
sed -i 's/import "\([^"]*\)";/import \1;/g' *.cb
sed -i 's/\//./g' *.cb  # ãƒ‘ã‚¹åŒºåˆ‡ã‚Šã‚’ . ã«å¤‰æ›
```

---

## ğŸ—‚ï¸ æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ§‹é€ ï¼ˆv0.11.0ï¼‰

### stdlibå†ç·¨æˆ

**v0.11.0ã®å¤‰æ›´ç‚¹**:
- `stdlib.collections.*` â†’ `stdlib.std.*` ã«çµ±åˆ
- çµ„ã¿è¾¼ã¿å‹ï¼ˆResult, Option, memory, ioï¼‰ã‚’å‰Šé™¤
- `str.cb` â†’ `string.cb` ã«åå‰å¤‰æ›´

### æœ€çµ‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
stdlib/
â”œâ”€â”€ std/                    # æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªçµ±åˆãƒ•ã‚©ãƒ«ãƒ€
â”‚   â”œâ”€â”€ test.cb            # TestFramework, assert_*
â”‚   â”œâ”€â”€ string.cb          # String, StringOps (19ãƒ¡ã‚½ãƒƒãƒ‰)
â”‚   â”œâ”€â”€ vector.cb          # Vector<T> åŒæ–¹å‘ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆ
â”‚   â”œâ”€â”€ queue.cb           # Queue<T> å¾ªç’°ãƒãƒƒãƒ•ã‚¡
â”‚   â””â”€â”€ map.cb             # Map<K, V> AVLè‡ªå·±å¹³è¡¡æœ¨
â”œâ”€â”€ async/                  # éåŒæœŸå‡¦ç†ï¼ˆv0.12.0äºˆå®šï¼‰
â”‚   â””â”€â”€ task_queue.cb      # TaskQueueï¼ˆasync/awaitç”¨ï¼‰
â””â”€â”€ allocators/             # ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿
    â””â”€â”€ system.cb          # SystemAllocator
```

### importæ§‹æ–‡ãƒãƒƒãƒ”ãƒ³ã‚°

```cb
// âŒ æ—§ï¼ˆå»ƒæ­¢ï¼‰
import stdlib.collections.vector;
import stdlib.collections.queue;
import stdlib.collections.map;
import stdlib.std.str;
import stdlib.std.result;
import stdlib.std.option;

// âœ… æ–°
import stdlib.std.vector;
import stdlib.std.queue;
import stdlib.std.map;
import stdlib.std.string;
// Result<T, E> ã¨ Option<T> ã¯çµ„ã¿è¾¼ã¿å‹ï¼ˆimportä¸è¦ï¼‰
```

### ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹è§£æ±º

```
import stdlib.std.vector;
  â†“
stdlib/std/vector.cb

import stdlib.std.queue;
  â†“
stdlib/std/queue.cb
```

### ãƒ†ã‚¹ãƒˆæ§‹é€ 

```
tests/cases/stdlib/
â”œâ”€â”€ collections/           # ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ map/              # Mapãƒ†ã‚¹ãƒˆ
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ test_basic.cb
â”‚   â”‚   â””â”€â”€ test_stress.cb
â”‚   â”œâ”€â”€ vector/           # Vectorãƒ†ã‚¹ãƒˆï¼ˆ10ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â””â”€â”€ test_vector_*.cb
â”‚   â””â”€â”€ queue/            # Queueãƒ†ã‚¹ãƒˆï¼ˆ4ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
â”‚       â”œâ”€â”€ README.md
â”‚       â””â”€â”€ test_queue_*.cb
â””â”€â”€ string/               # æ–‡å­—åˆ—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ†ã‚¹ãƒˆ
    â””â”€â”€ test_*.cb
```

### å®Œå…¨ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

```
docs/stdlib/std/
â”œâ”€â”€ README.md             # æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ¦‚è¦
â”œâ”€â”€ vector.md             # Vector<T> APIæ–‡æ›¸
â”œâ”€â”€ queue.md              # Queue<T> APIæ–‡æ›¸
â”œâ”€â”€ map.md                # Map<K, V> APIæ–‡æ›¸
â”œâ”€â”€ string.md             # String APIæ–‡æ›¸
â””â”€â”€ test.md               # TestFramework APIæ–‡æ›¸
```

### APIæ¦‚è¦

| ãƒ©ã‚¤ãƒ–ãƒ©ãƒª | ä¸»ãªå‹ | ä¸»ãªæ©Ÿèƒ½ | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ |
|-----------|--------|---------|---------------|
| **test.cb** | TestResult, TestFramework | assert_*, print_summary | - |
| **string.cb** | String, StringOps | 19ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ¯”è¼ƒã€æ¤œç´¢ã€å¤‰æ›ï¼‰ | O(n) |
| **vector.cb** | Vector<T> | åŒæ–¹å‘ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆã€ã‚½ãƒ¼ãƒˆ | O(1) å…ˆé ­/æœ«å°¾ã€O(n) ã‚¢ã‚¯ã‚»ã‚¹ |
| **queue.cb** | Queue<T> | å¾ªç’°ãƒãƒƒãƒ•ã‚¡ã€FIFO | O(1) enqueue/dequeue |
| **map.cb** | Map<K, V> | AVLè‡ªå·±å¹³è¡¡æœ¨ã€æŒ¿å…¥/æ¤œç´¢/å‰Šé™¤ | O(log n) ã™ã¹ã¦ |

---

## ğŸš€ Async/Await ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ (v0.12.1)

### æ¦‚è¦

v0.12.1ã§ã¯ã€**å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯**ã«ã‚ˆã‚‹éåŒæœŸå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ãŒå®Œå…¨å®Ÿè£…ã•ã‚Œã¾ã—ãŸã€‚

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

#### 1. EventLoop (simple_event_loop.cpp)

**å½¹å‰²**: ã‚¿ã‚¹ã‚¯ã®ç™»éŒ²ã€å®Ÿè¡Œã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°

**ä¸»è¦æ©Ÿèƒ½**:
- ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ç®¡ç†
- Future<T>ã®çŠ¶æ…‹ç®¡ç†
- yield/auto-yieldå®Ÿè£…
- ã‚¿ã‚¹ã‚¯ãƒ•ã‚§ã‚¢ãƒã‚¹ä¿è¨¼

**å®Ÿè£…è©³ç´°**:
```cpp
class SimpleEventLoop {
    std::map<int, Task> tasks_;
    std::queue<int> task_queue_;
    int next_task_id_;
    
    void register_task(Task task);
    void run();
    TypedValue await_future(Variable* future_var);
};
```

#### 2. Future<T> å‹ (builtin_types.cpp)

**æ§‹é€ **:
```cb
struct Future<T> {
    T value;
    bool is_ready;
    int task_id;
}
```

**ç‰¹å¾´**:
- ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¯¾å¿œ
- Result<T,E>/Option<T>çµ±åˆ
- enumæƒ…å ±å®Œå…¨ä¿æŒ

#### 3. async/await/yieldæ§‹æ–‡

**ãƒ‘ãƒ¼ã‚µãƒ¼å¯¾å¿œ** (statement_parser.cpp):
- `async T func()` â†’ è‡ªå‹•çš„ã« `Future<T>` ã«ãƒ©ãƒƒãƒ”ãƒ³ã‚°
- `await expr` â†’ EventLoopçµŒç”±ã§å€¤å–å¾—
- `yield` â†’ æ˜ç¤ºçš„ãªã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆ

**å‹æ¨è«–**:
```
async int compute(int x) { ... }
      â†“
Future<int> compute(int x) { ... }
      â†“
await future â†’ int
```

#### 4. enumæƒ…å ±ä¿æŒ (v0.12.1å®Œå…¨ä¿®æ­£)

**å®Ÿè£…ç®‡æ‰€**:
- `return.cpp`: TYPE_ENUMã¨ã—ã¦è¿”ã™
- `simple_event_loop.cpp`: enumæƒ…å ±ã‚’æŒã¤struct_valueä½œæˆ
- `declaration.cpp`: awaitæ™‚ã®enumæƒ…å ±å¾©å…ƒ
- `binary_unary.cpp`: enumæƒ…å ±å–å¾—

**å¯¾å¿œãƒ‘ã‚¿ãƒ¼ãƒ³**:
- âœ… ç›´æ¥return Option::None/Some
- âœ… ç›´æ¥return Result::Ok/Err
- âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°çµ±åˆ

### å®Ÿè¡Œãƒ•ãƒ­ãƒ¼

```
1. asyncé–¢æ•°å‘¼ã³å‡ºã—
   â†“
2. Taskã¨ã—ã¦register_task()
   â†“
3. Future<T>ã‚’å³åº§ã«è¿”ã™
   â†“
4. EventLoop::run()ã§ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
   â†“
5. yieldæ™‚ã«ä»–ã®ã‚¿ã‚¹ã‚¯ã«åˆ‡ã‚Šæ›¿ãˆ
   â†“
6. returnã§Future.is_ready = true
   â†“
7. awaitæ™‚ã«Future.valueã‚’å–å¾—
```

### ã‚¿ã‚¹ã‚¯ãƒ•ã‚§ã‚¢ãƒã‚¹

**ãƒ«ãƒ¼ãƒ—å†…auto-yield**:
```cb
async int task() {
    for (int i = 0; i < 100; i++) {
        // è‡ªå‹•çš„ã«yieldæŒ¿å…¥
        work(i);
    }
}
```

**å†å¸°é–¢æ•°auto-yield**:
```cb
async int recursive(int n) {
    if (n == 0) return 1;
    // è‡ªå‹•çš„ã«yieldæŒ¿å…¥
    return await recursive(n - 1) * 2;
}
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç‰¹æ€§

- **ã‚¹ãƒ¬ãƒƒãƒ‰ä¸è¦**: ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯
- **ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–**: awaitæ™‚ã®ã¿ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: ã‚¿ã‚¹ã‚¯æ¯ã«æœ€å°é™ã®ãƒ¡ãƒ¢ãƒª
- **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**: ã‚¿ã‚¹ã‚¯æ•°ã«æ¯”ä¾‹ã—ãŸO(n)

---

**ä½œæˆæ—¥**: 2025å¹´1æœˆ  
**æœ€çµ‚æ›´æ–°**: 2025å¹´11æœˆ11æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.12.1  
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: Async/Awaitå®Œå…¨å®Ÿè£…ã€Production Ready
