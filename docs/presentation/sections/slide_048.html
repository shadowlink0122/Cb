<section class="left-align">
  <h2>インタプリタ内部実装（1）: interface/impl</h2>
  <div style="width: 88%; margin: 0.25em auto 0">
    <h3 style="font-size: 0.72em; margin-bottom: 0.25em">仮想メソッドテーブル（動的ディスパッチ）</h3>
    <pre
      style="font-size: 0.46em; margin: 0.3em 0"
    ><code class="language-cpp" data-trim>// 1. interface定義時: メソッドシグネチャを登録
interface Drawable {
    void draw();  // → インタプリタ内部でメソッド名と型情報を記録
}

// 2. impl定義時: 型とinterfaceの関連付け
impl Drawable for Circle {
    void draw() { /* 実装 */ }
}
// → インタプリタ内部で vtable[Circle][Drawable::draw] = 実装へのポインタ

// 3. メソッド呼び出し時: 動的ディスパッチ
Circle c;
c.draw();  // → 実行時に vtable[Circle型][draw] を検索して実行</code></pre>

    <h3 style="font-size: 0.72em; margin-bottom: 0.25em; margin-top: 0.25em">C++実装の概要</h3>
    <pre
      style="font-size: 0.46em; margin: 0.3em 0"
    ><code class="language-cpp" data-trim>// インタプリタ内部のデータ構造
struct InterfaceMethod {
    std::string name;         // メソッド名
    TypeInfo return_type;     // 戻り値の型
    std::vector&lt;TypeInfo&gt; params;  // パラメータの型リスト
};

// 型 → interface → メソッド実装 のマップ
std::map&lt;TypeInfo, std::map&lt;std::string, ASTNode*&gt;&gt; interface_impls;

// メソッド呼び出しの解決
ASTNode* resolve_method(TypeInfo type, std::string method_name) {
    return interface_impls[type][method_name];  // O(log n)で検索
}</code></pre>
  </div>
</section>
