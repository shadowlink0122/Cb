<section class="left-align">
  <h2>インタプリタ内部実装（2）: 協調的マルチタスク（2/2）</h2>
  <div style="width: 88%; margin: 0.25em auto 0">
    <h3 style="font-size: 0.72em; margin-bottom: 0.25em">await/sleepの動作</h3>
    <pre
      style="font-size: 0.46em; margin: 0.3em 0"
    ><code class="language-cpp" data-trim>// await: 他のタスクの完了を待つ
void execute_await(Task* current_task, Task* target_task) {
    if (target_task->state == TaskState::Completed) {
        // 既に完了: 即座に結果を返す
        current_task->result = target_task->result;
    } else {
        // 未完了: 現在のタスクを一時停止して、依存関係を登録
        current_task->state = TaskState::Suspended;
        current_task->deps.push_back(target_task);
        suspended_tasks.push_back(current_task);
        // → 他のタスクが実行される（協調的マルチタスク）
    }
}

// sleep: 指定時間だけタスクを停止（他のタスクをブロックしない）
void execute_sleep(Task* task, long duration_ms) {
    task->state = TaskState::Suspended;
    task->resume_time_ms = current_time_ms + duration_ms;  // 再開時刻を設定
    suspended_tasks.push_back(task);
    // → 他のタスクが実行される（sleepは他をブロックしない！）
}

// 時間経過チェック: sleep中のタスクを再開
void check_sleeping_tasks() {
    for (auto it = suspended_tasks.begin(); it != suspended_tasks.end();) {
        if ((*it)->resume_time_ms &lt;= current_time_ms) {
            // 時間が来たので再開
            (*it)->state = TaskState::Ready;
            ready_queue.push(*it);
            it = suspended_tasks.erase(it);
        } else {
            ++it;
        }
    }
}</code></pre>
  </div>
</section>
