<section class="left-align">
  <h2>協調的マルチタスク（async/await）の実装 - Part 2</h2>
  <div style="width: 88%; margin: 0.25em auto 0">
    <h3 style="font-size: 0.72em; margin-bottom: 0.25em">Event Loop実行ロジック</h3>
    <pre
      style="font-size: 0.46em; margin: 0.3em 0; max-height: 230px; overflow-y: auto"
    ><code class="language-cpp" data-trim>
// Event Loopを実行
void EventLoop::run() {
    while (!task_queue.empty()) {
        Task* task = task_queue.front();
        task_queue.pop_front();
        
        // await式を評価（制御を戻す可能性あり）
        TypedValue result = evaluate_task(task);
        
        if (result.is_pending()) {
            // まだ完了していない → キューに戻す
            if (current_time_ms() >= task->wake_time) {
                task_queue.push_back(task);
            } else {
                task_queue.push_back(task);
            }
        } else {
            // 完了 → Futureを解決
            resolve_future(task->id, result);
            delete task;
        }
    }
}
</code></pre>
    <h3 style="font-size: 0.72em; margin-bottom: 0.25em; margin-top: 0.25em">タスクスケジューリングの流れ</h3>
    <ul style="font-size: 0.6em; line-height: 1.2; margin: 0; padding-left: 1.3em">
      <li>
        <strong>1. spawn_task()</strong>
        : async関数を実行キューに登録
      </li>
      <li>
        <strong>2. run()</strong>
        : タスクキューからタスクを取り出して実行
      </li>
      <li>
        <strong>3. await評価</strong>
        : Futureが未完了なら制御をEvent Loopに戻す（<code>Pending</code>）
      </li>
      <li>
        <strong>4. 再スケジュール</strong>
        : 未完了タスクはキューの後ろに戻す
      </li>
      <li>
        <strong>5. 完了</strong>
        : タスクが完了したらFutureを解決し、メモリを解放
      </li>
    </ul>
    <p class="fragment" style="font-size: 0.58em; margin-top: 0.25em; text-align: center">
      <strong class="success">キーポイント</strong>
      : タスクが自発的に制御を譲渡（yield）するため、デッドロックやレースコンディションが発生しない
    </p>
  </div>
</section>
