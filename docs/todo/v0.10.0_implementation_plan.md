# v0.10.0 実装計画

**作成日**: 2025年10月5日  
**最終更新**: 2025年10月6日  
**対象バージョン**: v0.10.0  
**ベースバージョン**: v0.9.0

---

## 📊 実装状況サマリー（2025/10/06時点）

### ✅ 完了した機能
- **関数ポインタ**: 完全実装（5テスト追加、2424/2424成功）
  - 宣言、初期化、呼び出し（2形式）
  - 関数ポインタを返す関数
  - チェーン呼び出し
  - コールバック関数
  - アドレス比較と表示

### 🔄 実装中の機能
- なし（次のフェーズ待ち）

### 📋 未実装の機能（優先順）
1. **多次元配列へのポインタ** - 高優先度
2. **構造体配列メンバーの関数戻り値代入** - 中優先度
3. **多次元配列の関数戻り値からメンバー代入** - 中優先度
4. **ポインタ配列の包括的テスト** - 中優先度
5. **const ポインタ** - 低優先度
6. **多重ポインタ** - 低優先度

---

## 🎯 実装する機能

### ✅ 既に完了
1. ✅ **impl内static変数** - 完全実装済み（26テスト成功）
2. ✅ **nullptr リテラル** - 完全実装済み
3. ✅ **参照型** `int&` - 完全実装済み
4. ✅ **関数ポインタ** - 完全実装済み（2024/10/06完了、5テスト追加）

### 🔥 次期実装機能

#### 13. 関数ポインタ（コールバック用） ✅ **完了**

**優先度**: 🔴 **必須**  
**理由**: コールバック機能が必要  
**状態**: ✅ **実装完了**（2024/10/06）

**実装された機能**:
```cb
// 関数ポインタの宣言と初期化
int add(int a, int b) { return a + b; }
int* op = &add;

// 呼び出し（2つの形式）
int result1 = op(5, 3);      // 暗黙的呼び出し
int result2 = (*op)(5, 3);   // 明示的デリファレンス

// 関数ポインタを返す関数
int* getOperation(int code) {
    if (code == 1) return &add;
    return &subtract;
}

// チェーン呼び出し
int result = getOperation(3)(6, 7);

// コールバック関数
int apply(int* callback, int x, int y) {
    return callback(x, y);
}

// アドレス比較と表示
int* fp1 = &add;
int* fp2 = &add;
if (fp1 == fp2) { }  // 同じ関数
println(op);  // 0x12345678 (16進数)
```

**実装完了項目**:
- [x] 関数ポインタの宣言と初期化
- [x] 2つの呼び出し形式（暗黙的・明示的）
- [x] 関数ポインタを返す関数
- [x] チェーン呼び出し
- [x] コールバック関数
- [x] ポインタのアドレス比較
- [x] アドレス表示（16進数）
- [x] 関数ポインタの再代入
- [x] 包括的なテスト（5テストケース、2424/2424成功）

---

### 🟡 優先度中（今回実装）

#### 2. 多次元配列へのポインタ

**優先度**: 🟡 **中**  
**理由**: ポインタシステムの完全性向上

**基本構文**:
```c++
int[3][4] matrix = [[1,2,3,4], [5,6,7,8], [9,10,11,12]];

// 行へのポインタ
int(*row_ptr)[4] = &matrix[0];  // 4要素配列へのポインタ

// ポインタ演算
row_ptr++;  // 次の行へ
int value = (*row_ptr)[2];  // matrix[1][2]と同じ

// 要素へのポインタ
int* elem_ptr = &matrix[1][2];
*elem_ptr = 100;
```

**実装要件**:
1. 配列へのポインタ型: `int(*ptr)[n]`
2. 行ポインタのポインタ演算
3. デリファレンスと配列アクセスの組み合わせ
4. 型チェックの強化

**実装ステップ**:
- [ ] 型システム: 配列ポインタ型の表現
- [ ] パーサー: `int(*ptr)[n]` 構文の解析
- [ ] インタプリタ: 配列ポインタの演算
- [ ] テスト: 多次元配列ポインタのテスト

---

#### 3. 構造体配列メンバーの関数戻り値代入

**優先度**: 🟡 **中**  
**理由**: 利便性向上

**問題**:
```c++
struct Container {
    int[5] data;
};

int[5] create_array() {
    return [1, 2, 3, 4, 5];
}

int main() {
    Container c;
    // ❌ 現在は不可
    c.data = create_array();
    return 0;
}
```

**実装要件**:
1. 構造体メンバー配列への関数戻り値の直接代入
2. メモリコピーの最適化
3. 型チェック（サイズ一致）

**実装ステップ**:
- [ ] インタプリタ: 配列メンバーへの代入処理
- [ ] 型チェック: サイズ一致の検証
- [ ] テスト: 構造体配列メンバー代入のテスト

---

#### 4. 多次元配列の関数戻り値からメンバー代入

**優先度**: 🟡 **中**  
**理由**: 利便性向上（3の拡張）

**問題**:
```c++
struct Matrix {
    int[2][2] data;
};

int[2][2] create_matrix() {
    return [[1, 2], [3, 4]];
}

int main() {
    Matrix m;
    // ❌ 現在は不可
    m.data = create_matrix();
    return 0;
}
```

**実装要件**:
1. 多次元配列メンバーへの関数戻り値代入
2. ネストした配列のメモリコピー
3. 型チェック（次元とサイズの一致）

**実装ステップ**:
- [ ] インタプリタ: 多次元配列メンバー代入
- [ ] メモリ管理: ネストした配列のコピー
- [ ] テスト: 多次元配列メンバー代入のテスト

---

#### 5. ポインタ配列の高度な操作（検証）

**優先度**: 🟡 **中**  
**理由**: 既存機能の完全性確認

**検証項目**:
```c++
// 1. ループ操作
int[10] arr;
int* ptrs[10];
for (int i = 0; i < 10; i++) {
    ptrs[i] = &arr[i];
}

// 2. 関数引数
void process(int** ptr_array, int size) {
    for (int i = 0; i < size; i++) {
        *ptr_array[i] = i * 10;
    }
}

// 3. 構造体メンバー
struct PointerContainer {
    int* ptrs[10];
};

// 4. 関数戻り値（要検討）
// int*[10] get_pointers();  // 構文？
```

**実装ステップ**:
- [ ] テスト: 包括的なポインタ配列テスト
- [ ] ドキュメント: 動作確認済み機能の記録
- [ ] バグ修正: 発見された問題の修正

---

---

#### 7. const ポインタ

**優先度**: � **中**  
**理由**: 型安全性向上（ポインタシステムの完全性）

```c++
const int* ptr1;       // ポイント先が定数
int* const ptr2;       // ポインタ自体が定数
const int* const ptr3; // 両方が定数
```

**実装要件**:
1. const修飾子の型システム統合
2. 代入時のconst違反チェック
3. エラーメッセージの改善

**実装ステップ**:
- [ ] 型システム: const属性の追加
- [ ] パーサー: const ポインタ構文の解析
- [ ] インタプリタ: const チェック
- [ ] テスト: const ポインタのテスト

---

#### 8. 多重ポインタ

**優先度**: � **中**  
**理由**: 高度なポインタ操作に必要

```c++
int value = 42;
int* ptr = &value;
int** pptr = &ptr;
**pptr = 100;
```

**実装要件**:
1. 多重ポインタ型の表現
2. 多段階デリファレンス
3. 型チェック

**実装ステップ**:
- [ ] 型システム: ポインタ深度の管理
- [ ] パーサー: `int**`, `int***` 構文の解析
- [ ] インタプリタ: 多段階デリファレンス
- [ ] テスト: 多重ポインタのテスト

---

### 🟢 低優先度（将来検討）

### ⛔ スコープ外

#### 6. 配列要素へのポインタ構文糖衣 `ptr[n]`

**理由**: 明示的なポインタ演算で十分機能する

---

## 📅 実装スケジュール

### Phase 1: 必須機能 ✅ **完了**
1. **関数ポインタの実装** - コールバック機能
   - [x] 設計と仕様策定
   - [x] パーサー拡張
   - [x] インタプリタ実装
   - [x] テスト作成（5テストケース）
   - [x] 統合テスト成功（2424/2424）

### Phase 2: 優先度中の機能（実装中）
2. **多次元配列ポインタ**
3. **構造体配列メンバー代入**
4. **多次元配列メンバー代入**
5. **ポインタ配列の検証**

### Phase 3: ドキュメント化（1週間）
- リリースノート作成
- spec.md更新
- サンプルコード追加

---

## 🎯 成功基準

### 必須
- ✅ 関数ポインタが動作する
- ✅ コールバック関数を使ったサンプルが動く
- ✅ すべてのテストがパスする

### 推奨
- ✅ 多次元配列ポインタが動作する
- ✅ 構造体配列メンバー代入が動作する
- ✅ ポインタ配列の高度な操作が確認できる

---

## 📝 次のステップ

1. **関数ポインタの詳細設計**
   - typedef構文の定義
   - AST構造の設計
   - 関数テーブルの設計

2. **プロトタイプ実装**
   - 最小限の関数ポインタ実装
   - 簡単なテストケース

3. **段階的な機能追加**
   - 関数ポインタの引数
   - 関数ポインタの戻り値
   - 関数ポインタの配列

---

**次回更新**: 実装進捗に応じて随時更新
