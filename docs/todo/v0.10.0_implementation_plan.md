# v0.10.0 実装計画

**作成日**: 2025年10月5日  
**最終更新**: 2025年10月9日  
**対象バージョン**: v0.10.0  
**ベースバージョン**: v0.9.2

---

## 📊 実装状況サマリー（2025/10/06時点）

### ✅ 完了した機能
- **関数ポインタ**: 完全実装（5テスト追加、2424/2424成功）
  - 宣言、初期化、呼び出し（2形式）
  - 関数ポインタを返す関数
  - チェーン呼び出し
  - コールバック関数
  - アドレス比較と表示

### 🔄 実装中の機能
- なし（次のフェーズ```

---

#### 4. 無名関数（ラムダ式）

**優先度**: 🔴 **高**  
**理由**: 高階関数のサポート、コールバック関数の簡潔な記述

**基本構文**:
```cb
void main() {
    // パターン1: 関数ポインタへの代入
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    println(add(5, 3));  // 8
    
    // パターン2: 関数引数として
    apply(int func(int x) { return x * 2; }, 10);  // 20
    
    // パターン3: 配列要素として
    int*[3] ops = [
      ## 📚 詳細設計ドキュメント

各機能の詳細な実装計画は以下のドキュメントを参照:

1. **[コンストラクタ/デストラクタ](v0.10.0_constructor_destructor.md)**
   - `this` ポインタの実装
   - スコープ管理とライフサイクル
   - 配列要素の初期化/破棄

2. **[デフォルト引数](v0.10.0_default_arguments.md)**
   - パラメータのデフォルト値
   - 引数補完ロジック
   - 定数式の制約

3. **[デフォルトメンバ](v0.10.0_default_member.md)**
   - `default` 修飾子の仕様
   - 型推論と暗黙的変換
   - 構造体の透過的な使用

4. **[無名関数（ラムダ式）](v0.10.0_lambda_functions.md)**
   - func式の構文
   - 内部識別子の自動生成
   - 高階関数のサポート

5. **[無名変数（_ 識別子）](v0.10.0_discard_variable.md)**
   - 特殊識別子としての扱い
   - エラー検出とvalidation
   - 将来のタプル対応{ return x + 1; },
        int func(int x) { return x * 2; },
        int func(int x) { return x * x; }
    ];
}
```

**実装要件**:
1. `func` キーワードを式として使用可能に
2. 内部識別子の自動生成（`__lambda_1`, `__lambda_2`, ...）
3. 同じスコープ内に複数のfuncが存在可能（重複エラーなし）
4. 関数ポインタへの自動変換
5. 型推論とシグネチャの検証

**実装ステップ**:
- [ ] LambdaExpressionNode の定義
- [ ] 識別子自動生成機構
- [ ] 式としての統合（代入、引数、配列）
- [ ] 型チェックの実装
- [ ] テスト作成

**詳細**: [v0.10.0_lambda_functions.md](v0.10.0_lambda_functions.md)

---

#### 5. 無名変数（_ 識別子）

**優先度**: 🟡 **中**  
**理由**: 将来のタプル実装への布石、意図の明確化

**基本構文**:
```cb
void main() {
    // 戻り値を無視
    int _ = compute();  // 戻り値は無視されるが関数は実行される
    
    // 複数の無名変数（重複エラーなし）
    int _ = 10;      // 内部: __discard_1
    string _ = "a";  // 内部: __discard_2
    
    // ❌ エラー: 参照不可
    // println(_);
    
    // ❌ エラー: 代入不可
    // _ = 20;
}

// 将来的な使用例（タプル実装後）
// (int value, _) = get_data();  // 第2戻り値を無視
```

**実装要件**:
1. `_` を特殊な識別子として認識
2. 内部識別子の自動生成（`__discard_1`, `__discard_2`, ...`)
3. 参照エラーの検出
4. 代入エラーの検出（宣言以外）
5. 副作用のある式のみ実行（最適化）

**実装ステップ**:
- [ ] `_` の特殊識別子としての認識
- [ ] 内部識別子の自動生成
- [ ] エラー検出機構
- [ ] 最適化の実装
- [ ] テスト作成

**詳細**: [v0.10.0_discard_variable.md](v0.10.0_discard_variable.md)

---

### 🟡 優先度中（今回実装）

#### 6. 多次元配列へのポインタ# 📋 未実装の機能（優先順）
1. **コンストラクタ/デストラクタ** - 高優先度（NEW）
2. **デフォルト引数** - 高優先度（NEW）
3. **デフォルトメンバ（default修飾子）** - 高優先度（NEW）
4. **無名関数（ラムダ式）** - 高優先度（NEW）
5. **無名変数（_ 識別子）** - 中優先度（NEW）
6. **多次元配列へのポインタ** - 中優先度
7. **構造体配列メンバーの関数戻り値代入** - 中優先度
8. **多次元配列の関数戻り値からメンバー代入** - 中優先度
9. **ポインタ配列の包括的テスト** - 中優先度
10. **const ポインタ** - 低優先度
11. **多重ポインタ** - 低優先度

---

## 🎯 実装する機能

### ✅ 既に完了
1. ✅ **impl内static変数** - 完全実装済み（26テスト成功）
2. ✅ **nullptr リテラル** - 完全実装済み
3. ✅ **参照型** `int&` - 完全実装済み
4. ✅ **関数ポインタ** - 完全実装済み（2024/10/06完了、5テスト追加）

### 🔥 次期実装機能

#### 13. 関数ポインタ（コールバック用） ✅ **完了**

**優先度**: 🔴 **必須**  
**理由**: コールバック機能が必要  
**状態**: ✅ **実装完了**（2024/10/06）

**実装された機能**:
```cb
// 関数ポインタの宣言と初期化
int add(int a, int b) { return a + b; }
int* op = &add;

// 呼び出し（2つの形式）
int result1 = op(5, 3);      // 暗黙的呼び出し
int result2 = (*op)(5, 3);   // 明示的デリファレンス

// 関数ポインタを返す関数
int* getOperation(int code) {
    if (code == 1) return &add;
    return &subtract;
}

// チェーン呼び出し
int result = getOperation(3)(6, 7);

// コールバック関数
int apply(int* callback, int x, int y) {
    return callback(x, y);
}

// アドレス比較と表示
int* fp1 = &add;
int* fp2 = &add;
if (fp1 == fp2) { }  // 同じ関数
println(op);  // 0x12345678 (16進数)
```

**実装完了項目**:
- [x] 関数ポインタの宣言と初期化
- [x] 2つの呼び出し形式（暗黙的・明示的）
- [x] 関数ポインタを返す関数
- [x] チェーン呼び出し
- [x] コールバック関数
- [x] ポインタのアドレス比較
- [x] アドレス表示（16進数）
- [x] 関数ポインタの再代入
- [x] 包括的なテスト（5テストケース、2424/2424成功）

---

### � 高優先度（次期実装機能）

#### 1. コンストラクタ/デストラクタ

**優先度**: 🔴 **高**  
**理由**: オブジェクト指向機能の基盤、リソース管理の自動化

**基本構文**:
```cb
struct String {
    string value;
};

impl String {
    // コンストラクタ
    String() {
        this.value = "";
    }
    
    String(string s) {
        this.value = s;
    }
    
    // デストラクタ
    ~String() {
        // クリーンアップ処理
    }
}

// 使用例
void main() {
    String s1;              // デフォルトコンストラクタ呼び出し
    String s2("Hello");     // パラメータ付きコンストラクタ
    // スコープ終了時に自動的にデストラクタ呼び出し
}
```

**実装要件**:
1. impl内で構造体名と同名の関数をコンストラクタとして認識
2. impl内で `~構造体名` の関数をデストラクタとして認識
3. オーバーロード対応（複数のコンストラクタ）
4. `this` ポインタの実装（impl内のメソッドで使用可能）
5. スコープ終了時の自動デストラクタ呼び出し
6. 配列の要素ごとのコンストラクタ/デストラクタ呼び出し

**実装ステップ**:
- [ ] 型システム: コンストラクタ/デストラクタのメタデータ管理
- [ ] パーサー: `~構造体名()` 構文の解析
- [ ] パーサー: `this` キーワードの解析
- [ ] インタプリタ: コンストラクタの自動呼び出し
- [ ] インタプリタ: デストラクタの自動呼び出し（スコープ管理）
- [ ] インタプリタ: `this` ポインタの実装
- [ ] テスト: コンストラクタ/デストラクタのテスト

---

#### 2. デフォルト引数

**優先度**: 🔴 **高**  
**理由**: 関数呼び出しの柔軟性向上、API設計の改善

**基本構文**:
```cb
func int add(int a, int b = 10, int c = 20) {
    return a + b + c;
}

void main() {
    println(add(1));        // 1 + 10 + 20 = 31
    println(add(1, 2));     // 1 + 2 + 20 = 23
    println(add(1, 2, 3));  // 1 + 2 + 3 = 6
}
```

**実装要件**:
1. デフォルト引数は右側から連続して指定
2. デフォルト引数のスキップは不可（`add(1, , 3)` は不可）
3. 定数式のみ許可（変数は不可）
4. 関数宣言と定義での整合性チェック

**実装ステップ**:
- [ ] 型システム: パラメータのデフォルト値メタデータ
- [ ] パーサー: `int a = 10` 構文の解析
- [ ] インタプリタ: デフォルト引数の補完
- [ ] 型チェック: デフォルト引数の位置検証
- [ ] テスト: デフォルト引数のテスト

---

#### 3. デフォルトメンバ（default修飾子）

**優先度**: 🔴 **高**  
**理由**: 構造体の利便性向上、型安全なラッパー型の実現

**基本構文**:
```cb
struct String {
    default string value;
};

void main() {
    // 構造体リテラルとして初期化
    String s = {"Hello"};
    
    // デフォルトメンバへの暗黙的アクセス（読み取り）
    println(s);  // "Hello" と出力（s.value として解釈）
    
    // デフォルトメンバへの暗黙的代入（基本型として）
    s = "World";  // s.value = "World" として解釈
    println(s);   // "World"
    
    // 構造体として明示的にアクセス
    s = {"Explicit"};  // 構造体リテラル
    println(s.value);   // "Explicit"
    
    // 明示的なメンバーアクセスも可能
    s.value = "Direct";
    println(s.value);  // "Direct"
}
```

**詳細仕様**:

1. **default修飾子の制約**:
   - 構造体に1つだけ `default` メンバーを設定可能
   - 2つ以上の `default` メンバーがある場合はコンパイルエラー
   ```cb
   struct Invalid {
       default int a;
       default int b;  // エラー: 複数のdefaultメンバー
   };
   ```

2. **型推論による暗黙的アクセス**:
   - **代入**: 基本型の値が代入される場合、デフォルトメンバーに代入
   ```cb
   String s;
   s = "text";      // s.value = "text" として解釈
   s = {"text"};    // 構造体リテラル（明示的）
   ```
   
   - **参照**: 基本型が期待される文脈でデフォルトメンバーを返す
   ```cb
   println(s);         // s.value として解釈
   string str = s;     // str = s.value として解釈
   ```

3. **関数引数での動作**:
   ```cb
   func void print_string(string s) {
       println(s);
   }
   
   String wrapper = {"Hello"};
   print_string(wrapper);  // wrapper.value が渡される
   ```

4. **構造体としての明示的操作**:
   ```cb
   String s1 = {"A"};
   String s2 = s1;      // 構造体全体のコピー
   s2 = {"B"};          // 構造体リテラルによる代入
   ```

**実装要件**:
1. `default` キーワードの追加
2. 構造体に複数の `default` メンバーがないことの検証
3. 型推論による暗黙的変換の実装
4. 構造体リテラル `{}` と基本型の代入の区別
5. 関数引数での自動変換

**実装ステップ**:
- [ ] Lexer: `default` キーワードの追加
- [ ] パーサー: `default` 修飾子の解析
- [ ] 型システム: デフォルトメンバーのメタデータ管理
- [ ] 型チェック: 複数のdefaultメンバーの検出
- [ ] インタプリタ: 暗黙的代入の実装
- [ ] インタプリタ: 暗黙的参照の実装
- [ ] インタプリタ: 構造体リテラルと基本型の区別
- [ ] テスト: デフォルトメンバーのテスト

**エラーケース**:
```cb
// エラー1: 複数のdefaultメンバー
struct Bad {
    default int x;
    default int y;  // コンパイルエラー
};

// エラー2: 型不一致
String s;
s = 123;  // エラー: intをstring型のdefaultメンバーに代入できない

// エラー3: defaultメンバーが無い構造体への暗黙的代入
struct Point {
    int x;
    int y;
};
Point p = 10;  // エラー: defaultメンバーが無い
```

---

### �🟡 優先度中（今回実装）

#### 4. 多次元配列へのポインタ

**優先度**: 🟡 **中**  
**理由**: ポインタシステムの完全性向上

**基本構文**:
```c++
int[3][4] matrix = [[1,2,3,4], [5,6,7,8], [9,10,11,12]];

// 行へのポインタ
int(*row_ptr)[4] = &matrix[0];  // 4要素配列へのポインタ

// ポインタ演算
row_ptr++;  // 次の行へ
int value = (*row_ptr)[2];  // matrix[1][2]と同じ

// 要素へのポインタ
int* elem_ptr = &matrix[1][2];
*elem_ptr = 100;
```

**実装要件**:
1. 配列へのポインタ型: `int(*ptr)[n]`
2. 行ポインタのポインタ演算
3. デリファレンスと配列アクセスの組み合わせ
4. 型チェックの強化

**実装ステップ**:
- [ ] 型システム: 配列ポインタ型の表現
- [ ] パーサー: `int(*ptr)[n]` 構文の解析
- [ ] インタプリタ: 配列ポインタの演算
- [ ] テスト: 多次元配列ポインタのテスト

---

#### 7. 構造体配列メンバーの関数戻り値代入

**優先度**: 🟡 **中**  
**理由**: 利便性向上

**問題**:
```c++
struct Container {
    int[5] data;
};

int[5] create_array() {
    return [1, 2, 3, 4, 5];
}

int main() {
    Container c;
    // ❌ 現在は不可
    c.data = create_array();
    return 0;
}
```

**実装要件**:
1. 構造体メンバー配列への関数戻り値の直接代入
2. メモリコピーの最適化
3. 型チェック（サイズ一致）

**実装ステップ**:
- [ ] インタプリタ: 配列メンバーへの代入処理
- [ ] 型チェック: サイズ一致の検証
- [ ] テスト: 構造体配列メンバー代入のテスト

---

#### 8. 多次元配列の関数戻り値からメンバー代入

**優先度**: 🟡 **中**  
**理由**: 利便性向上（3の拡張）

**問題**:
```c++
struct Matrix {
    int[2][2] data;
};

int[2][2] create_matrix() {
    return [[1, 2], [3, 4]];
}

int main() {
    Matrix m;
    // ❌ 現在は不可
    m.data = create_matrix();
    return 0;
}
```

**実装要件**:
1. 多次元配列メンバーへの関数戻り値代入
2. ネストした配列のメモリコピー
3. 型チェック（次元とサイズの一致）

**実装ステップ**:
- [ ] インタプリタ: 多次元配列メンバー代入
- [ ] メモリ管理: ネストした配列のコピー
- [ ] テスト: 多次元配列メンバー代入のテスト

---

#### 9. ポインタ配列の高度な操作（検証）

**優先度**: 🟡 **中**  
**理由**: 既存機能の完全性確認

**検証項目**:
```c++
// 1. ループ操作
int[10] arr;
int* ptrs[10];
for (int i = 0; i < 10; i++) {
    ptrs[i] = &arr[i];
}

// 2. 関数引数
void process(int** ptr_array, int size) {
    for (int i = 0; i < size; i++) {
        *ptr_array[i] = i * 10;
    }
}

// 3. 構造体メンバー
struct PointerContainer {
    int* ptrs[10];
};

// 4. 関数戻り値（要検討）
// int*[10] get_pointers();  // 構文？
```

**実装ステップ**:
- [ ] テスト: 包括的なポインタ配列テスト
- [ ] ドキュメント: 動作確認済み機能の記録
- [ ] バグ修正: 発見された問題の修正

---

---

#### 10. const ポインタ

**優先度**: � **中**  
**理由**: 型安全性向上（ポインタシステムの完全性）

```c++
const int* ptr1;       // ポイント先が定数
int* const ptr2;       // ポインタ自体が定数
const int* const ptr3; // 両方が定数
```

**実装要件**:
1. const修飾子の型システム統合
2. 代入時のconst違反チェック
3. エラーメッセージの改善

**実装ステップ**:
- [ ] 型システム: const属性の追加
- [ ] パーサー: const ポインタ構文の解析
- [ ] インタプリタ: const チェック
- [ ] テスト: const ポインタのテスト

---

#### 11. 多重ポインタ

**優先度**: � **中**  
**理由**: 高度なポインタ操作に必要

```c++
int value = 42;
int* ptr = &value;
int** pptr = &ptr;
**pptr = 100;
```

**実装要件**:
1. 多重ポインタ型の表現
2. 多段階デリファレンス
3. 型チェック

**実装ステップ**:
- [ ] 型システム: ポインタ深度の管理
- [ ] パーサー: `int**`, `int***` 構文の解析
- [ ] インタプリタ: 多段階デリファレンス
- [ ] テスト: 多重ポインタのテスト

---

### 🟢 低優先度（将来検討）

### ⛔ スコープ外

#### 12. 配列要素へのポインタ構文糖衣 `ptr[n]`

**理由**: 明示的なポインタ演算で十分機能する

---

## 📅 実装スケジュール

### Phase 1: 必須機能 ✅ **完了**
1. **関数ポインタの実装** - コールバック機能
   - [x] 設計と仕様策定
   - [x] パーサー拡張
   - [x] インタプリタ実装
   - [x] テスト作成（5テストケース）
   - [x] 統合テスト成功（2424/2424）

### Phase 2: 高優先度機能（次期実装）
1. **コンストラクタ/デストラクタ**
   - [ ] 設計と仕様策定
   - [ ] `this` ポインタの実装
   - [ ] コンストラクタの自動呼び出し
   - [ ] デストラクタの自動呼び出し（スコープ管理）
   - [ ] テスト作成

2. **デフォルト引数**
   - [ ] 設計と仕様策定
   - [ ] パラメータのデフォルト値メタデータ
   - [ ] デフォルト引数の補完ロジック
   - [ ] テスト作成

3. **デフォルトメンバ（default修飾子）**
   - [ ] 設計と仕様策定
   - [ ] `default` キーワードの追加
   - [ ] 型推論による暗黙的変換
   - [ ] 構造体リテラルとの区別
   - [ ] テスト作成

4. **無名関数（ラムダ式）**
   - [ ] 設計と仕様策定
   - [ ] LambdaExpressionNode の定義
   - [ ] 内部識別子の自動生成
   - [ ] 式としての統合
   - [ ] テスト作成

### Phase 3: 優先度中の機能
5. **無名変数（_ 識別子）**
   - [ ] 設計と仕様策定
   - [ ] 特殊識別子としての認識
   - [ ] エラー検出機構
   - [ ] 最適化の実装
   - [ ] テスト作成

6. **多次元配列ポインタ**
7. **構造体配列メンバー代入**
8. **多次元配列メンバー代入**
9. **ポインタ配列の検証**

### Phase 4: ドキュメント化（1週間）
- リリースノート作成
- spec.md更新
- サンプルコード追加

---

## 🎯 成功基準

### 必須（Phase 1完了）
- ✅ 関数ポインタが動作する
- ✅ コールバック関数を使ったサンプルが動く
- ✅ すべてのテストがパスする

### Phase 2目標
- [ ] コンストラクタ/デストラクタが動作する
- [ ] デフォルト引数が動作する
- [ ] デフォルトメンバ（default修飾子）が動作する
- [ ] 無名関数（ラムダ式）が動作する
- [ ] すべてのテストがパスする

### Phase 3目標
- [ ] 無名変数（_ 識別子）が動作する

### 推奨（Phase 3）
- [ ] 多次元配列ポインタが動作する
- [ ] 構造体配列メンバー代入が動作する
- [ ] ポインタ配列の高度な操作が確認できる

---

## � 詳細設計ドキュメント

各機能の詳細な実装計画は以下のドキュメントを参照:

1. **[コンストラクタ/デストラクタ](v0.10.0_constructor_destructor.md)**
   - `this` ポインタの実装
   - スコープ管理とライフサイクル
   - 配列要素の初期化/破棄

2. **[デフォルト引数](v0.10.0_default_arguments.md)**
   - パラメータのデフォルト値
   - 引数補完ロジック
   - 定数式の制約

3. **[デフォルトメンバ](v0.10.0_default_member.md)**
   - `default` 修飾子の仕様
   - 型推論と暗黙的変換
   - 構造体の透過的な使用

---

## �📝 次のステップ

### 優先順位1: コンストラクタ/デストラクタ
1. **詳細設計**
   - `this` ポインタの実装方式
   - スコープ管理とデストラクタ呼び出しタイミング
   - AST構造の設計
   - 👉 **詳細は [v0.10.0_constructor_destructor.md](v0.10.0_constructor_destructor.md) を参照**

2. **プロトタイプ実装**
   - 最小限のコンストラクタ実装
   - `this` ポインタの基本動作
   - 簡単なテストケース

3. **段階的な機能追加**
   - デフォルトコンストラクタ
   - パラメータ付きコンストラクタ
   - デストラクタとスコープ管理
   - 配列要素のコンストラクタ/デストラクタ

### 優先順位2: デフォルト引数
1. **詳細設計**
   - パラメータメタデータの拡張
   - 関数呼び出し時の引数補完ロジック
   - 👉 **詳細は [v0.10.0_default_arguments.md](v0.10.0_default_arguments.md) を参照**

2. **実装**
   - パーサー拡張
   - インタプリタでの引数補完
   - 型チェック強化

### 優先順位3: デフォルトメンバ
1. **詳細設計**
   - `default` キーワードの文法定義
   - 型推論と暗黙的変換のルール
   - 構造体リテラルとの区別方法
   - 👉 **詳細は [v0.10.0_default_member.md](v0.10.0_default_member.md) を参照**

2. **実装**
   - Lexer/Parser拡張
   - 型システムの拡張
   - 暗黙的変換ロジック

---

**次回更新**: 実装進捗に応じて随時更新
