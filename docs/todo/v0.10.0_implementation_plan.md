# v0.10.0 実装計画

**作成日**: 2025年10月5日  
**最終更新**: 2025年10月11日  
**対象バージョン**: v0.10.0  
**ベースバージョン**: v0.9.2

---

## 📊 実装状況サマリー（2025/10/11時点）

### ✅ 完了した機能
- **関数ポインタ**: 完全実装（5テスト追加、2424/2424成功）
  - 宣言、初期化、呼び出し（2形式）
  - 関数ポインタを返す関数
  - チェーン呼び出し
  - コールバック関数
  - アドレス比較と表示
- **多次元配列へのポインタ**: 完全実装
  - 配列へのポインタ型: `int(*ptr)[n]`
  - 行ポインタのポインタ演算
  - デリファレンスと配列アクセス
- **constポインタ**: 完全実装
  - ポインタの指す先がconst
  - ポインタ自体がconst
  - 両方がconst
- **多重ポインタ**: 完全実装
  - ポインタのポインタ（`int**`など）
  - 多段階のデリファレンス
- **構造体配列メンバーの関数戻り値代入**: 完全実装
- **多次元配列の関数戻り値からメンバー代入**: 完全実装

### 🔄 実装中の機能
- なし（次のフェーズから開始予定）

---

## 📋 未実装の機能（優先順）
1. **コンストラクタ/デストラクタ** - 高優先度（NEW）
2. **デフォルト引数** - 高優先度（NEW）
3. **デフォルトメンバ（default修飾子）** - 高優先度（NEW）
4. **無名関数（ラムダ式）** - 高優先度（NEW）
5. **defer文** - 高優先度（NEW）
6. **switch文** - 高優先度（NEW）
7. **無名変数（_ 識別子）** - 中優先度（NEW）
8. **import/export** - 中優先度（NEW）

---

## 🔥 高優先度機能

### 1. コンストラクタ/デストラクタ

**優先度**: 🔴 **高**  
**理由**: オブジェクト指向機能の基盤、リソース管理の自動化

**詳細**: [v0.10.0_constructor_destructor.md](v0.10.0_constructor_destructor.md) を参照

---

### 2. デフォルト引数

**優先度**: 🔴 **高**  
**理由**: 関数呼び出しの柔軟性向上、API設計の改善

**詳細**: [v0.10.0_default_arguments.md](v0.10.0_default_arguments.md) を参照

---

### 3. デフォルトメンバ（default修飾子）

**優先度**: 🔴 **高**  
**理由**: 構造体の利便性向上、型安全なラッパー型の実現

**詳細**: [v0.10.0_default_member.md](v0.10.0_default_member.md) を参照

---

### 4. 無名関数（ラムダ式）

**優先度**: 🔴 **高**  
**理由**: 高階関数のサポート、コールバック関数の簡潔な記述

**基本構文**:
```cb
void main() {
    // パターン1: 関数ポインタへの代入
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    println(add(5, 3));  // 8
    
    // パターン2: 関数引数として
    apply(int func(int x) { return x * 2; }, 10);  // 20
    
    // パターン3: 配列要素として
    int*[3] ops = [
        int func(int x) { return x + 1; },
        int func(int x) { return x * 2; },
        int func(int x) { return x * x; }
    ];
}
```

**実装要件**:
1. `func` キーワードを式として使用可能に
2. 内部識別子の自動生成（`__lambda_1`, `__lambda_2`, ...）
3. 同じスコープ内に複数のfuncが存在可能（重複エラーなし）
4. 関数ポインタへの自動変換
5. 型推論とシグネチャの検証

**実装ステップ**:
- [ ] LambdaExpressionNode の定義
- [ ] 識別子自動生成機構
- [ ] 式としての統合（代入、引数、配列）
- [ ] 型チェックの実装
- [ ] テスト作成

**詳細**: [v0.10.0_lambda_functions.md](v0.10.0_lambda_functions.md)

---

### 5. defer文（Go言語スタイル）

**優先度**: 🔴 **高**  
**理由**: リソース解放の確実な実行、クリーンアップコードの簡潔化

**基本構文**:
```cb
void process_file(string path) {
    File f = open(path);
    defer close(f);  // 関数終了時に必ず実行
    
    if (error_check()) {
        return;  // ここで戻っても close(f) が実行される
    }
    
    // ファイル処理
    write(f, "data");
}

void multiple_defers() {
    defer println("1");  // 3番目に実行
    defer println("2");  // 2番目に実行
    defer println("3");  // 1番目に実行（最後のdeferが最初）
    println("main");     // 最初に実行
    // 出力: main, 3, 2, 1
}
```

**実装要件**:
1. `defer`キーワードの追加
2. defer スタックの管理（LIFO）
3. スコープ終了時の自動実行
4. return、break、continue との統合
5. エラー発生時でも実行

**実装ステップ**:
- [ ] Lexer: `defer` キーワードの追加
- [ ] パーサー: defer文の解析
- [ ] インタプリタ: deferスタックの管理
- [ ] インタプリタ: スコープ終了時の実行
- [ ] 制御フロー: return/break/continue との統合
- [ ] テスト作成

**詳細**: ※仕様提示待ち

---

### 6. switch文

**優先度**: 🔴 **高**  
**理由**: 多分岐処理の簡潔化、可読性向上

**基本構文**:
```cb
void check_value(int x) {
    switch (x) {
        case (1) {
            println("one");
        } case (2 || 3) {
            println("two or three");
        } case (10...20) {
            println("ten to twenty");
        } else {
            println("other");
        }
    }
}

string get_grade(int score) {
    switch (score) {
        case (90...100) {
            return "A";
        } case (80...89) {
            return "B";
        } case (70...79) {
            return "C";
        } case (60...69) {
            return "D";
        } else {
            return "F";
        }
    }
}

void check_char(string c) {
    switch (c) {
        case ("a" || "e" || "i" || "o" || "u") {
            println("vowel");
        } case ("A"..."Z") {
            println("uppercase consonant");
        } else {
            println("other");
        }
    }
}
```

**主な特徴**:
1. **OR演算子**: `case (2 || 3)` で複数の値をマッチング
2. **範囲演算子**: `case (10...20)` で範囲内の値をマッチング（閉区間）
3. **elseブロック**: `default`の代わりに`else`を使用
4. **自動break**: 各caseは自動的に終了（fallthrough無し）
5. **ブロック必須**: 各caseは`{}`ブロックで囲む必須

**実装要件**:
1. `switch`, `case`, `else` キーワードの追加
2. 式の評価とマッチング
3. OR演算子（`||`）の処理
4. 範囲演算子（`...`）の処理
5. 型チェック（通常型では型一致、ユニオン型では型混在許可）
6. 範囲チェック（int型での数値範囲、string型での辞書順範囲）

**型の扱い**:
```cb
// ✅ OK: 同じ型
case (1 || 2 || 3) { }

// ✅ OK: 複数の範囲
case (10...20 || 30...40) { }

// ✅ OK: ユニオン型では型混在も可能
union Value {
    int num;
    string str;
    float flt;
};
Value v = /* ... */;
switch (v) {
    case (1 || "text" || 3.14) {
        println("matched");
    }
}

// ❌ エラー: 通常の型で型混在
int x = 5;
switch (x) {
    case (1 || "two") { }  // エラー: intとstringの混在
}

// ❌ エラー: 範囲の逆順
case (20...10) { }

// ❌ エラー: 範囲内の型不一致
case (1..."z") { }  // intとstringの範囲は不可
```

**実装ステップ**:
- [ ] Lexer: `switch`, `case`, `else` キーワードの追加
- [ ] パーサー: switch文の解析
- [ ] パーサー: case内のOR演算子（`||`）の解析
- [ ] パーサー: case内の範囲演算子（`...`）の解析
- [ ] AST: SwitchNode, CaseNode, RangeNode の定義
- [ ] インタプリタ: マッチング処理
- [ ] インタプリタ: OR条件の評価
- [ ] インタプリタ: 範囲条件の評価
- [ ] 型チェック: 通常型での型一致検証
- [ ] 型チェック: ユニオン型での型混在許可
- [ ] テスト作成

**詳細**: ※実装ドキュメント作成予定

---

## 🟡 中優先度機能

### 7. 無名変数（_ 識別子）

**優先度**: 🟡 **中**  
**理由**: 将来のタプル実装への布石、意図の明確化

**基本構文**:
```cb
void main() {
    // 戻り値を無視
    int _ = compute();  // 戻り値は無視されるが関数は実行される
    
    // 複数の無名変数（重複エラーなし）
    int _ = 10;      // 内部: __discard_1
    string _ = "a";  // 内部: __discard_2
    
    // ❌ エラー: 参照不可
    // println(_);
    
    // ❌ エラー: 代入不可
    // _ = 20;
}

// 将来的な使用例（タプル実装後）
// (int value, _) = get_data();  // 第2戻り値を無視
```

**実装要件**:
1. `_` を特殊な識別子として認識
2. 内部識別子の自動生成（`__discard_1`, `__discard_2`, ...`)
3. 参照エラーの検出
4. 代入エラーの検出（宣言以外）
5. 副作用のある式のみ実行（最適化）

**実装ステップ**:
- [ ] `_` の特殊識別子としての認識
- [ ] 内部識別子の自動生成
- [ ] エラー検出機構
- [ ] 最適化の実装
- [ ] テスト作成

**詳細**: [v0.10.0_discard_variable.md](v0.10.0_discard_variable.md)

---

### 8. import/export（モジュールシステム）

**優先度**: 🟡 **中**  
**理由**: モジュール化による保守性向上、大規模プロジェクトへの対応

**基本構文**:

**exportの3つの形式**:
```cb
// stdlib/math/basic.cb

// 1. default export（ファイルに1つのみ）
default export int add(int a, int b) {
    return a + b;
}

// 2. 個別export（複数可能）
export int multiply(int a, int b) {
    return a * b;
}

export const int PI = 3.14159;

export struct Point {
    int x;
    int y;
};

export interface Drawable {
    void draw();
};

// 3. まとめてexport
int subtract(int a, int b) { return a - b; }
float divide(float a, float b) { return a / b; }

export {
    subtract,
    divide
};

// exportできないもの（自動的に含まれる）
impl Point {
    Point(int px, int py) { /* ... */ }
    ~Point() { }
};
```

**importの形式（TypeScript風）**:
```cb
// main.cb

// 1. 個別インポート（ドット記法）
import stdlib.math.basic.multiply;
import stdlib.math.basic.PI;

// 2. default exportの読み込み（ファイル単位）
import stdlib.math.basic;

// 3. まとめてimport
import stdlib.math.basic {
    multiply,
    subtract,
    Point
};

// 4. as を使った名前空間エイリアス
import stdlib.math.basic as math;
math.multiply(5, 3);
math.PI;

// 5. 個別の名前変更
import stdlib.math.basic {
    multiply as mul,
    subtract as sub
};
mul(5, 3);

void main() {
    int sum = basic(5, 3);        // default export
    int product = multiply(5, 3);  // 個別import
    Point p;                       // まとめてimport
}
```

**名前空間（namespace）**:
```cb
// stdlib/io.cb
namespace std {
    void print(string msg) {
        println(msg);
    }
    
    struct Console {
        int level;
    };
}

export namespace std;  // namespace全体をexport

// main.cb
import stdlib.io;

void main() {
    std::print("Hello");  // C++スタイルの::演算子
    std::Console console;
}
```

**モジュール検索パス**:
```
プロジェクト構造:
project/
  ├── main.cb
  ├── modules/
  │   └── utils/
  │       └── helper.cb
  └── cb_config.json (将来)

検索順序:
1. プロジェクトルート: ./
2. modulesディレクトリ: ./modules/
3. cb_config.jsonで指定されたパス（将来拡張）

使用例:
import modules.utils.helper;  // OK
import utils.helper;          // OK: modules/を省略可能
```

**`as`キーワードの2つの用途**:

```cb
// 1. import文での名前変更（モジュールシステム）
import stdlib.math.basic as math;
import stdlib.io { print as output };

math.add(1, 2);
output("Hello");

// 2. 型キャスト（Rust風）
int x = 10;
float y = x as float;  // intからfloatへキャスト

void* ptr = get_memory();
int* int_ptr = ptr as int*;  // void*からint*へキャスト

// パーサーでの文脈判定
// - import文の中: 名前変更
// - 式の中: 型キャスト
```

**型キャストの詳細**:
```cb
// 基本型のキャスト
int a = 10;
float b = a as float;        // 10.0
double c = a as double;      // 10.0
string s = a as string;      // "10"

// ポインタのキャスト
void* generic_ptr = malloc(100);
int* int_ptr = generic_ptr as int*;
char* char_ptr = generic_ptr as char*;

// 数値の範囲変換
int large = 1000;
byte small = large as byte;  // オーバーフロー注意

// 構造体のキャスト（メンバの型・サイズ・順序が完全一致する場合のみ）
struct Point2D {
    int x;
    int y;
}

struct Vector2D {
    int x;
    int y;
}

Point2D p = {10, 20};
Vector2D v = p as Vector2D;  // OK: メンバの型・サイズ・順序が完全一致

// typedefされた型も同様
typedef struct {
    float x;
    float y;
} Position;

typedef struct {
    float x;
    float y;
} Velocity;

Position pos = {1.0, 2.0};
Velocity vel = pos as Velocity;  // OK: メンバ構造が同一

// リテラル構造体型もキャスト可能
struct RGB { int r; int g; int b; }
RGB color = {255, 0, 0};
struct { int r; int g; int b; } anon = color as struct { int r; int g; int b; };

// ユニオン型でも同様のルール（サイズとアライメントが一致すれば可能）
union IntFloat {
    int i;
    float f;
}

union NumberValue {
    int i;
    float f;
}

IntFloat if1 = {.i = 42};
NumberValue nv = if1 as NumberValue;  // OK: ユニオンの構造が同一

// エラーケース
struct Point3D { int x; int y; int z; }
Point3D p3 = p as Point3D;  // エラー: メンバ数が異なる

struct FloatPoint { float x; float y; }
FloatPoint fp = p as FloatPoint;  // エラー: メンバの型が異なる（int != float）

struct SwappedPoint { int y; int x; }
SwappedPoint sp = p as SwappedPoint;  // エラー: メンバの順序が異なる

// 安全性チェック（実行時）
// キャスト不可能な場合はエラー
string text = "abc";
// int num = text as int;  // エラー: 文字列から数値へのキャストは不可

// 構造体キャストの検証（コンパイル時）
// - メンバ数が一致すること
// - 各メンバの型が完全に一致すること
// - メンバの順序が一致すること
// - padding/アライメントを考慮した実際のサイズが一致すること
```

**型キャストの設計方針**:

**1. 基本方針**:
- Rust風の明示的キャスト構文（`value as type`）
- 暗黙的キャストは行わず、常に明示的に記述
- コンパイル時に型安全性をチェック
- 実行時のオーバーヘッドを最小限に

**2. キャスト可能な変換**:

| 変換元 → 変換先 | 許可 | 条件 |
|----------------|------|------|
| 数値型 → 数値型 | ✅ | 範囲外の場合は警告 |
| 数値型 → string | ✅ | 文字列表現に変換 |
| ポインタ → ポインタ | ✅ | void*からの変換は常に許可 |
| 構造体 → 構造体 | ✅ | メンバ構造が完全一致 |
| typedef構造体 → typedef構造体 | ✅ | メンバ構造が完全一致 |
| ユニオン → ユニオン | ✅ | サイズとアライメントが一致 |
| string → 数値型 | ❌ | パースエラーの可能性（将来検討） |
| 関数ポインタ → 関数ポインタ | ❌ | 型安全性のため禁止 |
| 配列 → ポインタ | ✅ | 自動的に先頭要素のポインタに |

**3. 構造体キャストの詳細ルール**:
```
許可条件（すべて満たす必要がある）:
1. メンバ数が完全に一致
2. 各メンバの型が完全に一致（型名は異なっても良い）
3. メンバの宣言順序が一致
4. 構造体全体のサイズが一致（padding含む）
5. 各メンバのオフセット位置が一致

検証方法:
- コンパイル時に構造体のメモリレイアウトを比較
- sizeof()とoffsetof()相当の情報で検証
- メンバ名は無視（位置と型のみで判定）
```

**4. エラー処理**:
```cb
// コンパイルエラー
struct Point2D { int x; int y; }
struct Point3D { int x; int y; int z; }
Point2D p = {1, 2};
Point3D p3 = p as Point3D;  // エラー: メンバ数不一致

// コンパイルエラー
struct IntPoint { int x; int y; }
struct FloatPoint { float x; float y; }
IntPoint ip = {1, 2};
FloatPoint fp = ip as FloatPoint;  // エラー: メンバ型不一致

// 警告（実行時エラーの可能性）
int large = 100000;
byte small = large as byte;  // 警告: オーバーフローの可能性
```

**5. パフォーマンス考慮事項**:
- 構造体キャストはメモリコピーとして実装
- サイズが同じ場合はmemcpy相当の処理
- 最適化時に不要なコピーは削除可能
- ポインタキャストは実行時オーバーヘッドなし（型情報のみ変更）

**6. 将来の拡張可能性**:
- ユーザー定義の型変換（`impl as TypeName`）
- トレイト/インターフェースベースのキャスト
- スマートキャスト（nullable型の自動絞り込み）

**exportできる要素**:
- ✅ 関数
- ✅ 構造体（struct）
- ✅ インターフェース（interface）
- ✅ 型エイリアス（typedef）
- ✅ 定数（const）
- ✅ グローバル変数
- ✅ namespace（名前空間全体）
- ❌ impl ブロック（自動的に含まれる）
- ❌ コンストラクタ/デストラクタ（自動的に含まれる）

**依存関係の自動解決**:
```cb
// math.cb
export int complexCalc(int x) {
    return helper1(x) + helper2(x);
}

int helper1(int x) { return x * 2; }      // 自動登録
int helper2(int x) { return x + 10; }     // 自動登録
int unused() { return 999; }              // 登録されない

// main.cb
import math.complexCalc;
// → helper1, helper2は自動的にASTに登録
// → unusedは登録されない（最適化）
```

**実装要件**:
1. `export`, `import`, `default`, `namespace`, `as` キーワードの追加
2. ドット記法によるモジュールパス解析
3. `::` 演算子（C++スタイルの名前空間アクセス）
4. default exportの制約（1ファイル1つ）
5. `as` による名前空間エイリアス（import文内）
6. `as` による型キャスト（Rust風、式内）
7. パーサーでの`as`の文脈判定（import vs キャスト）
8. 構造体間のキャスト検証（メンバの型・サイズ・順序の完全一致チェック）
9. typedefされた構造体やユニオンのキャスト対応
10. リテラル構造体型のキャスト対応
11. モジュール検索パス（プロジェクトルート、modules/）
12. 依存関係の自動解析（再帰的に使用される要素を追跡）
13. 選択的AST登録（使用される要素のみ）
14. 循環依存の検出
15. cb_config.jsonによる検索パス拡張（将来）

**実装の最適化戦略**:
1. **依存関係グラフ構築**: exportされた要素から使用される関数・定数を再帰的に解析
2. **到達可能性解析**: エントリーポイントから到達可能な要素のみを抽出
3. **選択的登録**: 到達可能な要素のみをASTに登録（未使用コード除外）
4. **循環依存検出**: DFSによる循環参照の検出

**実装ステップ**:
- [ ] Lexer: `export`, `import`, `default`, `namespace`, `as` キーワードの追加
- [ ] Lexer: `::` 演算子の追加
- [ ] パーサー: ドット記法の解析
- [ ] パーサー: namespace宣言の解析
- [ ] パーサー: `::` 演算子の解析
- [ ] パーサー: default export文の解析
- [ ] パーサー: 個別export文の解析
- [ ] パーサー: まとめてexport文の解析
- [ ] パーサー: namespace exportの解析
- [ ] パーサー: 個別import文の解析
- [ ] パーサー: まとめてimport文の解析
- [ ] パーサー: `as` による名前変更の解析
- [ ] モジュールシステム: 検索パス管理（プロジェクトルート、modules/）
- [ ] モジュールシステム: ファイルパス解決
- [ ] モジュールシステム: namespace管理
- [ ] モジュールシステム: 依存関係グラフ構築
- [ ] モジュールシステム: 到達可能性解析
- [ ] モジュールシステム: 選択的AST登録
- [ ] モジュールシステム: 循環依存検出
- [ ] 型チェック: default exportの重複検出
- [ ] 型チェック: 公開/非公開の検証
- [ ] 型チェック: namespace内の名前衝突検出
- [ ] 将来: cb_config.jsonからの検索パス読み込み
- [ ] テスト作成

**詳細**: ※実装ドキュメント作成予定

---

##  フェーズ計画

### Phase 1: 必須機能 ✅ **完了**
1. **関数ポインタの実装** - コールバック機能
   - [x] 設計と仕様策定
   - [x] パーサー拡張
   - [x] インタプリタ実装
   - [x] テスト作成（5テストケース）
   - [x] 統合テスト成功（2424/2424）

### Phase 2: 高優先度機能（次期実装）
1. **コンストラクタ/デストラクタ**
   - [ ] 設計と仕様策定
   - [x] `self` ポインタの実装（既に実装済み）
   - [ ] コンストラクタの自動呼び出し
   - [ ] デストラクタの自動呼び出し（スコープ管理）
   - [ ] 配列要素のコンストラクタ/デストラクタ
   - [ ] テスト作成

2. **デフォルト引数**
   - [ ] 設計と仕様策定
   - [ ] パラメータのデフォルト値メタデータ
   - [ ] デフォルト引数の補完ロジック
   - [ ] 型チェック強化
   - [ ] テスト作成

3. **デフォルトメンバ（default修飾子）**
   - [ ] 設計と仕様策定
   - [ ] `default` キーワードの追加
   - [ ] 型推論による暗黙的変換
   - [ ] 構造体リテラルとの区別
   - [ ] 関数引数での自動変換
   - [ ] テスト作成

4. **無名関数（ラムダ式）**
   - [ ] 設計と仕様策定
   - [ ] LambdaExpressionNode の定義
   - [ ] 内部識別子の自動生成
   - [ ] 式としての統合
   - [ ] 型推論とシグネチャ検証
   - [ ] テスト作成

5. **defer文**
   - [ ] 設計と仕様策定
   - [ ] `defer` キーワードの追加
   - [ ] deferスタックの管理（LIFO）
   - [ ] スコープ終了時の自動実行
   - [ ] return/break/continue との統合
   - [ ] テスト作成

6. **switch文**
   - [ ] 設計と仕様策定
   - [ ] `switch`, `case`, `default` キーワードの追加
   - [ ] 式の評価とマッチング
   - [ ] fallthrough の実装
   - [ ] break による脱出
   - [ ] 型チェック
   - [ ] テスト作成

### Phase 3: 優先度中の機能
7. **無名変数（_ 識別子）**
   - [ ] 設計と仕様策定
   - [ ] 特殊識別子としての認識
   - [ ] エラー検出機構
   - [ ] 最適化の実装
   - [ ] テスト作成

8. **import/export（モジュールシステム）**
   - [ ] 設計と仕様策定
   - [ ] `export`, `import` キーワードの追加
   - [ ] 名前空間管理
   - [ ] 依存関係解決
   - [ ] 循環依存検出
   - [ ] テスト作成

### Phase 4: ドキュメント化（1週間）
- リリースノート作成
- spec.md更新
- サンプルコード追加

---

## 🎯 成功基準

### 必須（Phase 1完了）
- ✅ 関数ポインタが動作する
- ✅ コールバック関数を使ったサンプルが動く
- ✅ すべてのテストがパスする

### Phase 2目標（高優先度機能）
- [ ] コンストラクタ/デストラクタが動作する
- [ ] デフォルト引数が動作する
- [ ] デフォルトメンバ（default修飾子）が動作する
- [ ] 無名関数（ラムダ式）が動作する
- [ ] defer文が動作する
- [ ] switch文が動作する
- [ ] すべてのテストがパスする

### Phase 3目標（中優先度機能）
- [ ] 無名変数（_ 識別子）が動作する
- [ ] import/exportが動作する

---

## 📚 詳細設計ドキュメント

各機能の詳細な実装計画は以下のドキュメントを参照:

### 高優先度機能

1. **[コンストラクタ/デストラクタ](v0.10.0_constructor_destructor.md)**
   - `self` ポインタの実装（既に実装済み）
   - スコープ管理とライフサイクル
   - 配列要素の初期化/破棄

2. **[デフォルト引数](v0.10.0_default_arguments.md)**
   - パラメータのデフォルト値
   - 引数補完ロジック
   - 定数式の制約

3. **[デフォルトメンバ](v0.10.0_default_member.md)**
   - `default` 修飾子の仕様
   - 型推論と暗黙的変換
   - 構造体の透過的な使用

4. **[無名関数（ラムダ式）](v0.10.0_lambda_functions.md)**
   - 式としてのfuncキーワード
   - 内部識別子の自動生成
   - 高階関数のサポート

5. **defer文**
   - deferスタックの管理（LIFO）
   - スコープ終了時の確実な実行
   - 制御フローとの統合
   - ※仕様提示待ち

6. **switch文**
   - 式の評価とマッチング
   - fallthroughの動作
   - 型チェック
   - ※仕様提示待ち

### 中優先度機能

7. **[無名変数（_ 識別子）](v0.10.0_discard_variable.md)**
   - 特殊識別子としての認識
   - エラー検出機構
   - 最適化

8. **import/export（モジュールシステム）**
   - 名前空間管理
   - 依存関係解決
   - 循環依存検出
   - ※仕様提示待ち

---

## �📝 次のステップ

### 優先順位1: コンストラクタ/デストラクタ
1. **詳細設計**
   - スコープ管理とデストラクタ呼び出しタイミング
   - AST構造の設計
   - `self` ポインタの活用（既に実装済み）
   - 👉 **詳細は [v0.10.0_constructor_destructor.md](v0.10.0_constructor_destructor.md) を参照**

2. **プロトタイプ実装**
   - 最小限のコンストラクタ実装
   - `self` ポインタの活用
   - 簡単なテストケース

3. **段階的な機能追加**
   - デフォルトコンストラクタ
   - パラメータ付きコンストラクタ
   - デストラクタとスコープ管理
   - 配列要素のコンストラクタ/デストラクタ

### 優先順位2: デフォルト引数
1. **詳細設計**
   - パラメータメタデータの拡張
   - 関数呼び出し時の引数補完ロジック
   - 👉 **詳細は [v0.10.0_default_arguments.md](v0.10.0_default_arguments.md) を参照**

2. **実装**
   - パーサー拡張
   - インタプリタでの引数補完
   - 型チェック強化

### 優先順位3: デフォルトメンバ
1. **詳細設計**
   - `default` キーワードの文法定義
   - 型推論と暗黙的変換のルール
   - 構造体リテラルとの区別方法
   - 👉 **詳細は [v0.10.0_default_member.md](v0.10.0_default_member.md) を参照**

2. **実装**
   - Lexer/Parser拡張
   - 型システムの拡張
   - 暗黙的変換ロジック

---

**次回更新**: 実装進捗に応じて随時更新
