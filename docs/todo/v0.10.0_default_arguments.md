# デフォルト引数実装計画

**作成日**: 2025年10月9日  
**対象バージョン**: v0.10.0  
**優先度**: 🔴 高

---

## 📋 概要

関数パラメータにデフォルト値を設定し、呼び出し時に引数を省略可能にする機能を実装する。

---

## 🎯 目的

1. **関数呼び出しの柔軟性向上**: 頻繁に使う値をデフォルトとして設定
2. **API設計の改善**: 後方互換性を保ちながら機能拡張が可能
3. **コードの簡潔化**: 同じ値を繰り返し指定する必要がなくなる

---

## 📝 基本仕様

### 構文

```cb
func int add(int a, int b = 10, int c = 20) {
    return a + b + c;
}

void main() {
    println(add(1));        // 1 + 10 + 20 = 31
    println(add(1, 2));     // 1 + 2 + 20 = 23
    println(add(1, 2, 3));  // 1 + 2 + 3 = 6
}
```

### 制約

1. **右側から連続**: デフォルト引数は右側から連続して指定する必要がある
   ```cb
   // ✅ 正しい
   func void f1(int a, int b = 1, int c = 2);
   
   // ❌ エラー: デフォルト引数の後に非デフォルト引数
   func void f2(int a = 1, int b, int c = 2);
   
   // ❌ エラー: デフォルト引数が連続していない
   func void f3(int a = 1, int b, int c);
   ```

2. **定数式のみ**: デフォルト値は定数式（リテラル、定数変数）のみ
   ```cb
   const int DEFAULT_SIZE = 10;
   
   // ✅ 正しい
   func void f1(int size = 10);
   func void f2(int size = DEFAULT_SIZE);
   func void f3(string name = "default");
   
   // ❌ エラー: 変数を使用
   int x = 10;
   func void f4(int size = x);
   
   // ❌ エラー: 関数呼び出し
   func void f5(int size = get_size());
   ```

3. **スキップ不可**: 中間の引数をスキップできない
   ```cb
   func void draw(int x = 0, int y = 0, int color = 255);
   
   // ✅ 正しい
   draw();
   draw(10);
   draw(10, 20);
   draw(10, 20, 128);
   
   // ❌ エラー: 引数のスキップ
   draw(10, , 128);  // y をスキップできない
   ```

4. **型一致**: デフォルト値の型はパラメータの型と一致する必要がある
   ```cb
   // ✅ 正しい
   func void f1(int x = 10);
   func void f2(string s = "hello");
   
   // ❌ エラー: 型不一致
   func void f3(int x = "hello");
   func void f4(string s = 123);
   ```

---

## 🔧 実装要件

### 1. 構文拡張

**Parser**:
- パラメータ宣言で `= 式` を解析
- デフォルト値の位置検証（右側から連続）

**AST拡張**:
```cpp
struct Parameter {
    std::string name;
    TypeInfo type;
    std::unique_ptr<ExpressionNode> default_value;  // NEW: デフォルト値
    bool has_default;  // NEW: デフォルト値があるか
};

struct FunctionDef {
    std::string name;
    std::vector<Parameter> parameters;
    int first_default_param_index;  // NEW: 最初のデフォルト引数のインデックス
    // ...
};
```

### 2. 関数定義の検証

**検証項目**:
1. デフォルト引数が右側から連続しているか
2. デフォルト値が定数式か
3. デフォルト値の型がパラメータ型と一致するか

**実装例**:
```cpp
void TypeChecker::validate_function_definition(FunctionDef* func) {
    bool found_default = false;
    
    for (size_t i = 0; i < func->parameters.size(); i++) {
        auto& param = func->parameters[i];
        
        if (param.has_default) {
            found_default = true;
            
            // デフォルト値の型チェック
            auto default_type = infer_type(param.default_value.get());
            if (default_type != param.type) {
                throw std::runtime_error(
                    "Default value type mismatch for parameter: " + param.name
                );
            }
            
            // デフォルト値が定数式か確認
            if (!is_constant_expression(param.default_value.get())) {
                throw std::runtime_error(
                    "Default value must be a constant expression"
                );
            }
        } else if (found_default) {
            // デフォルト引数の後に非デフォルト引数
            throw std::runtime_error(
                "Non-default parameter after default parameter: " + param.name
            );
        }
    }
}
```

### 3. 関数呼び出しの引数補完

**補完ロジック**:
```cpp
void Interpreter::call_function(FunctionCallNode* call) {
    FunctionDef* func = find_function(call->function_name);
    
    // 引数数の検証
    size_t provided_args = call->arguments.size();
    size_t required_args = func->first_default_param_index;
    size_t total_params = func->parameters.size();
    
    if (provided_args < required_args || provided_args > total_params) {
        throw std::runtime_error("Invalid number of arguments");
    }
    
    // 引数リストを構築（デフォルト値で補完）
    std::vector<int64_t> actual_args;
    
    for (size_t i = 0; i < total_params; i++) {
        if (i < provided_args) {
            // 提供された引数を評価
            actual_args.push_back(evaluate(call->arguments[i].get()));
        } else {
            // デフォルト値を評価
            actual_args.push_back(evaluate(func->parameters[i].default_value.get()));
        }
    }
    
    // 関数を実行
    execute_function(func, actual_args);
}
```

### 4. 型チェック

**定数式の判定**:
```cpp
bool is_constant_expression(ExpressionNode* expr) {
    switch (expr->type) {
    case NodeType::INTEGER_LITERAL:
    case NodeType::FLOAT_LITERAL:
    case NodeType::STRING_LITERAL:
    case NodeType::BOOLEAN_LITERAL:
    case NodeType::NULLPTR_LITERAL:
        return true;
    
    case NodeType::IDENTIFIER:
        // const変数の参照は許可
        Variable* var = find_variable(expr->name);
        return var && var->is_const;
    
    case NodeType::BINARY_EXPRESSION:
        // 両辺が定数式なら定数式
        return is_constant_expression(expr->left.get()) &&
               is_constant_expression(expr->right.get());
    
    default:
        return false;
    }
}
```

---

## 📊 実装ステップ

### Phase 1: 構文解析（1週間）
- [ ] Parser拡張: `= 式` の解析
- [ ] AST構造の拡張
- [ ] デフォルト値の位置検証

### Phase 2: 型チェック（1週間）
- [ ] 定数式の判定ロジック
- [ ] デフォルト値の型チェック
- [ ] エラーメッセージの実装

### Phase 3: 実行時処理（1週間）
- [ ] 引数補完ロジック
- [ ] 関数呼び出しの修正
- [ ] デフォルト値の評価

### Phase 4: テストと検証（1週間）
- [ ] 基本的なデフォルト引数テスト
- [ ] エラーケーステスト
- [ ] 統合テスト

---

## 🧪 テストケース

### 1. 基本的なデフォルト引数
```cb
func int add(int a, int b = 10, int c = 20) {
    return a + b + c;
}

void main() {
    assert(add(1) == 31);
    assert(add(1, 2) == 23);
    assert(add(1, 2, 3) == 6);
}
```

### 2. 様々な型のデフォルト値
```cb
func void test(
    int n = 42,
    float f = 3.14,
    string s = "hello",
    bool b = true
) {
    println(n);
    println(f);
    println(s);
    println(b);
}

void main() {
    test();              // すべてデフォルト
    test(100);           // n のみ指定
    test(100, 2.71);     // n, f を指定
}
```

### 3. const定数をデフォルト値に使用
```cb
const int DEFAULT_WIDTH = 800;
const int DEFAULT_HEIGHT = 600;

func void create_window(int w = DEFAULT_WIDTH, int h = DEFAULT_HEIGHT) {
    println("Window size: " + w + "x" + h);
}

void main() {
    create_window();           // 800x600
    create_window(1024);       // 1024x600
    create_window(1024, 768);  // 1024x768
}
```

### 4. 構造体とデフォルト引数
```cb
struct Point {
    int x;
    int y;
};

impl Point {
    Point(int px = 0, int py = 0) {
        this.x = px;
        this.y = py;
    }
}

void main() {
    Point p1;              // コンストラクタのデフォルト引数使用
    Point p2(10);          // px=10, py=0
    Point p3(10, 20);      // px=10, py=20
    
    assert(p1.x == 0 && p1.y == 0);
    assert(p2.x == 10 && p2.y == 0);
    assert(p3.x == 10 && p3.y == 20);
}
```

### 5. エラーケース
```cb
// エラー: デフォルト引数の後に非デフォルト引数
func void error1(int a = 1, int b);  // コンパイルエラー

// エラー: 変数をデフォルト値に使用
int x = 10;
func void error2(int n = x);  // コンパイルエラー

// エラー: 型不一致
func void error3(int n = "hello");  // コンパイルエラー

// エラー: 引数数不足
func int add(int a, int b = 10) { return a + b; }
void main() {
    add();  // エラー: 必須引数 a が不足
}
```

---

## 🔗 関連機能

### コンストラクタとの統合

デフォルト引数はコンストラクタでも使用可能:

```cb
struct Rectangle {
    int width;
    int height;
};

impl Rectangle {
    Rectangle(int w = 100, int h = 100) {
        this.width = w;
        this.height = h;
    }
}

void main() {
    Rectangle r1;           // 100x100
    Rectangle r2(200);      // 200x100
    Rectangle r3(200, 150); // 200x150
}
```

---

## ⚠️ 注意事項

1. **パフォーマンス**: デフォルト値は毎回評価される（定数でも）
2. **オーバーロード**: オーバーロードと組み合わせた場合の曖昧性
3. **関数ポインタ**: 関数ポインタ型にデフォルト引数情報を含めるか

---

## 🔄 将来の拡張

1. **名前付き引数**: `draw(x: 10, color: 255)` のように指定
2. **可変長引数との組み合わせ**: `func void log(string msg, ...args)`
3. **デフォルト値の式**: より複雑な式を許可

---

**更新履歴**:
- 2025/10/09: 初版作成
