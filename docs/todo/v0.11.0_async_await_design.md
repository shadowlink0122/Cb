# Cbè¨€èª v0.11.0 éåŒæœŸå‡¦ç†è¨­è¨ˆæ›¸

**ä½œæˆæ—¥**: 2025å¹´10æœˆ26æ—¥  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.11.0  
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: è¨­è¨ˆä¸­

---

## ğŸ“‹ ç›®æ¬¡

1. [è¨­è¨ˆæ–¹é‡ã¨å‘½å](#è¨­è¨ˆæ–¹é‡ã¨å‘½å)
2. [Cbã«ãŠã‘ã‚‹ç¾çŠ¶åˆ†æ](#cbã«ãŠã‘ã‚‹ç¾çŠ¶åˆ†æ)
3. [ææ¡ˆã™ã‚‹å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ](#ææ¡ˆã™ã‚‹å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ)
4. [æ§‹æ–‡ã¨ä»•æ§˜](#æ§‹æ–‡ã¨ä»•æ§˜)
5. [å®Ÿè£…è¦ä»¶](#å®Ÿè£…è¦ä»¶)
6. [æ®µéšçš„å®Ÿè£…è¨ˆç”»](#æ®µéšçš„å®Ÿè£…è¨ˆç”»)

---

## ğŸ¯ è¨­è¨ˆæ–¹é‡ã¨å‘½å

### å‘½åã®é¸æŠè‚¢æ¯”è¼ƒ

| ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ | é•·æ‰€ | çŸ­æ‰€ | è¨€èªã¨ã®æ•´åˆæ€§ |
|----------|------|------|--------------|
| **Coroutine** | ãƒ»C++20ã®coroutineã¨ä¸€è²«æ€§<br>ãƒ»ä½ãƒ¬ãƒ™ãƒ«ã§æŸ”è»Ÿæ€§ãŒé«˜ã„<br>ãƒ»ã€ŒCã£ã½ã„ã€å°è±¡ | ãƒ»ä½¿ã„å‹æ‰‹ãŒè¤‡é›‘<br>ãƒ»å­¦ç¿’ã‚³ã‚¹ãƒˆãŒé«˜ã„<br>ãƒ»ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆãŒå¤šã„ | C++ã¨ã®è¦ªå’Œæ€§: â­â­â­â­â­ |
| **async/await** | ãƒ»ç›´æ„Ÿçš„ã§ä½¿ã„ã‚„ã™ã„<br>ãƒ»TypeScript/Rusté¢¨<br>ãƒ»ãƒ¢ãƒ€ãƒ³ãªå°è±¡ | ãƒ»Cè¨€èªã¨ã®ä¹–é›¢<br>ãƒ»äºˆç´„èªãŒ2ã¤å¢—ãˆã‚‹ | TypeScript/Rustã¨ã®è¦ªå’Œæ€§: â­â­â­â­â­ |
| **ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰** | ãƒ»ä¸¡æ–¹ã®ãƒ¡ãƒªãƒƒãƒˆ<br>ãƒ»æ®µéšçš„ãªå®Ÿè£…ãŒå¯èƒ½ | ãƒ»æ¦‚å¿µã®æ··åœ¨<br>ãƒ»ä»•æ§˜ãŒè¤‡é›‘åŒ– | ãƒãƒ©ãƒ³ã‚¹: â­â­â­ |

### ğŸ–ï¸ æ¨å¥¨: **async/await + å†…éƒ¨ã§coroutineå®Ÿè£…**

**ç†ç”±**:
1. **ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å„ªå…ˆ**: Cbè¨€èªã¯ã€Œå®Ÿç”¨æ€§é‡è¦–ã€ã®è¨­è¨ˆæ€æƒ³
2. **æ—¢å­˜è¨€èªã¨ã®æ•´åˆæ€§**: TypeScriptã‚„Rustã®çŸ¥è­˜ãŒæ´»ã‹ã›ã‚‹
3. **å­¦ç¿’ã‚³ã‚¹ãƒˆã®ä½æ¸›**: ç›´æ„Ÿçš„ãªæ§‹æ–‡ã§éåŒæœŸå‡¦ç†ã‚’è¨˜è¿°
4. **æ®µéšçš„å®Ÿè£…**: Phase 1ã§åŸºæœ¬çš„ãªasync/awaitã€å°†æ¥çš„ã«coroutineã®è©³ç´°åˆ¶å¾¡ã‚‚è¿½åŠ å¯èƒ½

**å®Ÿè£…æˆ¦ç•¥**:
```
ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹: async/awaitï¼ˆé«˜ãƒ¬ãƒ™ãƒ«ï¼‰
         â†“
å†…éƒ¨å®Ÿè£…: Coroutineæ©Ÿæ§‹ï¼ˆä½ãƒ¬ãƒ™ãƒ«ï¼‰
         â†“
å®Ÿè¡ŒåŸºç›¤: Event Loop / Executor
```

---

## ğŸ” Cbã«ãŠã‘ã‚‹ç¾çŠ¶åˆ†æ

### æ—¢å­˜ã®æ©Ÿèƒ½

#### âœ… åˆ©ç”¨å¯èƒ½ãªæ©Ÿèƒ½

1. **é–¢æ•°ãƒã‚¤ãƒ³ã‚¿**: ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿæ§‹ã¨ã—ã¦åˆ©ç”¨å¯èƒ½
   ```cb
   int* callback = int func(int x) { return x * 2; };
   ```

2. **Lambdaå¼**: åŒ¿åé–¢æ•°ã¨ã—ã¦éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’å®šç¾©å¯èƒ½
   ```cb
   int* task = int func() {
       // éåŒæœŸå‡¦ç†
       return result;
   };
   ```

3. **æ§‹é€ ä½“**: Future/Promiseã®çŠ¶æ…‹ç®¡ç†ã«åˆ©ç”¨
   ```cb
   struct Future<T> {
       T value;
       bool is_ready;
   };
   ```

4. **Interface/Impl**: éåŒæœŸãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ã«æ´»ç”¨
   ```cb
   interface AsyncTask {
       void run();
       bool is_complete();
   };
   ```

5. **ã‚¹ã‚³ãƒ¼ãƒ—ãƒ™ãƒ¼ã‚¹ã®ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†**: deferã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   ```cb
   {
       Resource r;
       defer cleanup();
   }  // è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   ```

#### âŒ ä¸è¶³ã—ã¦ã„ã‚‹æ©Ÿèƒ½

1. **ã‚¹ãƒ¬ãƒƒãƒ‰/ä¸¦è¡Œå®Ÿè¡Œæ©Ÿæ§‹**
   - ç¾çŠ¶: ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè¡Œ
   - å¿…è¦: ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚µãƒãƒ¼ãƒˆã€ã¾ãŸã¯Event Loop

2. **ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—**
   - ç¾çŠ¶: é€æ¬¡å®Ÿè¡Œã®ã¿
   - å¿…è¦: éåŒæœŸã‚¿ã‚¹ã‚¯ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°

3. **ã‚¹ãƒªãƒ¼ãƒ—/å¾…æ©Ÿæ©Ÿæ§‹**
   - ç¾çŠ¶: ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°æ“ä½œã®ã¿
   - å¿…è¦: ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãªå¾…æ©Ÿ

4. **ãƒãƒ£ãƒãƒ«/é€šä¿¡æ©Ÿæ§‹**
   - ç¾çŠ¶: ãªã—
   - å¿…è¦: éåŒæœŸã‚¿ã‚¹ã‚¯é–“ã®é€šä¿¡

5. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ‹¡å¼µ**
   - ç¾çŠ¶: åŸºæœ¬çš„ãªthrowã®ã¿
   - å¿…è¦: asyncé–¢æ•°å†…ã§ã®ã‚¨ãƒ©ãƒ¼ä¼æ’­

6. **ã‚¿ã‚¤ãƒãƒ¼/æ™‚é–“ç®¡ç†**
   - ç¾çŠ¶: åŸºæœ¬çš„ãªæ™‚é–“é–¢æ•°ã®ã¿
   - å¿…è¦: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€é…å»¶å®Ÿè¡Œ

### éåŒæœŸå‡¦ç†ã«å¿…è¦ãªè¿½åŠ æ©Ÿèƒ½

#### ğŸ”´ æœ€å„ªå…ˆï¼ˆv0.11.0ã§å®Ÿè£…å¿…é ˆï¼‰

1. **Event Loopå®Ÿè£…**
   - ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã®ç®¡ç†
   - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼
   - å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆ‡ã‚Šæ›¿ãˆ

2. **Future/Promiseå‹**
   - éåŒæœŸçµæœã®è¡¨ç¾
   - çŠ¶æ…‹ç®¡ç†ï¼ˆPending, Ready, Errorï¼‰

3. **async/awaitæ§‹æ–‡**
   - ãƒ‘ãƒ¼ã‚µãƒ¼æ‹¡å¼µ
   - ã‚³ãƒ¼ãƒ‰ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

#### ğŸŸ¡ é«˜å„ªå…ˆï¼ˆv0.11.x-v0.12.0ï¼‰

4. **ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½**
   - `sleep_async(duration)`
   - `timeout(duration, task)`

5. **åŸºæœ¬çš„ãªãƒãƒ£ãƒãƒ«**
   - Producer-Consumer ãƒ‘ã‚¿ãƒ¼ãƒ³
   - éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°

6. **ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰**
   - ä¸¦åˆ—å®Ÿè¡Œã®ã‚µãƒãƒ¼ãƒˆ
   - CPUãƒã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã®å‡¦ç†

#### ğŸŸ¢ ä¸­å„ªå…ˆï¼ˆv0.12.0ä»¥é™ï¼‰

7. **ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¢ã‚»ãƒ³ãƒ–ãƒªï¼ˆASMï¼‰**
   - ä½ãƒ¬ãƒ™ãƒ«æœ€é©åŒ–
   - ã‚¢ãƒˆãƒŸãƒƒã‚¯æ“ä½œ
   - ç¾æ™‚ç‚¹ã§ã¯**ä¸è¦**ï¼ˆEvent Loopå®Ÿè£…ã§ååˆ†ï¼‰

8. **Select/Raceæ§‹æ–‡**
   - è¤‡æ•°ã®Futureã‚’åŒæ™‚ã«å¾…æ©Ÿ
   - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†

---

## ğŸ’¡ ææ¡ˆã™ã‚‹å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

### Phase 1: åŸºæœ¬çš„ãªasync/awaitï¼ˆv0.11.0ç›®æ¨™ï¼‰

**ã‚¹ã‚³ãƒ¼ãƒ—**: å”èª¿çš„ãƒãƒ«ãƒã‚¿ã‚¹ã‚­ãƒ³ã‚°ï¼ˆCooperative Multitaskingï¼‰

**ç‰¹å¾´**:
- Event Loop ãƒ™ãƒ¼ã‚¹
- ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè¡Œ
- æ˜ç¤ºçš„ãª`await`ãƒã‚¤ãƒ³ãƒˆã§ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆ
- I/Oãƒã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã«æœ€é©

**åˆ©ç‚¹**:
- âœ… å®Ÿè£…ãŒæ¯”è¼ƒçš„ã‚·ãƒ³ãƒ—ãƒ«
- âœ… ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã®å¿ƒé…ãŒå°‘ãªã„
- âœ… ãƒ‡ãƒãƒƒã‚°ãŒå®¹æ˜“
- âœ… JavaScript/TypeScriptã¨åŒæ§˜ã®ãƒ¢ãƒ‡ãƒ«

**åˆ¶é™**:
- âš ï¸ CPUãƒã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã«ã¯ä¸å‘ãï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰
- âš ï¸ çœŸã®ä¸¦åˆ—å®Ÿè¡Œã¯ä¸å¯

### Phase 2: ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«çµ±åˆï¼ˆv0.12.0ä»¥é™ï¼‰

**ã‚¹ã‚³ãƒ¼ãƒ—**: ãƒ—ãƒªã‚¨ãƒ³ãƒ—ãƒ†ã‚£ãƒ–ãƒãƒ«ãƒã‚¿ã‚¹ã‚­ãƒ³ã‚°ï¼ˆPreemptive Multitaskingï¼‰

**ç‰¹å¾´**:
- ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã§CPUãƒã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
- async/awaitæ§‹æ–‡ã¯ãã®ã¾ã¾
- å†…éƒ¨ã§ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç®¡ç†

---

## ğŸ“ æ§‹æ–‡ã¨ä»•æ§˜

### åŸºæœ¬æ§‹æ–‡

#### asyncé–¢æ•°ã®å®šç¾©

```cb
// åŸºæœ¬çš„ãªasyncé–¢æ•°
async int fetch_data(string url) {
    println("Fetching data from: ", url);
    
    // éåŒæœŸå¾…æ©Ÿï¼ˆã“ã“ã§ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆï¼‰
    string result = await http_get(url);
    
    return parse_int(result);
}

// voidæˆ»ã‚Šå€¤ã®asyncé–¢æ•°
async void log_async(string message) {
    await sleep_ms(100);
    println(message);
}
```

#### awaitã®ä½¿ç”¨

```cb
void main() {
    // asyncé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨FutureãŒè¿”ã‚‹
    Future<int> future = fetch_data("https://api.example.com/data");
    
    // awaitã§çµæœã‚’å¾…ã¤ï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰
    int data = await future;
    println("Data: ", data);
}
```

#### è¤‡æ•°ã®await

```cb
async int process_multiple() {
    // é †æ¬¡å®Ÿè¡Œ
    int data1 = await fetch_data("url1");
    int data2 = await fetch_data("url2");
    int data3 = await fetch_data("url3");
    
    return data1 + data2 + data3;
}
```

#### ä¸¦è¡Œå®Ÿè¡Œï¼ˆFutureé…åˆ—ï¼‰

```cb
async int process_parallel() {
    // è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã‚’åŒæ™‚ã«é–‹å§‹
    Future<int> f1 = fetch_data("url1");
    Future<int> f2 = fetch_data("url2");
    Future<int> f3 = fetch_data("url3");
    
    // ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…ã¤
    int data1 = await f1;
    int data2 = await f2;
    int data3 = await f3;
    
    return data1 + data2 + data3;
}
```

### å‹ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ

#### Futureå‹ï¼ˆResultçµ±åˆç‰ˆï¼‰

```cb
// Futureã¯æˆåŠŸæ™‚ã®å€¤ã®ã¿ã‚’æŒã¤ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
struct Future<T> {
    T value;              // çµæœã®å€¤
    bool is_ready;        // å®Œäº†ãƒ•ãƒ©ã‚°
};

// Futureã¨Resultã®çµ„ã¿åˆã‚ã›ãŒæ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³
// asyncé–¢æ•°ã¯Future<Result<T, E>>ã‚’è¿”ã™
async Result<int, NetworkError> fetch_data(string url) {
    // ...
}

// ä½¿ç”¨ä¾‹
async void main() {
    // Futureã‚’å–å¾—
    Future<Result<int, NetworkError>> future = fetch_data("https://api.example.com");
    
    // awaitã§Resultã‚’å–å¾—
    Result<int, NetworkError> result = await future;
    
    // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    match (result) {
        Ok(value) => println("Success: ", value),
        Err(error) => println("Error: ", error.message)
    }
}

// ã¾ãŸã¯?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ç°¡æ½”ã«
async Result<int, Error> process() {
    int data = await fetch_data("url")?;  // ã‚¨ãƒ©ãƒ¼ã¯è‡ªå‹•ä¼æ’­
    return Ok(data * 2);
}
```

#### Futureã®çŠ¶æ…‹ç¢ºèªï¼ˆãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰

```cb
// Futureã®å®Œäº†çŠ¶æ…‹ã‚’ç¢ºèª
bool is_ready<T>(Future<T> future);

// ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆéæ¨å¥¨ã€awaitã‚’ä½¿ç”¨ã™ã¹ãï¼‰
async void polling_example() {
    Future<Result<int, Error>> future = fetch_data("url");
    
    while (!is_ready(future)) {
        println("Waiting...");
        await sleep_ms(100);
    }
    
    Result<int, Error> result = await future;
    // ...
}
```

#### asyncé–¢æ•°ã®å‹

```cb
// asyncé–¢æ•°ã®å‹ã¯ Future<T> ã‚’è¿”ã™é–¢æ•°ãƒã‚¤ãƒ³ã‚¿
typedef Future<int> AsyncIntFunc = async int func(string url);

async int my_async_func(string url) {
    return await fetch_data(url);
}

void main() {
    AsyncIntFunc f = my_async_func;
    Future<int> future = f("https://example.com");
    int result = await future;
}
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆRusté¢¨Resultå‹ï¼‰

#### Resultå‹ã®å®šç¾©

```cb
// Resultå‹: æˆåŠŸï¼ˆOkï¼‰ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ï¼ˆErrï¼‰ã‚’è¡¨ç¾
enum Result<T, E> {
    Ok(T),      // æˆåŠŸã—ãŸå ´åˆã®å€¤
    Err(E)      // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®å€¤
};

// ã‚ˆãä½¿ã†ã‚¨ãƒ©ãƒ¼å‹
struct Error {
    string message;
    int code;
};

// ç‰¹å®šã®ã‚¨ãƒ©ãƒ¼å‹
struct NetworkError {
    string message;
    int status_code;
};

struct FileError {
    string message;
    string path;
};
```

#### asyncé–¢æ•°ã§Resultå‹ã‚’è¿”ã™

```cb
// Result<T, E>ã‚’è¿”ã™asyncé–¢æ•°
async Result<int, NetworkError> fetch_data(string url) {
    if (url == "") {
        NetworkError err;
        err.message = "URL cannot be empty";
        err.status_code = 400;
        return Err(err);
    }
    
    string response = await http_get(url);
    
    if (response == "") {
        NetworkError err;
        err.message = "Empty response";
        err.status_code = 500;
        return Err(err);
    }
    
    int value = parse_int(response);
    return Ok(value);
}
```

#### Resultå‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°

```cb
async void main() {
    Result<int, NetworkError> result = await fetch_data("https://api.example.com");
    
    // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    match (result) {
        Ok(value) => {
            println("Success: ", value);
        },
        Err(error) => {
            println("Error: ", error.message);
            println("Status: ", error.status_code);
        }
    }
}
```

#### `?`ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆã‚¨ãƒ©ãƒ¼ä¼æ’­ï¼‰

```cb
// Rustã®`?`ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨åŒæ§˜ã®æ©Ÿèƒ½
async Result<int, Error> process_data(string url) {
    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã€è‡ªå‹•çš„ã«è¿”ã™
    int data = await fetch_data(url)?;  // Errã®å ´åˆã¯ã“ã“ã§å³return
    
    int processed = data * 2;
    return Ok(processed);
}

// è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
async Result<int, Error> complex_operation() {
    int data1 = await fetch_data("url1")?;
    int data2 = await fetch_data("url2")?;
    int data3 = await fetch_data("url3")?;
    
    return Ok(data1 + data2 + data3);
}
```

#### unwrap/expectï¼ˆé–‹ç™ºæ™‚ã®ç°¡æ˜“çš„ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼‰

```cb
async void main() {
    Result<int, NetworkError> result = await fetch_data("https://api.example.com");
    
    // unwrap: ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ‘ãƒ‹ãƒƒã‚¯ï¼ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ çµ‚äº†ï¼‰
    int value = result.unwrap();  // é–‹ç™ºæ™‚ã®ã¿æ¨å¥¨
    
    // expect: ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä»˜ãã§ãƒ‘ãƒ‹ãƒƒã‚¯
    int value2 = result.expect("Failed to fetch data from API");
}
```

#### unwrap_or/unwrap_or_elseï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®æä¾›ï¼‰

```cb
async void main() {
    Result<int, NetworkError> result = await fetch_data("https://api.example.com");
    
    // unwrap_or: ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
    int value = result.unwrap_or(0);
    println("Value: ", value);
    
    // unwrap_or_else: ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯é–¢æ•°ã‚’å®Ÿè¡Œ
    int value2 = result.unwrap_or_else(int func(NetworkError e) {
        println("Error occurred: ", e.message);
        return -1;
    });
}
```

#### map/and_thenï¼ˆResultå‹ã®å¤‰æ›ï¼‰

```cb
// map: Okå€¤ã‚’å¤‰æ›ï¼ˆã‚¨ãƒ©ãƒ¼ã¯ãã®ã¾ã¾ä¼æ’­ï¼‰
async Result<string, NetworkError> fetch_and_format(string url) {
    Result<int, NetworkError> result = await fetch_data(url);
    
    // Okã®å ´åˆã®ã¿å€¤ã‚’å¤‰æ›
    return result.map(int func(int value) {
        return "Value is: " + to_string(value);
    });
}

// and_then: Resultå‹ã‚’è¿”ã™é–¢æ•°ã§ãƒã‚§ãƒ¼ãƒ³
async Result<int, NetworkError> fetch_and_double(string url) {
    Result<int, NetworkError> result = await fetch_data(url);
    
    return result.and_then(Result<int, NetworkError> func(int value) {
        if (value < 0) {
            NetworkError err;
            err.message = "Negative value not allowed";
            err.status_code = 400;
            return Err(err);
        }
        return Ok(value * 2);
    });
}
```

#### å¾“æ¥ã®try-catchã¨ã®å…±å­˜

```cb
// try-catchã‚‚å¼•ãç¶šãã‚µãƒãƒ¼ãƒˆï¼ˆç·Šæ€¥æ™‚ã®ã¿ä½¿ç”¨ã‚’æ¨å¥¨ï¼‰
async void legacy_error_handling() {
    try {
        // ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’èµ·ã“ã™å¯èƒ½æ€§ã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰
        int value = some_result.unwrap();
        println("Value: ", value);
    } catch (PanicError& e) {
        println("Panic caught: ", e.message);
    }
}
```

#### å®Ÿç”¨ä¾‹: è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼å‹ã‚’æ‰±ã†

```cb
// è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼å‹ã‚’Unionå‹ã§ã¾ã¨ã‚ã‚‹
typedef AppError = NetworkError | FileError | ParseError;

async Result<User, AppError> load_user(int user_id) {
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’èª­ã¿è¾¼ã‚€
    Result<string, FileError> config_result = await read_file("config.json");
    string config = config_result?;  // ã‚¨ãƒ©ãƒ¼ã¯è‡ªå‹•çš„ã«ä¼æ’­
    
    // APIã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
    Result<string, NetworkError> api_result = await http_get("/users/" + to_string(user_id));
    string user_json = api_result?;
    
    // JSONã‚’ãƒ‘ãƒ¼ã‚¹
    Result<User, ParseError> parse_result = parse_user(user_json);
    User user = parse_result?;
    
    return Ok(user);
}

async void main() {
    Result<User, AppError> result = await load_user(123);
    
    match (result) {
        Ok(user) => {
            println("User loaded: ", user.name);
        },
        Err(error) => {
            match (error) {
                NetworkError(e) => println("Network error: ", e.message),
                FileError(e) => println("File error: ", e.path),
                ParseError(e) => println("Parse error: ", e.message)
            }
        }
    }
}
```

### ã‚¿ã‚¤ãƒãƒ¼ã¨ã‚¹ãƒªãƒ¼ãƒ—

```cb
// ãƒŸãƒªç§’å˜ä½ã®ã‚¹ãƒªãƒ¼ãƒ—ï¼ˆéåŒæœŸï¼‰
async void sleep_ms(int milliseconds);

// ç§’å˜ä½ã®ã‚¹ãƒªãƒ¼ãƒ—ï¼ˆéåŒæœŸï¼‰
async void sleep(int seconds) {
    await sleep_ms(seconds * 1000);
}

// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Ÿè¡Œ
async int with_timeout(Future<int> future, int timeout_ms) {
    // å°†æ¥çš„ãªå®Ÿè£…ï¼ˆv0.12.0ä»¥é™ï¼‰
    // ...
}
```

### å®Ÿç”¨ä¾‹

#### HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆResultå‹ç‰ˆï¼‰

```cb
async Result<string, NetworkError> http_get(string url) {
    println("GET ", url);
    await sleep_ms(100);  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é…å»¶ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    
    if (url == "") {
        NetworkError err;
        err.message = "Empty URL";
        err.status_code = 400;
        return Err(err);
    }
    
    return Ok("Response from " + url);
}

async Result<void, NetworkError> main() {
    Result<string, NetworkError> result = await http_get("https://api.example.com");
    
    match (result) {
        Ok(response) => println("Response: ", response),
        Err(error) => println("Error: ", error.message)
    }
    
    return Ok(void);  // voidæˆ»ã‚Šå€¤ã®Ok
}

// ã¾ãŸã¯?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ç°¡æ½”ã«
async Result<void, NetworkError> main_short() {
    string response = await http_get("https://api.example.com")?;
    println("Response: ", response);
    return Ok(void);
}
```

#### ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ï¼ˆResultå‹ç‰ˆï¼‰

```cb
async Result<string, FileError> read_file_async(string path) {
    println("Reading file: ", path);
    await sleep_ms(50);  // I/Oå¾…æ©Ÿã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    
    if (!file_exists(path)) {
        FileError err;
        err.message = "File not found";
        err.path = path;
        return Err(err);
    }
    
    return Ok("File contents from " + path);
}

async Result<void, FileError> process_files() {
    // ä¸¦è¡Œèª­ã¿è¾¼ã¿
    Future<Result<string, FileError>> f1 = read_file_async("file1.txt");
    Future<Result<string, FileError>> f2 = read_file_async("file2.txt");
    Future<Result<string, FileError>> f3 = read_file_async("file3.txt");
    
    // ã™ã¹ã¦ã®çµæœã‚’å–å¾—ï¼ˆ?ã§ç°¡æ½”ã«ï¼‰
    string content1 = await f1?;
    string content2 = await f2?;
    string content3 = await f3?;
    
    println("All files loaded!");
    return Ok(void);
}
```

#### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªï¼ˆResultå‹ç‰ˆï¼‰

```cb
struct User {
    int id;
    string name;
    string email;
};

struct DbError {
    string message;
    string query;
};

async Result<User, DbError> fetch_user(int user_id) {
    println("Fetching user ", user_id);
    await sleep_ms(200);  // DBé…å»¶
    
    if (user_id <= 0) {
        DbError err;
        err.message = "Invalid user ID";
        err.query = "SELECT * FROM users WHERE id = " + to_string(user_id);
        return Err(err);
    }
    
    User user;
    user.id = user_id;
    user.name = "Alice";
    user.email = "alice@example.com";
    return Ok(user);
}

async Result<void, DbError> main() {
    Result<User, DbError> result = await fetch_user(1);
    
    match (result) {
        Ok(user) => {
            println("User: ", user.name, " (", user.email, ")");
        },
        Err(error) => {
            println("Database error: ", error.message);
            println("Query: ", error.query);
        }
    }
    
    return Ok(void);
}

// ã¾ãŸã¯?ã¨unwrap_orã‚’çµ„ã¿åˆã‚ã›ã¦
async void main_with_defaults() {
    Result<User, DbError> result = await fetch_user(1);
    User user = result.unwrap_or(User{0, "Guest", "guest@example.com"});
    println("User: ", user.name);
}
```

---

## ğŸ”§ å®Ÿè£…è¦ä»¶

### 1. ãƒ‘ãƒ¼ã‚µãƒ¼æ‹¡å¼µ

#### æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³

```cpp
enum class TokenType {
    // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¯ãƒ³...
    
    // éåŒæœŸå‡¦ç†ç”¨ã®æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³
    TOK_ASYNC,      // "async"
    TOK_AWAIT,      // "await"
    TOK_FUTURE,     // "Future" (çµ„ã¿è¾¼ã¿å‹ã¨ã—ã¦)
    
    // Resultå‹ç”¨
    TOK_RESULT,     // "Result" (çµ„ã¿è¾¼ã¿å‹ã¨ã—ã¦)
    TOK_OK,         // "Ok"
    TOK_ERR,        // "Err"
    TOK_QUESTION,   // "?" (ã‚¨ãƒ©ãƒ¼ä¼æ’­ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼)
};
```

#### ASTæ‹¡å¼µ

```cpp
// æ–°ã—ã„ASTãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—
enum class ASTNodeType {
    // æ—¢å­˜ã®ãƒãƒ¼ãƒ‰...
    
    // éåŒæœŸå‡¦ç†ç”¨
    AST_ASYNC_FUNCTION,     // asyncé–¢æ•°å®šç¾©
    AST_AWAIT_EXPRESSION,   // awaitå¼
    AST_FUTURE_TYPE,        // Futureå‹
    
    // Resultå‹ç”¨
    AST_RESULT_TYPE,        // Resultå‹
    AST_OK_EXPRESSION,      // Ok(value)
    AST_ERR_EXPRESSION,     // Err(error)
    AST_TRY_OPERATOR,       // ? ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼
};

// asyncé–¢æ•°ã®ãƒ•ãƒ©ã‚°
struct ASTNode {
    // æ—¢å­˜ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰...
    
    bool is_async = false;  // ã“ã®é–¢æ•°ãŒasyncã‹ã©ã†ã‹
};
```

#### BNFæ‹¡å¼µ

```bnf
<async_function> ::= 'async' <type_specifier> '(' <parameter_list>? ')' <block>

<await_expression> ::= 'await' <expression>

<future_type> ::= 'Future' '<' <type_specifier> '>'

<result_type> ::= 'Result' '<' <type_specifier> ',' <type_specifier> '>'

<ok_expression> ::= 'Ok' '(' <expression> ')'

<err_expression> ::= 'Err' '(' <expression> ')'

<try_operator> ::= <expression> '?'
```

### 2. ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿æ‹¡å¼µ

#### Event Loopå®Ÿè£…

```cpp
class EventLoop {
public:
    void schedule_task(std::function<void()> task);
    void run();
    void stop();
    
private:
    std::queue<std::function<void()>> task_queue_;
    bool is_running_ = false;
};
```

#### Resultå‹å®Ÿè£…

```cpp
// Resultå‹ã®ãƒãƒªã‚¢ãƒ³ãƒˆï¼ˆOk/Errï¼‰
enum class ResultVariant {
    OK,
    ERR
};

template<typename T, typename E>
class Result {
public:
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    static Result<T, E> Ok(T value);
    static Result<T, E> Err(E error);
    
    // çŠ¶æ…‹ç¢ºèª
    bool is_ok() const;
    bool is_err() const;
    
    // å€¤ã®å–å¾—
    T unwrap();  // Errã®å ´åˆã¯ãƒ‘ãƒ‹ãƒƒã‚¯
    T expect(const std::string& message);  // ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä»˜ããƒ‘ãƒ‹ãƒƒã‚¯
    T unwrap_or(T default_value);
    T unwrap_or_else(std::function<T(E)> func);
    
    // å¤‰æ›
    template<typename U>
    Result<U, E> map(std::function<U(T)> func);
    
    template<typename U>
    Result<U, E> and_then(std::function<Result<U, E>(T)> func);
    
private:
    ResultVariant variant_;
    std::optional<T> ok_value_;
    std::optional<E> err_value_;
};
```

#### Futureå®Ÿè£…ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰

```cpp
template<typename T>
class Future {
public:
    bool is_ready() const;
    T get();  // ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°
    void set_value(T value);
    
private:
    std::optional<T> value_;
    bool is_ready_ = false;
};

// Futureã¯Resultå‹ã¨çµ„ã¿åˆã‚ã›ã¦ä½¿ç”¨
// Future<Result<T, E>> ãŒæ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³
```

#### asyncé–¢æ•°ã®å®Ÿè¡Œ

```cpp
class Interpreter {
public:
    // æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰...
    
    // asyncé–¢æ•°ã®å®Ÿè¡Œ
    int64_t execute_async_function(const ASTNode* node);
    
    // awaitå¼ã®è©•ä¾¡
    int64_t evaluate_await_expression(const ASTNode* node);
    
    // ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆtry operatorï¼‰ã®è©•ä¾¡
    int64_t evaluate_try_operator(const ASTNode* node);
    
private:
    EventLoop event_loop_;
    std::unordered_map<std::string, std::shared_ptr<FutureBase>> futures_;
    std::unordered_map<std::string, std::shared_ptr<ResultBase>> results_;
};
```

### 3. æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ‹¡å¼µ

#### stdlib/async.cb

```cb
// Resultå‹ã®å®šç¾©
enum Result<T, E> {
    Ok(T),
    Err(E)
};

// Resultå‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆçµ„ã¿è¾¼ã¿ï¼‰
bool is_ok<T, E>(Result<T, E> result);
bool is_err<T, E>(Result<T, E> result);
T unwrap<T, E>(Result<T, E> result);
T expect<T, E>(Result<T, E> result, string message);
T unwrap_or<T, E>(Result<T, E> result, T default_value);

// Futureå‹ã®å®šç¾©
struct Future<T> {
    T value;
    bool is_ready;
};

// ã‚¿ã‚¤ãƒãƒ¼é–¢æ•°
async void sleep_ms(int milliseconds);
async void sleep(int seconds);

// Futureæ“ä½œ
bool is_ready<T>(Future<T> future);
```

#### stdlib/concurrent.cbï¼ˆå°†æ¥çš„ï¼‰

```cb
// ã‚¹ãƒ¬ãƒƒãƒ‰æ“ä½œ
struct Thread {
    int id;
    bool is_running;
};

Thread spawn_thread(void* func);
void join_thread(Thread thread);

// ãƒãƒ£ãƒãƒ«
struct Channel<T> {
    int capacity;
};

Channel<T> create_channel<T>(int capacity);
async void send<T>(Channel<T> chan, T value);
async T receive<T>(Channel<T> chan);
```

---

## ğŸš€ æ®µéšçš„å®Ÿè£…è¨ˆç”»

### âš ï¸ é‡è¦: å®Ÿè£…é †åºã®ä¾å­˜é–¢ä¿‚

async/awaitã¨Resultå‹ã®å®Ÿè£…ã«ã¯ã€ä»¥ä¸‹ã®æ©Ÿèƒ½ãŒå‰ææ¡ä»¶ã¨ãªã‚Šã¾ã™ï¼š

```
Phase 0: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰
    â†“
Phase 1: Event Loop + ã‚¿ã‚¤ãƒãƒ¼
    â†“
Phase 2: Future<T> å‹
    â†“
Phase 3: Result<T, E> å‹ + ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
    â†“
Phase 4: async/awaitæ§‹æ–‡
    â†“
Phase 5: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼
```

### Phase 0: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å®Ÿè£…ï¼ˆå‰ææ¡ä»¶ï¼‰ï¼ˆ4é€±é–“ï¼‰

**ç›®æ¨™**: `Future<T>`ã¨`Result<T, E>`ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®åŸºç›¤

#### ãªãœã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ãŒå¿…è¦ã‹

async/awaitã§å¿…é ˆã®å‹ï¼š
```cb
// ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ãŒå¿…è¦
Future<int>
Future<string>
Future<User>
Future<Result<int, Error>>

Result<int, NetworkError>
Result<User, DbError>
Result<void, FileError>
```

#### ã‚¿ã‚¹ã‚¯ï¼ˆv0.11.0_generics_spec.mdã‹ã‚‰ï¼‰

1. **åŸºæœ¬çš„ãªã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“**ï¼ˆ2é€±é–“ï¼‰
   - [ ] æ§‹æ–‡è§£æ: `struct Box<T> { T value; }`
   - [ ] å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç®¡ç†
   - [ ] ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
   - [ ] ãƒ†ã‚¹ãƒˆ: åŸºæœ¬çš„ãªæ§‹é€ ä½“

2. **ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°**ï¼ˆ1é€±é–“ï¼‰
   - [ ] æ§‹æ–‡è§£æ: `T max<T>(T a, T b)`
   - [ ] é–¢æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å®Ÿè£…
   - [ ] ãƒ†ã‚¹ãƒˆ: åŸºæœ¬çš„ãªé–¢æ•°

3. **Enumå‹ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å¯¾å¿œ**ï¼ˆ1é€±é–“ï¼‰
   - [ ] æ§‹æ–‡è§£æ: `enum Result<T, E> { Ok(T), Err(E) }`
   - [ ] ãƒãƒªã‚¢ãƒ³ãƒˆä»˜ãEnum
   - [ ] ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°çµ±åˆ
   - [ ] ãƒ†ã‚¹ãƒˆ: Resultå‹ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—

#### æœ€å°é™ã®å®Ÿè£…ç¯„å›²

async/awaitå®Ÿè£…ã«å¿…è¦ãªæ©Ÿèƒ½ã®ã¿ã«çµã‚‹ï¼š
- âœ… ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“ï¼ˆ`Future<T>`ç”¨ï¼‰
- âœ… ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Enumï¼ˆ`Result<T, E>`ç”¨ï¼‰
- âœ… åŸºæœ¬çš„ãªå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ`<T>`, `<T, E>`ï¼‰
- âš ï¸ å‹åˆ¶ç´„ã¯å¾Œå›ã—ï¼ˆv0.11.1ä»¥é™ï¼‰
- âš ï¸ ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Interfaceã¯å¾Œå›ã—ï¼ˆv0.11.1ä»¥é™ï¼‰
- âš ï¸ å‹æ¨è«–ã¯å¾Œå›ã—ï¼ˆv0.12.0ä»¥é™ï¼‰

#### å®Ÿè£…é †åºã®ç†ç”±

1. **Future<T>ã®å®Ÿè£…ã«å¿…é ˆ**
   ```cb
   struct Future<T> {
       T value;
       bool is_ready;
   };
   ```

2. **Result<T, E>ã®å®Ÿè£…ã«å¿…é ˆ**
   ```cb
   enum Result<T, E> {
       Ok(T),
       Err(E)
   };
   ```

3. **asyncé–¢æ•°ã®æˆ»ã‚Šå€¤ã«å¿…é ˆ**
   ```cb
   async Result<int, Error> fetch_data(string url) {
       // ...
   }
   // â†“ å†…éƒ¨çš„ã«ã¯
   Future<Result<int, Error>> fetch_data(string url);
   ```

### Phase 1: Event Loop + ã‚¿ã‚¤ãƒãƒ¼ï¼ˆ2é€±é–“ï¼‰

**ç›®æ¨™**: éåŒæœŸã‚¿ã‚¹ã‚¯ã®å®Ÿè¡ŒåŸºç›¤ï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ä¸è¦ã®éƒ¨åˆ†ï¼‰

#### ã‚¿ã‚¹ã‚¯
1. **Event Loopå®Ÿè£…**
   - [ ] ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã®å®Ÿè£…
   - [ ] ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã®å®Ÿè£…
   - [ ] run/stop ãƒ¡ã‚½ãƒƒãƒ‰

2. **ã‚¿ã‚¤ãƒãƒ¼å®Ÿè£…**
   - [ ] sleep_ms ã®å®Ÿè£…ï¼ˆã¾ãšã¯éã‚¸ã‚§ãƒãƒªãƒƒã‚¯ç‰ˆï¼‰
   - [ ] ã‚¿ã‚¤ãƒãƒ¼ã‚­ãƒ¥ãƒ¼ã®ç®¡ç†

#### ãƒ†ã‚¹ãƒˆ
- Event Loopã®åŸºæœ¬å‹•ä½œ
- ã‚¿ã‚¤ãƒãƒ¼ã®ç²¾åº¦
- ã‚¿ã‚¹ã‚¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°

### Phase 2: Future<T>å‹ï¼ˆ1é€±é–“ï¼‰

**ç›®æ¨™**: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªFutureå‹ã®å®Ÿè£…ï¼ˆPhase 0ã®æˆæœã‚’åˆ©ç”¨ï¼‰

#### ã‚¿ã‚¹ã‚¯
1. **Future<T>æ§‹é€ ä½“ã®å®šç¾©**
   - [ ] ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“ã¨ã—ã¦å®Ÿè£…
   - [ ] çŠ¶æ…‹ç®¡ç†ï¼ˆPending, Readyï¼‰
   - [ ] get/set ãƒ¡ã‚½ãƒƒãƒ‰

2. **Future<T>ã®åŸºæœ¬æ“ä½œ**
   - [ ] `is_ready<T>(Future<T>)` é–¢æ•°
   - [ ] Futureå¤‰æ•°ã®å®£è¨€ã¨åˆæœŸåŒ–

#### ãƒ†ã‚¹ãƒˆ
- Future<int>, Future<string> ã®å‹•ä½œç¢ºèª
- çŠ¶æ…‹é·ç§»ã®ãƒ†ã‚¹ãƒˆ
- è¤‡æ•°ã®Futureã®ç®¡ç†

### Phase 3: Result<T, E>å‹ + ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼ˆ3é€±é–“ï¼‰

**ç›®æ¨™**: Rusté¢¨Resultå‹ã®å®Œå…¨å®Ÿè£…ï¼ˆPhase 0ã®æˆæœã‚’åˆ©ç”¨ï¼‰

#### ã‚¿ã‚¹ã‚¯
1. **Result<T, E> Enumå®šç¾©**ï¼ˆ1é€±é–“ï¼‰
   - [ ] `enum Result<T, E>` ã®æ§‹æ–‡è§£æ
   - [ ] Ok/Err ãƒãƒªã‚¢ãƒ³ãƒˆã®å®Ÿè£…
   - [ ] ãƒãƒªã‚¢ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†

2. **ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°å®Ÿè£…**ï¼ˆ1é€±é–“ï¼‰
   - [ ] `match` æ–‡ã®æ§‹æ–‡è§£æ
   - [ ] Enumãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒãƒƒãƒãƒ³ã‚°
   - [ ] å€¤ã®æŠ½å‡ºï¼ˆ`Ok(value)`, `Err(error)`ï¼‰

3. **Resultå‹ã®ãƒ¡ã‚½ãƒƒãƒ‰**ï¼ˆ1é€±é–“ï¼‰
   - [ ] `unwrap()` / `expect()`
   - [ ] `unwrap_or()` / `unwrap_or_else()`
   - [ ] `is_ok()` / `is_err()`
   - [ ] `map()` / `and_then()`ï¼ˆãƒ©ãƒ ãƒ€å¼ã‚’åˆ©ç”¨ï¼‰

#### ãƒ†ã‚¹ãƒˆ
- Resultå‹ã®åŸºæœ¬å‹•ä½œ
- ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã®å‹•ä½œç¢ºèª
- Resultå‹ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ†ã‚¹ãƒˆ
- ã‚¨ãƒ©ãƒ¼ä¼æ’­ã®ãƒ†ã‚¹ãƒˆ

### Phase 4: async/awaitæ§‹æ–‡ï¼ˆ3é€±é–“ï¼‰

**ç›®æ¨™**: async/awaitæ§‹æ–‡ã®å®Ÿè£…ï¼ˆPhase 0-3ã®æˆæœã‚’åˆ©ç”¨ï¼‰

#### ã‚¿ã‚¹ã‚¯
1. **ãƒ‘ãƒ¼ã‚µãƒ¼æ‹¡å¼µ**ï¼ˆ1é€±é–“ï¼‰
   - [ ] `async` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®èªè­˜
   - [ ] `await` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®èªè­˜
   - [ ] asyncé–¢æ•°å®šç¾©ã®ãƒ‘ãƒ¼ã‚¹
   - [ ] awaitå¼ã®ãƒ‘ãƒ¼ã‚¹

2. **ASTæ‹¡å¼µ**ï¼ˆ1é€±é–“ï¼‰
   - [ ] AST_ASYNC_FUNCTION ãƒãƒ¼ãƒ‰
   - [ ] AST_AWAIT_EXPRESSION ãƒãƒ¼ãƒ‰
   - [ ] is_async ãƒ•ãƒ©ã‚°

3. **ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å®Ÿè£…**ï¼ˆ1é€±é–“ï¼‰
   - [ ] asyncé–¢æ•°ã®å®Ÿè¡Œï¼ˆFuture<Result<T, E>>ã‚’è¿”ã™ï¼‰
   - [ ] awaitå¼ã®è©•ä¾¡
   - [ ] ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ‡ã‚Šæ›¿ãˆ
   - [ ] Event Loopã¨ã®çµ±åˆ

#### ãƒ†ã‚¹ãƒˆ
- åŸºæœ¬çš„ãªasyncé–¢æ•°ã®å®šç¾©ã¨å‘¼ã³å‡ºã—
- awaitå¼ã®å‹•ä½œ
- è¤‡æ•°ã®awaitã®é€£ç¶šå®Ÿè¡Œ
- asyncé–¢æ•°ã‹ã‚‰ã®Resultå‹è¿”å´

### Phase 5: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆ1é€±é–“ï¼‰

**ç›®æ¨™**: ã‚¨ãƒ©ãƒ¼ä¼æ’­ã®ç°¡æ½”ãªè¨˜æ³•

#### ã‚¿ã‚¹ã‚¯
1. **?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®æ§‹æ–‡è§£æ**
   - [ ] `expr?` ã®èªè­˜
   - [ ] å¾Œç½®æ¼”ç®—å­ã¨ã—ã¦ã®å®Ÿè£…

2. **ã‚¨ãƒ©ãƒ¼ä¼æ’­ãƒ­ã‚¸ãƒƒã‚¯**
   - [ ] Resultå‹ã®ãƒã‚§ãƒƒã‚¯
   - [ ] Errã®å ´åˆã®æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
   - [ ] Okã®å ´åˆã®å€¤ã®æŠ½å‡º

3. **å‹ãƒã‚§ãƒƒã‚¯**
   - [ ] é–¢æ•°ã®æˆ»ã‚Šå€¤ãŒResultå‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
   - [ ] ã‚¨ãƒ©ãƒ¼å‹ã®äº’æ›æ€§ãƒã‚§ãƒƒã‚¯

#### ãƒ†ã‚¹ãƒˆ
- ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®åŸºæœ¬å‹•ä½œ
- ã‚¨ãƒ©ãƒ¼ä¼æ’­ã®ãƒ†ã‚¹ãƒˆ
- ãƒã‚¹ãƒˆã—ãŸ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼
- asyncé–¢æ•°å†…ã§ã®?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼

### Phase 6: ä¸¦è¡Œå®Ÿè¡Œã¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ‹¡å……ï¼ˆ2é€±é–“ï¼‰

**ç›®æ¨™**: å®Ÿç”¨çš„ãªéåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°

#### ã‚¿ã‚¹ã‚¯
1. **ä¸¦è¡Œå®Ÿè¡Œã®ã‚µãƒãƒ¼ãƒˆ**
   - [ ] è¤‡æ•°ã®Futureã‚’åŒæ™‚ã«é–‹å§‹
   - [ ] å„Futureã‚’å€‹åˆ¥ã«await

2. **æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**
   - [ ] stdlib/async.cb ã®å……å®Ÿ
   - [ ] åŸºæœ¬çš„ãªã‚¨ãƒ©ãƒ¼å‹ã®å®šç¾©
   - [ ] ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°

#### ãƒ†ã‚¹ãƒˆ
- ä¸¦è¡Œå®Ÿè¡Œã®å‹•ä½œç¢ºèª
- ã‚¿ã‚¹ã‚¯å®Œäº†é †åºã®ãƒ†ã‚¹ãƒˆ
- å®Ÿç”¨çš„ãªã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰

---

## ğŸ“Š å®Ÿè£…å„ªå…ˆåº¦ãƒãƒˆãƒªãƒƒã‚¯ã‚¹

| æ©Ÿèƒ½ | å„ªå…ˆåº¦ | å®Ÿè£…é›£æ˜“åº¦ | å¿…è¦æ€§ | Phase |
|-----|-------|----------|-------|-------|
| **ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆåŸºæœ¬ï¼‰** | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­â­â­ | **å‰ææ¡ä»¶** | 0 |
| Event Loop | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­â­ | å¿…é ˆ | 1 |
| Future<T>å‹ | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­ | å¿…é ˆ | 2 |
| Result<T, E>å‹ | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­â­ | å¿…é ˆ | 3 |
| **ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°** | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­â­ | å¿…é ˆ | 3 |
| async/awaitæ§‹æ–‡ | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­â­â­ | å¿…é ˆ | 4 |
| ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ | ğŸ”´ æœ€å„ªå…ˆ | â­â­â­ | å¿…é ˆ | 5 |
| ã‚¿ã‚¤ãƒãƒ¼ | ğŸŸ¡ é«˜ | â­â­ | å¿…é ˆ | 1 |
| ä¸¦è¡Œå®Ÿè¡Œ | ğŸŸ¡ é«˜ | â­â­â­ | é‡è¦ | 6 |
| ãƒãƒ£ãƒãƒ« | ï¿½ ä¸­ | â­â­â­â­ | ä¾¿åˆ© | v0.12.0 |
| ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ« | ğŸŸ¢ ä¸­ | â­â­â­â­â­ | ä¾¿åˆ© | v0.12.0 |
| å‹åˆ¶ç´„ï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼‰ | ğŸŸ¢ ä¸­ | â­â­â­ | ä¾¿åˆ© | v0.11.1 |
| ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ASM | ğŸ”µ ä½ | â­â­â­â­â­ | ä¸è¦ | v0.13.0 |

---

## ğŸ“ å‚è€ƒå®Ÿè£…

### JavaScript/TypeScript
- **Event Loop**: Node.jsã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãƒ¢ãƒ‡ãƒ«
- **æ§‹æ–‡**: async/awaitæ§‹æ–‡
- **Promise**: Futureã®å®Ÿè£…ãƒ¢ãƒ‡ãƒ«

### Rust
- **Future trait**: Futureã®å‹ã‚·ã‚¹ãƒ†ãƒ 
- **Executor**: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œæ©Ÿæ§‹
- **Pin**: ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§

### C++20 Coroutines
- **co_await**: awaitå¼ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹
- **Promise type**: Futureã®å®Ÿè£…
- **Coroutine Handle**: å®Ÿè¡Œåˆ¶å¾¡

### Python asyncio
- **Event Loop**: ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã®å®Ÿè£…
- **Task**: ã‚¿ã‚¹ã‚¯ç®¡ç†
- **awaitå¼**: æ§‹æ–‡ã¨ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹

---

## â“ ã‚ˆãã‚ã‚‹è³ªå•

### Q1: ãªãœã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¢ã‚»ãƒ³ãƒ–ãƒªã¯ä¸è¦ï¼Ÿ

**A**: ç¾æ™‚ç‚¹ã§ã¯ä»¥ä¸‹ã®ç†ç”±ã‹ã‚‰å„ªå…ˆåº¦ãŒä½ã„ï¼š
- Event Loopãƒ™ãƒ¼ã‚¹ã®å®Ÿè£…ã§ååˆ†
- ã‚¢ãƒˆãƒŸãƒƒã‚¯æ“ä½œã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§æä¾›å¯èƒ½
- ä½ãƒ¬ãƒ™ãƒ«æœ€é©åŒ–ã¯å°†æ¥çš„ã«LLVMãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§å¯¾å¿œ
- é–‹ç™ºãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚³ã‚¢æ©Ÿèƒ½ã«é›†ä¸­ã™ã¹ã

### Q2: ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã¯v0.11.0ã«å«ã¾ã‚Œãªã„ï¼Ÿ

**A**: Phase 1ã§ã¯Event Loopã®ã¿å®Ÿè£…ã™ã‚‹ç†ç”±ï¼š
- ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè£…ã®æ–¹ãŒã‚·ãƒ³ãƒ—ãƒ«
- I/Oãƒã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã«ã¯ååˆ†
- ãƒ‡ãƒãƒƒã‚°ã¨ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“
- v0.12.0ã§ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã‚’è¿½åŠ ã™ã‚‹è¨ˆç”»

### Q3: asyncé–¢æ•°ã¯ã©ã®ã‚ˆã†ã«å®Ÿè¡Œã•ã‚Œã‚‹ï¼Ÿ

**A**: ä»¥ä¸‹ã®æµã‚Œã§å®Ÿè¡Œï¼š
1. asyncé–¢æ•°å‘¼ã³å‡ºã— â†’ Futureã‚’å³åº§ã«è¿”ã™
2. Futureã‚’await â†’ Event Loopã§ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
3. awaitåœ°ç‚¹ã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ‡ã‚Šæ›¿ãˆ â†’ ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
4. ã‚¿ã‚¹ã‚¯å®Œäº† â†’ Futureã«çµæœã‚’è¨­å®š
5. å‘¼ã³å‡ºã—å…ƒã«åˆ¶å¾¡ã‚’æˆ»ã™

### Q6: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®å®Ÿè£…è¦æ¨¡ã¯ã©ã®ãã‚‰ã„ï¼Ÿ

**A**: async/awaitã«å¿…è¦ãªæœ€å°é™ã®æ©Ÿèƒ½ã«çµã‚Šã¾ã™ï¼š

**v0.11.0ã§å®Ÿè£…ã™ã‚‹ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ©Ÿèƒ½**ï¼š
- âœ… ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“ï¼ˆ`struct Future<T>`, `struct Box<T>`ï¼‰
- âœ… ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Enumï¼ˆ`enum Result<T, E>`ï¼‰
- âœ… è¤‡æ•°ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ`<T>`, `<T, E>`ï¼‰
- âœ… åŸºæœ¬çš„ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ï¼ˆ`Future<int>`, `Result<User, Error>`ï¼‰

**v0.11.1ä»¥é™ã«å»¶æœŸã™ã‚‹æ©Ÿèƒ½**ï¼š
- âš ï¸ å‹åˆ¶ç´„ï¼ˆ`<T: int | long>`ï¼‰
- âš ï¸ ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°ï¼ˆ`T max<T>(T a, T b)`ï¼‰- å¿…è¦æœ€å°é™ã®ã¿
- âš ï¸ ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Interfaceï¼ˆ`interface Container<T>`ï¼‰
- âš ï¸ implçµ±åˆï¼ˆ`impl Trait<T> for Struct<T>`ï¼‰

**å®Ÿè£…æ™‚é–“ã®è¦‹ç©ã‚‚ã‚Š**ï¼š
- ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“: 2é€±é–“
- ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Enum: 1é€±é–“
- ãƒ†ã‚¹ãƒˆã¨ãƒ‡ãƒãƒƒã‚°: 1é€±é–“
- **åˆè¨ˆ**: 4é€±é–“

**å‚è€ƒ**: v0.11.0_generics_spec.mdã«ã¯å®Œå…¨ãªã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ä»•æ§˜ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ãŒã€async/awaitå®Ÿè£…ã®ãŸã‚ã«æ®µéšçš„ã«é€²ã‚ã¾ã™ã€‚

### Q7: v0.11.0ã®ãƒªãƒªãƒ¼ã‚¹æ™‚æœŸã¯ï¼Ÿ

**A**: å®Ÿè£…è¦æ¨¡ã‚’è€ƒæ…®ã—ãŸè¦‹ç©ã‚‚ã‚Šï¼š

| Phase | æ©Ÿèƒ½ | æœŸé–“ | å®Œäº†äºˆå®š |
|-------|-----|------|---------|
| Phase 0 | ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆåŸºæœ¬ï¼‰ | 4é€±é–“ | 2025å¹´11æœˆ23æ—¥ |
| Phase 1 | Event Loop + ã‚¿ã‚¤ãƒãƒ¼ | 2é€±é–“ | 2025å¹´12æœˆ7æ—¥ |
| Phase 2 | Future<T>å‹ | 1é€±é–“ | 2025å¹´12æœˆ14æ—¥ |
| Phase 3 | Result<T, E> + ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚° | 3é€±é–“ | 2026å¹´1æœˆ4æ—¥ |
| Phase 4 | async/awaitæ§‹æ–‡ | 3é€±é–“ | 2026å¹´1æœˆ25æ—¥ |
| Phase 5 | ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ | 1é€±é–“ | 2026å¹´2æœˆ1æ—¥ |
| Phase 6 | ä¸¦è¡Œå®Ÿè¡Œ + ãƒ©ã‚¤ãƒ–ãƒ©ãƒª | 2é€±é–“ | 2026å¹´2æœˆ15æ—¥ |
| **åˆè¨ˆ** | | **16é€±é–“** | **2026å¹´2æœˆä¸­æ—¬** |

**ãƒªãƒªãƒ¼ã‚¹ç›®æ¨™**: 2026å¹´2æœˆä¸­æ—¬

**æ³¨**: ã“ã‚Œã¯ã‹ãªã‚Šå¤§è¦æ¨¡ãªå®Ÿè£…ã§ã™ã€‚æ®µéšçš„ã«ãƒªãƒªãƒ¼ã‚¹ã™ã‚‹ã“ã¨ã‚‚æ¤œè¨ã§ãã¾ã™ï¼š
- **v0.11.0-alpha**: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ + Event Loopï¼ˆ2025å¹´12æœˆï¼‰
- **v0.11.0-beta**: Future + Resultå‹ï¼ˆ2026å¹´1æœˆï¼‰
- **v0.11.0**: async/awaitå®Œå…¨ç‰ˆï¼ˆ2026å¹´2æœˆï¼‰

**A**: å®Œå…¨ã«å¾Œæ–¹äº’æ›ï¼š
- async/awaitã¯æ–°ã—ã„æ§‹æ–‡ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ãªã—ï¼‰
- æ—¢å­˜ã®åŒæœŸé–¢æ•°ã¯ãã®ã¾ã¾å‹•ä½œ
- asyncé–¢æ•°ã¨åŒæœŸé–¢æ•°ã‚’æ··åœ¨å¯èƒ½
- æ®µéšçš„ãªç§»è¡ŒãŒå¯èƒ½

### Q5: Resultå‹ã¨try-catchã¯ã©ã†ä½¿ã„åˆ†ã‘ã‚‹ï¼Ÿ

**A**: ä»¥ä¸‹ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æ¨å¥¨ï¼š

**Resultå‹ã‚’ä½¿ã†ã¹ãå ´åˆ**ï¼ˆæ¨å¥¨ï¼‰ï¼š
- âœ… é€šå¸¸ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãªã©ï¼‰
- âœ… äºˆæ¸¬å¯èƒ½ãªã‚¨ãƒ©ãƒ¼
- âœ… ã‚¨ãƒ©ãƒ¼ãŒæˆ»ã‚Šå€¤ã®ä¸€éƒ¨ã¨ã—ã¦æ‰±ãˆã‚‹å ´åˆ
- âœ… å‹å®‰å…¨æ€§ã‚’é‡è¦–ã™ã‚‹å ´åˆ
- âœ… ã‚¨ãƒ©ãƒ¼ä¼æ’­ã‚’æ˜ç¤ºçš„ã«ã—ãŸã„å ´åˆï¼ˆ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰

**try-catchã‚’ä½¿ã†å ´åˆ**ï¼ˆé™å®šçš„ï¼‰ï¼š
- âš ï¸ unwrap/expectã«ã‚ˆã‚‹ãƒ‘ãƒ‹ãƒƒã‚¯ï¼ˆé–‹ç™ºæ™‚ã®ã¿ï¼‰
- âš ï¸ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ï¼ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒã‚°ãªã©ï¼‰
- âš ï¸ ãƒ¬ã‚¬ã‚·ãƒ¼ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§

**æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³**ï¼š
```cb
// âœ… æ¨å¥¨: Resultå‹ã§æ˜ç¤ºçš„ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
async Result<User, DbError> fetch_user(int id) {
    if (id <= 0) {
        return Err(DbError{"Invalid ID"});
    }
    // ...
    return Ok(user);
}

// âš ï¸ éæ¨å¥¨: try-catchã¯æœ€å°é™ã«
async User fetch_user_legacy(int id) {
    if (id <= 0) {
        throw DbError{"Invalid ID"};  // é¿ã‘ã‚‹ã¹ã
    }
    // ...
    return user;
}

// âœ… Resultå‹ã®ä½¿ç”¨ä¾‹
async void main() {
    Result<User, DbError> result = await fetch_user(1);
    match (result) {
        Ok(user) => println("User: ", user.name),
        Err(error) => println("Error: ", error.message)
    }
}
```

**åˆ©ç‚¹**ï¼š
- ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¼ã‚Œã‚’æ¤œå‡º
- ã‚¨ãƒ©ãƒ¼ã®å‹ãŒæ˜ç¢º
- ã‚¨ãƒ©ãƒ¼ä¼æ’­ãŒè¿½è·¡ã—ã‚„ã™ã„
- ä¸è¦ãªtry-catchãƒ–ãƒ­ãƒƒã‚¯ã‚’é¿ã‘ã‚‰ã‚Œã‚‹

---

## ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

### ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ
1. **async/awaitä»•æ§˜æ›¸**ï¼ˆæœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®è©³ç´°ç‰ˆï¼‰
2. **Event Loopè¨­è¨ˆæ›¸**
3. **Futureå‹ã®APIä»•æ§˜**
4. **Resultå‹ã®APIä»•æ§˜**
5. **ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ä»•æ§˜æ›¸**ï¼ˆasync/awaitå‘ã‘ã®æœ€å°é™ã®æ©Ÿèƒ½ï¼‰
6. **ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«**: async/awaitã®ä½¿ã„æ–¹

### å®Ÿè£…é–‹å§‹ï¼ˆæ¨å¥¨é †åºï¼‰
1. **Phase 0: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®åŸºæœ¬å®Ÿè£…**ï¼ˆ4é€±é–“ï¼‰
   - ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æ§‹é€ ä½“ï¼ˆ`Future<T>`ç”¨ï¼‰
   - ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Enumï¼ˆ`Result<T, E>`ç”¨ï¼‰
   - åŸºæœ¬çš„ãªå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
2. **Phase 1: Event Loop + ã‚¿ã‚¤ãƒãƒ¼**ï¼ˆ2é€±é–“ï¼‰
3. **Phase 2: Future<T>å‹**ï¼ˆ1é€±é–“ï¼‰
4. **Phase 3: Result<T, E> + ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°**ï¼ˆ3é€±é–“ï¼‰
5. **Phase 4: async/awaitæ§‹æ–‡**ï¼ˆ3é€±é–“ï¼‰
6. **Phase 5: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼**ï¼ˆ1é€±é–“ï¼‰

**åˆè¨ˆè¦‹ç©ã‚‚ã‚Š**: ç´„14é€±é–“ï¼ˆ3.5ãƒ¶æœˆï¼‰

### ãƒªãƒªãƒ¼ã‚¹è¨ˆç”»

**v0.11.0ã®å¯¾è±¡**:
- âœ… ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆåŸºæœ¬æ©Ÿèƒ½ã®ã¿ï¼‰
- âœ… Event Loop
- âœ… Future<T>å‹
- âœ… Result<T, E>å‹
- âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
- âœ… async/awaitæ§‹æ–‡
- âœ… ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼

**v0.11.1ã§è¿½åŠ äºˆå®š**:
- ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®å‹åˆ¶ç´„
- ã‚¸ã‚§ãƒãƒªãƒƒã‚¯Interface
- ã‚ˆã‚Šè¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°

**v0.12.0ã§è¿½åŠ äºˆå®š**:
- ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«
- ãƒãƒ£ãƒãƒ«
- å‹æ¨è«–

### ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
- æœ¬è¨­è¨ˆæ›¸ã‚’GitHubã§å…¬é–‹
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†
- ä»•æ§˜ã®æ”¹å–„ã¨èª¿æ•´

---

**ä½œæˆè€…**: GitHub Copilot  
**ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼**: shadowlink0122  
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: è¨­è¨ˆææ¡ˆä¸­
