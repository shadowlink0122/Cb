# T&& 完全実装ロードマップ (v0.10.1 / v0.11.0)

## 現在の状態 (v0.10.0)

✅ **構文レベル完了** (100%)
- パース機能
- 型チェック
- データ構造

❌ **セマンティクスレベル未完成** (0%)
- メンバーアクセス
- 代入
- エイリアシング

---

## 実装計画

### Phase 1: アーキテクチャ設計 (2時間)

#### 1.1 参照マップの設計
```cpp
class Interpreter {
private:
    // スコープごとの参照マップ
    std::vector<std::map<std::string, std::string>> reference_maps_;
    
public:
    // 参照解決（再帰的）
    std::string resolve_reference(const std::string& name);
    
    // 参照登録
    void register_reference(const std::string& ref_name, 
                           const std::string& target_name);
    
    // スコープ管理
    void push_reference_scope();
    void pop_reference_scope();
};
```

#### 1.2 スコープ管理との統合
- `push_scope()` と `pop_scope()` で参照マップも管理
- スコープ終了時に参照マップもクリーンアップ

---

### Phase 2: コア実装 (3時間)

#### 2.1 Interpreter クラスの拡張

**ファイル**: `src/backend/interpreter/core/interpreter.h`
```cpp
// Private メンバー追加
std::vector<std::map<std::string, std::string>> reference_maps_;

// Public メソッド追加
std::string resolve_reference(const std::string& name);
void register_reference(const std::string& ref_name, const std::string& target_name);
```

**ファイル**: `src/backend/interpreter/core/interpreter.cpp`
```cpp
std::string Interpreter::resolve_reference(const std::string& name) {
    // 現在のスコープから親スコープへと検索
    for (int i = reference_maps_.size() - 1; i >= 0; --i) {
        auto it = reference_maps_[i].find(name);
        if (it != reference_maps_[i].end()) {
            // 再帰的に解決（参照の参照のケース）
            return resolve_reference(it->second);
        }
    }
    // 参照でない場合は元の名前を返す
    return name;
}

void Interpreter::register_reference(const std::string& ref_name, 
                                     const std::string& target_name) {
    if (reference_maps_.empty()) {
        reference_maps_.push_back({});
    }
    reference_maps_.back()[ref_name] = target_name;
}
```

#### 2.2 スコープ管理の統合

**ファイル**: `src/backend/interpreter/core/interpreter.cpp`
```cpp
void Interpreter::push_scope() {
    // 既存のコード
    scope_stack.push_back(Scope());
    
    // 参照マップのスコープを追加
    reference_maps_.push_back({});
}

void Interpreter::pop_scope() {
    // 既存のコード
    // ... デストラクタ呼び出し等 ...
    scope_stack.pop_back();
    
    // 参照マップのスコープを削除
    if (!reference_maps_.empty()) {
        reference_maps_.pop_back();
    }
}
```

#### 2.3 参照変数の登録

**ファイル**: `src/backend/interpreter/managers/variables/declaration.cpp`
```cpp
// 行 1804-1827 付近を修正
if ((var.is_reference || var.is_rvalue_reference) && source_var) {
    // 参照マップに登録
    interpreter_->register_reference(node->name, source_var_name);
    
    // 注: 変数テーブルには最小限の情報のみ保存
    Variable ref_var;
    ref_var.name = node->name;
    ref_var.type = source_var->type;
    ref_var.is_reference = true;
    ref_var.is_rvalue_reference = var.is_rvalue_reference;
    ref_var.reference_target = source_var_name;
    
    interpreter_->current_scope().variables[node->name] = ref_var;
}
```

---

### Phase 3: メンバーアクセスの修正 (2時間)

#### 3.1 単純なメンバーアクセス

**ファイル**: `src/backend/interpreter/evaluator/access/member.cpp`
```cpp
// 行 563 付近を修正
int64_t ExpressionEvaluator::evaluate_member_access_impl(const ASTNode *node) {
    std::string var_name;
    std::string member_name = node->name;
    
    // ... 既存のコード ...
    
    if (node->left->node_type == ASTNodeType::AST_VARIABLE) {
        var_name = node->left->name;
        
        // ★ 参照を解決
        var_name = interpreter_.resolve_reference(var_name);
    }
    
    // 以降は通常のメンバーアクセス処理
    // ...
}
```

#### 3.2 ネストメンバーアクセス

**ファイル**: `src/backend/interpreter/evaluator/access/member.cpp`
```cpp
// member_chain パス内でも参照解決
if (!has_arrow_or_deref && !node->member_chain.empty()) {
    std::string base_name = node->left->name;
    
    // ★ 参照を解決
    base_name = interpreter_.resolve_reference(base_name);
    
    Variable *var = interpreter_.find_variable(base_name);
    // ...
}
```

#### 3.3 sync_struct_members での参照解決

**ファイル**: `src/backend/interpreter/managers/structs/sync.cpp`
```cpp
void StructSyncManager::sync_struct_members_from_direct_access(
    const std::string &var_name) {
    
    // ★ 参照を解決
    std::string resolved_name = interpreter_->resolve_reference(var_name);
    
    Variable *var = interpreter_->find_variable(resolved_name);
    // ...
}
```

---

### Phase 4: 代入の修正 (2時間)

#### 4.1 メンバー代入

**ファイル**: `src/backend/interpreter/executors/assignments/member_assignment.cpp`
```cpp
void StatementExecutor::execute_member_assignment_impl(...) {
    // メンバーアクセスノードから変数名を取得
    std::string var_name = /* ... */;
    
    // ★ 参照を解決
    var_name = interpreter_.resolve_reference(var_name);
    
    // 以降は通常の代入処理
    // ...
}
```

#### 4.2 単純な代入

**ファイル**: `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
```cpp
void StatementExecutor::execute_simple_assignment_impl(...) {
    std::string var_name = node->name;
    
    // ★ 参照を解決
    var_name = interpreter_.resolve_reference(var_name);
    
    Variable *var = interpreter_.find_variable(var_name);
    // ...
}
```

---

### Phase 5: テストとデバッグ (3時間)

#### 5.1 既存テストの実行
```bash
make test
```
既存の機能が壊れていないことを確認。

#### 5.2 参照テストの更新

**更新が必要なテスト**:
- `tests/cases/rvalue_reference/member_access.cb`
- `tests/cases/rvalue_reference/member_assignment.cb`
- `tests/cases/rvalue_reference/aliasing.cb`

各テストで `❌ FAIL` → `✅ PASS` になることを確認。

#### 5.3 エッジケースのテスト作成

**新規テストケース**:
1. **参照の参照**
```cb
Point p1;
Point&& ref1 = p1;
Point&& ref2 = ref1;  // ref2 → ref1 → p1
ref2.x = 100;
assert(p1.x == 100);
```

2. **スコープをまたぐ参照**
```cb
Point p1;
{
    Point&& ref = p1;
    ref.x = 100;
}
assert(p1.x == 100);
```

3. **配列メンバーへの参照**
```cb
struct Data { int[10] arr; };
Data d;
Data&& ref = d;
ref.arr[0] = 42;
assert(d.arr[0] == 42);
```

4. **ネストした構造体への参照**
```cb
struct Inner { int x; };
struct Outer { Inner inner; };
Outer o;
Outer&& ref = o;
ref.inner.x = 99;
assert(o.inner.x == 99);
```

---

### Phase 6: ドキュメントとリリース (1時間)

#### 6.1 ドキュメント更新
- `docs/todo/v0.10.0_rvalue_reference_status.md` → 完了マーク
- `release_notes/v0.10.1.md` 作成
- `README.md` に機能を追加

#### 6.2 コミットとリリース
```bash
git add .
git commit -m "feat(v0.10.1): Complete T&& reference semantics implementation"
git push origin feature/v0.10.0
```

---

## 予想される困難と対策

### 困難1: 複数のメンバーアクセスパス
**問題**: member.cpp には複数の異なるパスがある  
**対策**: `resolve_reference()` を早い段階で呼び出す統一的なアプローチ

### 困難2: パフォーマンスへの影響
**問題**: 全てのアクセスで参照解決が必要  
**対策**: 
- インライン関数化
- 参照でない場合は早期リターン
- 必要に応じてキャッシュ

### 困難3: グローバル変数への参照
**問題**: スコープスタックとグローバルスコープの扱い  
**対策**: reference_maps_[0] をグローバル参照マップとして予約

---

## タイムライン

| Phase | 内容 | 推定時間 | 累積時間 |
|-------|------|----------|----------|
| 1 | アーキテクチャ設計 | 2h | 2h |
| 2 | コア実装 | 3h | 5h |
| 3 | メンバーアクセス修正 | 2h | 7h |
| 4 | 代入修正 | 2h | 9h |
| 5 | テストとデバッグ | 3h | 12h |
| 6 | ドキュメントとリリース | 1h | 13h |

**合計**: 約 13 時間（バッファ含む）

---

## チェックリスト

### Phase 1: 設計
- [ ] 参照マップのデータ構造設計
- [ ] スコープ管理との統合方法決定
- [ ] API設計（resolve_reference, register_reference）

### Phase 2: コア実装
- [ ] Interpreter::resolve_reference() 実装
- [ ] Interpreter::register_reference() 実装
- [ ] push_scope() / pop_scope() の修正
- [ ] 参照変数登録の修正

### Phase 3: メンバーアクセス
- [ ] 単純なメンバーアクセス修正
- [ ] ネストメンバーアクセス修正
- [ ] sync_struct_members での参照解決
- [ ] 全メンバーアクセスパスの確認

### Phase 4: 代入
- [ ] メンバー代入の修正
- [ ] 単純な代入の修正
- [ ] 複合代入の修正（+=, -= 等）

### Phase 5: テスト
- [ ] 既存テストスイート実行
- [ ] 参照テストの更新
- [ ] エッジケーステストの作成
- [ ] パフォーマンステスト

### Phase 6: リリース
- [ ] ドキュメント更新
- [ ] リリースノート作成
- [ ] コミットとプッシュ
- [ ] バージョンタグ作成

---

## 成功基準

1. ✅ 全ての参照テストが PASS
2. ✅ 既存テストが壊れていない
3. ✅ パフォーマンス劣化が10%以内
4. ✅ メモリリークなし
5. ✅ ドキュメント完備

---

## リスク管理

| リスク | 確率 | 影響 | 対策 |
|--------|------|------|------|
| 既存機能の破壊 | 中 | 高 | 段階的な実装、頻繁なテスト |
| パフォーマンス劣化 | 低 | 中 | プロファイリング、最適化 |
| スコープ管理のバグ | 中 | 高 | 慎重な設計、デバッグログ |
| メモリリーク | 低 | 高 | Valgrind でのテスト |

---

## 次のステップ

v0.10.1 または v0.11.0 でこのロードマップに従って実装を開始してください。

**推奨**: まず Phase 1 の設計を完了させ、レビューを受けてから実装に進む。
