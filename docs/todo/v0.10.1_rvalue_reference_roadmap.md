# T&& 完全実装ロードマップ (v0.10.1)

## 現在の状態 (v0.10.0 完了時点)

### ✅ 完了した実装

#### 1. 構文レベル (100%)
- ✅ パース機能（`T&&` トークン認識）
- ✅ 型チェック（構造体のみT&&許可、プリミティブ型はT&）
- ✅ データ構造（`is_rvalue_reference`, `reference_target` フィールド）
- ✅ テストインフラ（12個の統合テスト作成）

#### 2. バグ修正
- ✅ **Critical**: `ParsedTypeInfo`の未初期化問題を修正
  - 問題: `is_rvalue_reference`にガーベジ値が残り、通常の変数宣言でもT&&エラーが発生
  - 解決: `parseType()`で明示的に`parsed.is_reference = false; parsed.is_rvalue_reference = false;`を設定
  - 影響: 全2582テストが成功

#### 3. コンストラクタ・デストラクタ実装（部分的）
- ✅ デフォルトコンストラクタ生成
- ✅ パラメータ付きコンストラクタ生成  
- ✅ デストラクタの基本実装
- ✅ コンストラクタ呼び出しの基本サポート

### ❌ v0.10.1で実装が必要な部分

#### 1. 参照セマンティクス（優先度：高）
- ❌ メンバーアクセス（`ref.x`が元の変数を更新しない）
- ❌ メンバー代入（`ref.x = 10`が元の変数に反映されない）
- ❌ エイリアシング（参照の参照が正しく動作しない）
- ❌ 参照マップの実装（変数名の解決機構）

#### 2. コンストラクタ・デストラクタの完全実装（優先度：中）
- ❌ コピーコンストラクタ（自動生成と呼び出し）
- ❌ ムーブコンストラクタ（move() 関数との統合）
- ❌ デストラクタの自動呼び出し（スコープ終了時、return時、break時）
- ❌ 初期化リスト構文のサポート
- ❌ メンバーワイズ初期化
- ❌ 継承時のコンストラクタチェーン

#### 3. move() 関数の完全実装（優先度：中）
- ❌ 実際のメモリ転送セマンティクス
- ❌ ムーブ後の元変数の無効化
- ❌ ムーブコンストラクタとの統合
- ❌ std::move相当の実装

#### 4. デストラクタの高度な機能（優先度：低）
- ❌ リソース管理（メモリ、ファイルハンドル等）
- ❌ 例外安全性
- ❌ 仮想デストラクタ（将来的に必要）

---

## v0.10.0で発見された技術的課題

### 課題1: ParsedTypeInfo の初期化順序問題

**問題の詳細**:
```cpp
// 問題のあったコード (type_utility_parser.cpp)
std::string TypeUtilityParser::parseType() {
    ParsedTypeInfo parsed;  // ← is_rvalue_referenceが未初期化の場合がある
    parsed.array_info = ArrayTypeInfo();
    // ... 処理 ...
}
```

**根本原因**:
- C++の構造体デフォルトコンストラクタでは、メンバー初期化子（`bool is_rvalue_reference = false;`）が設定されていても、コンパイラの最適化やメモリ配置の影響で初期化が不完全な場合がある
- 特に、スタック上のメモリに以前の値が残っている場合、`true`(1)のガーベジ値が読まれる

**解決策**:
```cpp
// 修正後のコード
std::string TypeUtilityParser::parseType() {
    ParsedTypeInfo parsed = ParsedTypeInfo();  // デフォルトコンストラクタを明示的に呼び出し
    parsed.array_info = ArrayTypeInfo();
    // 明示的な初期化を追加
    parsed.is_reference = false;
    parsed.is_rvalue_reference = false;
    // ... 処理 ...
}
```

**教訓**:
- C++では、メンバー初期化子があっても明示的な初期化が必要な場合がある
- 特に、bool型フラグは必ず明示的に初期化すること
- デバッグが困難な場合は、最小限のテストケースで再現を試みる

### 課題2: 参照変数の実装アプローチ

**現在の実装（v0.10.0）**:
```cpp
// declaration.cpp で参照変数を作成
if ((var.is_reference || var.is_rvalue_reference) && source_var) {
    Variable ref_var;
    ref_var.name = node->name;
    ref_var.type = source_var->type;
    ref_var.is_reference = true;
    ref_var.is_rvalue_reference = var.is_rvalue_reference;
    ref_var.reference_target = source_var_name;  // ★ 文字列で保存
    
    // 値をコピー（これが問題！）
    ref_var.value = source_var->value;
    // ...
}
```

**問題点**:
1. **値のコピー**: 参照変数に値をコピーしているため、元の変数との接続が切れる
2. **同期の欠如**: メンバーアクセス時に`reference_target`を使った解決がない
3. **スコープ管理**: 参照が有効なスコープを超えて使われる危険性

**v0.10.1での解決アプローチ**:
```cpp
// 参照マップを使った実装
class Interpreter {
    std::vector<std::map<std::string, std::string>> reference_maps_;
    
    std::string resolve_reference(const std::string& name) {
        // 再帰的に参照を解決
        for (int i = reference_maps_.size() - 1; i >= 0; --i) {
            auto it = reference_maps_[i].find(name);
            if (it != reference_maps_[i].end()) {
                return resolve_reference(it->second);  // 再帰
            }
        }
        return name;  // 参照でない場合は元の名前
    }
};
```

**利点**:
- メモリ効率: 実際の値はコピーせず、名前のマッピングのみ
- 同期の自動化: 常に最新の値にアクセス
- スコープ安全: スコープ終了時に自動的にマッピング削除

### 課題3: デストラクタの呼び出しタイミング

**未実装の呼び出しポイント**:
1. **通常のスコープ終了**
```cpp
{
    Point p;
    // ... 処理 ...
}  // ← ここでPoint::~Point()を呼ぶべき
```

2. **return文での早期リターン**
```cpp
Point create_point() {
    Point p1;
    if (condition) {
        return p1;  // ← ここまでのローカル変数のデストラクタを呼ぶべき
    }
    Point p2;
    return p2;
}
```

3. **break/continue でのループ脱出**
```cpp
for (int i = 0; i < 10; i++) {
    Point p;
    if (i == 5) {
        break;  // ← pのデストラクタを呼ぶべき
    }
}
```

4. **例外発生時（将来的に）**
```cpp
try {
    Point p;
    throw_error();  // ← pのデストラクタを呼ぶべき
} catch (...) {
    // ...
}
```

**v0.10.1での実装方針**:
- `pop_scope()`でスコープ内の全構造体変数のデストラクタを呼び出す
- return/break/continue時にも適切にデストラクタを呼び出す仕組みを追加

---

## 実装計画

### Phase 1: アーキテクチャ設計 (2時間)

#### 1.1 参照マップの設計
```cpp
class Interpreter {
private:
    // スコープごとの参照マップ
    std::vector<std::map<std::string, std::string>> reference_maps_;
    
public:
    // 参照解決（再帰的）
    std::string resolve_reference(const std::string& name);
    
    // 参照登録
    void register_reference(const std::string& ref_name, 
                           const std::string& target_name);
    
    // スコープ管理
    void push_reference_scope();
    void pop_reference_scope();
};
```

#### 1.2 スコープ管理との統合
- `push_scope()` と `pop_scope()` で参照マップも管理
- スコープ終了時に参照マップもクリーンアップ

---

### Phase 2: コア実装 (3時間)

#### 2.1 Interpreter クラスの拡張

**ファイル**: `src/backend/interpreter/core/interpreter.h`
```cpp
// Private メンバー追加
std::vector<std::map<std::string, std::string>> reference_maps_;

// Public メソッド追加
std::string resolve_reference(const std::string& name);
void register_reference(const std::string& ref_name, const std::string& target_name);
```

**ファイル**: `src/backend/interpreter/core/interpreter.cpp`
```cpp
std::string Interpreter::resolve_reference(const std::string& name) {
    // 現在のスコープから親スコープへと検索
    for (int i = reference_maps_.size() - 1; i >= 0; --i) {
        auto it = reference_maps_[i].find(name);
        if (it != reference_maps_[i].end()) {
            // 再帰的に解決（参照の参照のケース）
            return resolve_reference(it->second);
        }
    }
    // 参照でない場合は元の名前を返す
    return name;
}

void Interpreter::register_reference(const std::string& ref_name, 
                                     const std::string& target_name) {
    if (reference_maps_.empty()) {
        reference_maps_.push_back({});
    }
    reference_maps_.back()[ref_name] = target_name;
}
```

#### 2.2 スコープ管理の統合

**ファイル**: `src/backend/interpreter/core/interpreter.cpp`
```cpp
void Interpreter::push_scope() {
    // 既存のコード
    scope_stack.push_back(Scope());
    
    // 参照マップのスコープを追加
    reference_maps_.push_back({});
}

void Interpreter::pop_scope() {
    // 既存のコード
    // ... デストラクタ呼び出し等 ...
    scope_stack.pop_back();
    
    // 参照マップのスコープを削除
    if (!reference_maps_.empty()) {
        reference_maps_.pop_back();
    }
}
```

#### 2.3 参照変数の登録

**ファイル**: `src/backend/interpreter/managers/variables/declaration.cpp`
```cpp
// 行 1804-1827 付近を修正
if ((var.is_reference || var.is_rvalue_reference) && source_var) {
    // 参照マップに登録
    interpreter_->register_reference(node->name, source_var_name);
    
    // 注: 変数テーブルには最小限の情報のみ保存
    Variable ref_var;
    ref_var.name = node->name;
    ref_var.type = source_var->type;
    ref_var.is_reference = true;
    ref_var.is_rvalue_reference = var.is_rvalue_reference;
    ref_var.reference_target = source_var_name;
    
    interpreter_->current_scope().variables[node->name] = ref_var;
}
```

---

### Phase 3: メンバーアクセスの修正 (2時間)

#### 3.1 単純なメンバーアクセス

**ファイル**: `src/backend/interpreter/evaluator/access/member.cpp`
```cpp
// 行 563 付近を修正
int64_t ExpressionEvaluator::evaluate_member_access_impl(const ASTNode *node) {
    std::string var_name;
    std::string member_name = node->name;
    
    // ... 既存のコード ...
    
    if (node->left->node_type == ASTNodeType::AST_VARIABLE) {
        var_name = node->left->name;
        
        // ★ 参照を解決
        var_name = interpreter_.resolve_reference(var_name);
    }
    
    // 以降は通常のメンバーアクセス処理
    // ...
}
```

#### 3.2 ネストメンバーアクセス

**ファイル**: `src/backend/interpreter/evaluator/access/member.cpp`
```cpp
// member_chain パス内でも参照解決
if (!has_arrow_or_deref && !node->member_chain.empty()) {
    std::string base_name = node->left->name;
    
    // ★ 参照を解決
    base_name = interpreter_.resolve_reference(base_name);
    
    Variable *var = interpreter_.find_variable(base_name);
    // ...
}
```

#### 3.3 sync_struct_members での参照解決

**ファイル**: `src/backend/interpreter/managers/structs/sync.cpp`
```cpp
void StructSyncManager::sync_struct_members_from_direct_access(
    const std::string &var_name) {
    
    // ★ 参照を解決
    std::string resolved_name = interpreter_->resolve_reference(var_name);
    
    Variable *var = interpreter_->find_variable(resolved_name);
    // ...
}
```

---

### Phase 4: 代入の修正 (2時間)

#### 4.1 メンバー代入

**ファイル**: `src/backend/interpreter/executors/assignments/member_assignment.cpp`
```cpp
void StatementExecutor::execute_member_assignment_impl(...) {
    // メンバーアクセスノードから変数名を取得
    std::string var_name = /* ... */;
    
    // ★ 参照を解決
    var_name = interpreter_.resolve_reference(var_name);
    
    // 以降は通常の代入処理
    // ...
}
```

#### 4.2 単純な代入

**ファイル**: `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
```cpp
void StatementExecutor::execute_simple_assignment_impl(...) {
    std::string var_name = node->name;
    
    // ★ 参照を解決
    var_name = interpreter_.resolve_reference(var_name);
    
    Variable *var = interpreter_.find_variable(var_name);
    // ...
}
```

---

### Phase 5: テストとデバッグ (3時間)

#### 5.1 既存テストの実行
```bash
make test
```
既存の機能が壊れていないことを確認。

#### 5.2 参照テストの更新

**更新が必要なテスト**:
- `tests/cases/rvalue_reference/member_access.cb`
- `tests/cases/rvalue_reference/member_assignment.cb`
- `tests/cases/rvalue_reference/aliasing.cb`

各テストで `❌ FAIL` → `✅ PASS` になることを確認。

#### 5.3 エッジケースのテスト作成

**新規テストケース**:
1. **参照の参照**
```cb
Point p1;
Point&& ref1 = p1;
Point&& ref2 = ref1;  // ref2 → ref1 → p1
ref2.x = 100;
assert(p1.x == 100);
```

2. **スコープをまたぐ参照**
```cb
Point p1;
{
    Point&& ref = p1;
    ref.x = 100;
}
assert(p1.x == 100);
```

3. **配列メンバーへの参照**
```cb
struct Data { int[10] arr; };
Data d;
Data&& ref = d;
ref.arr[0] = 42;
assert(d.arr[0] == 42);
```

4. **ネストした構造体への参照**
```cb
struct Inner { int x; };
struct Outer { Inner inner; };
Outer o;
Outer&& ref = o;
ref.inner.x = 99;
assert(o.inner.x == 99);
```

---

### Phase 6: ドキュメントとリリース (1時間)

#### 6.1 ドキュメント更新
- `docs/todo/v0.10.0_rvalue_reference_status.md` → 完了マーク
- `release_notes/v0.10.1.md` 作成
- `README.md` に機能を追加

#### 6.2 コミットとリリース
```bash
git add .
git commit -m "feat(v0.10.1): Complete T&& reference semantics implementation"
git push origin feature/v0.10.0
```

---

## 予想される困難と対策

### 困難1: 複数のメンバーアクセスパス
**問題**: member.cpp には複数の異なるパスがある  
**対策**: `resolve_reference()` を早い段階で呼び出す統一的なアプローチ

### 困難2: パフォーマンスへの影響
**問題**: 全てのアクセスで参照解決が必要  
**対策**: 
- インライン関数化
- 参照でない場合は早期リターン
- 必要に応じてキャッシュ

### 困難3: グローバル変数への参照
**問題**: スコープスタックとグローバルスコープの扱い  
**対策**: reference_maps_[0] をグローバル参照マップとして予約

---

## タイムライン

| Phase | 内容 | 推定時間 | 累積時間 |
|-------|------|----------|----------|
| 1 | アーキテクチャ設計 | 2h | 2h |
| 2 | コア実装 | 3h | 5h |
| 3 | メンバーアクセス修正 | 2h | 7h |
| 4 | 代入修正 | 2h | 9h |
| 5 | テストとデバッグ | 3h | 12h |
| 6 | ドキュメントとリリース | 1h | 13h |

**合計**: 約 13 時間（バッファ含む）

---

## チェックリスト

### Phase 1: 設計
- [ ] 参照マップのデータ構造設計
- [ ] スコープ管理との統合方法決定
- [ ] API設計（resolve_reference, register_reference）

### Phase 2: コア実装
- [ ] Interpreter::resolve_reference() 実装
- [ ] Interpreter::register_reference() 実装
- [ ] push_scope() / pop_scope() の修正
- [ ] 参照変数登録の修正

### Phase 3: メンバーアクセス
- [ ] 単純なメンバーアクセス修正
- [ ] ネストメンバーアクセス修正
- [ ] sync_struct_members での参照解決
- [ ] 全メンバーアクセスパスの確認

### Phase 4: 代入
- [ ] メンバー代入の修正
- [ ] 単純な代入の修正
- [ ] 複合代入の修正（+=, -= 等）

### Phase 5: テスト
- [ ] 既存テストスイート実行
- [ ] 参照テストの更新
- [ ] エッジケーステストの作成
- [ ] パフォーマンステスト

### Phase 6: リリース
- [ ] ドキュメント更新
- [ ] リリースノート作成
- [ ] コミットとプッシュ
- [ ] バージョンタグ作成

---

## 成功基準

1. ✅ 全ての参照テストが PASS
2. ✅ 既存テストが壊れていない
3. ✅ パフォーマンス劣化が10%以内
4. ✅ メモリリークなし
5. ✅ ドキュメント完備

---

## リスク管理

| リスク | 確率 | 影響 | 対策 |
|--------|------|------|------|
| 既存機能の破壊 | 中 | 高 | 段階的な実装、頻繁なテスト |
| パフォーマンス劣化 | 低 | 中 | プロファイリング、最適化 |
| スコープ管理のバグ | 中 | 高 | 慎重な設計、デバッグログ |
| メモリリーク | 低 | 高 | Valgrind でのテスト |

---

## 次のステップ

v0.10.1 または v0.11.0 でこのロードマップに従って実装を開始してください。

**推奨**: まず Phase 1 の設計を完了させ、レビューを受けてから実装に進む。
