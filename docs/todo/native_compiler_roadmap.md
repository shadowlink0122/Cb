# Cb言語 ネイティブコンパイラ実装ロードマップ

**作成日**: 2025-11-13
**ステータス**: 計画段階

## 概要

このドキュメントは、Cb言語のネイティブコンパイラ実装に向けた段階的なロードマップを示します。v0.16.0からv1.0.0までの各バージョンで実装すべき機能を定義します。

## 全体戦略

```
v0.13.0-v0.15.0: インタプリタの完成
    ↓
v0.16.0-v0.20.0: コンパイラ基盤の構築
    ↓
v1.0.0: ネイティブコンパイラの完成
```

## バージョン別実装計画

### v0.14.0 - 標準ライブラリの拡充

**目標**: インタプリタ版の標準ライブラリを充実させる

#### 主要機能
- [ ] **ファイルI/O**
  - `File`, `FileReader`, `FileWriter`
  - バイナリI/O対応
  - ストリーム処理

- [ ] **ネットワーク**
  - TCPクライアント/サーバー
  - HTTPクライアント
  - WebSocketサポート

- [ ] **並行処理の強化**
  - スレッドプール
  - チャネル（CSP）
  - Mutex/RWLock

- [ ] **コレクションの拡張**
  - `HashMap`, `HashSet`
  - `LinkedList`, `Deque`
  - `BinaryHeap`, `BTreeMap`

**実装期間**: 2-3ヶ月

---

### v0.15.0 - パフォーマンスとエラーハンドリング

**目標**: インタプリタのパフォーマンス向上と堅牢性強化

#### 主要機能
- [ ] **インタプリタ最適化**
  - ASTキャッシング
  - バイトコード生成（オプション）
  - 関数呼び出しの最適化

- [ ] **エラーハンドリング強化**
  - スタックトレースの改善
  - エラーメッセージの詳細化
  - パニックハンドラ

- [ ] **デバッグ機能**
  - `debug()`組み込み関数
  - メモリ使用量の監視
  - プロファイリング機能

- [ ] **テスト機能**
  - ユニットテストフレームワーク
  - アサーション関数
  - モックサポート

**実装期間**: 2-3ヶ月

---

### v0.16.0 - IR (Intermediate Representation) 設計と実装

**目標**: コンパイラの中間表現を設計・実装する

#### 主要機能

##### 1. HIR (High-level IR) - 高レベル中間表現
- [ ] **ASTからHIRへの変換**
  - 型情報の保持
  - 制御フロー構造の保持
  - スコープ情報の保持

- [ ] **HIR構造**
  ```rust
  // 例: HIR定義（Rust風の疑似コード）
  enum HIRExpr {
      Literal(Literal),
      Variable(Symbol),
      BinaryOp(BinOp, Box<HIRExpr>, Box<HIRExpr>),
      FunctionCall(Symbol, Vec<HIRExpr>),
      If(Box<HIRExpr>, Block, Option<Block>),
      // ...
  }
  ```

- [ ] **型チェックとの統合**
  - HIR上での型推論
  - ジェネリクスの単相化（Monomorphization）

##### 2. MIR (Mid-level IR) - 中レベル中間表現
- [ ] **HIRからMIRへの変換**
  - 制御フローグラフ (CFG) 生成
  - SSA形式への変換
  - 基本ブロックの構築

- [ ] **MIR構造**
  ```rust
  // 例: MIR定義
  struct BasicBlock {
      statements: Vec<Statement>,
      terminator: Terminator,
  }

  enum Statement {
      Assign(Place, Rvalue),
      StorageLive(Local),
      StorageDead(Local),
  }

  enum Terminator {
      Goto(BasicBlock),
      SwitchInt(Operand, Vec<(u128, BasicBlock)>),
      Return,
      Call(Function, Vec<Operand>, BasicBlock),
  }
  ```

- [ ] **データフロー解析基盤**
  - 生存変数解析
  - 到達定義解析
  - 使用-定義チェーン

##### 3. LIR (Low-level IR) - 低レベル中間表現
- [ ] **MIRからLIRへの変換**
  - ターゲット非依存の低レベル命令
  - レジスタ割り当て準備
  - 呼び出し規約の適用

- [ ] **LIR構造**
  ```rust
  // 例: LIR定義
  enum LIRInstruction {
      Move(Operand, Operand),
      Add(Operand, Operand, Operand),
      Load(Operand, Address),
      Store(Address, Operand),
      Call(Label, Vec<Operand>),
      Jump(Label),
      CondJump(Condition, Label),
      Return(Option<Operand>),
  }
  ```

##### 4. IRビューワー
- [ ] **デバッグツール**
  - HIR/MIR/LIRの可視化
  - 各IRレベルでのダンプ出力
  - GraphVizによるCFG可視化

**実装期間**: 3-4ヶ月

**成果物**:
- IR設計ドキュメント
- HIR/MIR/LIR実装
- IRユニットテスト

---

### v0.17.0 - 基本的な最適化パス

**目標**: MIR上での基本的な最適化を実装する

#### 主要機能

##### 1. 定数関連の最適化
- [ ] **定数畳み込み (Constant Folding)**
  ```cb
  // 最適化前
  int x = 2 + 3 * 4;

  // 最適化後
  int x = 14;
  ```

- [ ] **定数伝播 (Constant Propagation)**
  ```cb
  // 最適化前
  int x = 10;
  int y = x + 5;

  // 最適化後
  int x = 10;
  int y = 15;
  ```

##### 2. デッドコード除去
- [ ] **到達不可能コードの削除**
  ```cb
  // 最適化前
  if (true) {
      println("A");
  } else {
      println("B");  // 削除される
  }

  // 最適化後
  println("A");
  ```

- [ ] **未使用変数の削除**
  ```cb
  // 最適化前
  int x = compute();  // xが使われない
  int y = 10;
  println(y);

  // 最適化後
  int y = 10;
  println(y);
  ```

##### 3. 共通部分式除去 (CSE)
- [ ] **重複計算の削除**
  ```cb
  // 最適化前
  int a = x * y + 1;
  int b = x * y + 2;

  // 最適化後
  int temp = x * y;
  int a = temp + 1;
  int b = temp + 2;
  ```

##### 4. 強度削減 (Strength Reduction)
- [ ] **高コスト演算の低コスト化**
  ```cb
  // 最適化前
  int x = y * 2;
  int z = a / 4;

  // 最適化後
  int x = y << 1;
  int z = a >> 2;
  ```

##### 5. ループ不変式の移動 (LICM)
- [ ] **ループ内の不変計算を外に移動**
  ```cb
  // 最適化前
  for (int i = 0; i < n; i++) {
      int temp = x * y;  // ループ不変
      arr[i] = temp + i;
  }

  // 最適化後
  int temp = x * y;
  for (int i = 0; i < n; i++) {
      arr[i] = temp + i;
  }
  ```

##### 6. 最適化パイプライン
- [ ] **最適化パスの順序制御**
  - `-O0`: 最適化なし
  - `-O1`: 基本的な最適化
  - `-O2`: 積極的な最適化
  - `-O3`: 最大限の最適化

**実装期間**: 3-4ヶ月

**成果物**:
- 最適化パス実装
- 最適化前後のベンチマーク
- 最適化ドキュメント

---

### v0.18.0 - コード生成基盤

**目標**: ターゲットアーキテクチャ向けのコード生成を実装する

#### 主要機能

##### 1. ターゲット抽象化
- [ ] **ターゲット情報の定義**
  ```rust
  struct Target {
      triple: String,        // e.g., "x86_64-unknown-linux-gnu"
      pointer_width: usize,  // 32 or 64
      endian: Endian,
      calling_convention: CallingConvention,
  }
  ```

- [ ] **初期対応ターゲット**
  - x86-64 (Linux, macOS, Windows)
  - ARM64 (macOS, Linux)

##### 2. レジスタ割り当て
- [ ] **リニアスキャンレジスタ割り当て**
  - 生存区間解析
  - レジスタ/スタック割り当て
  - スピルコード生成

- [ ] **呼び出し規約の実装**
  - System V AMD64 ABI (Linux, macOS)
  - Microsoft x64 calling convention (Windows)
  - AAPCS64 (ARM64)

##### 3. アセンブリ生成
- [ ] **x86-64アセンブリ生成**
  - AT&T構文（GNU as）
  - Intel構文（オプション）
  - セクション管理（.text, .data, .bss）

- [ ] **ARM64アセンブリ生成**
  - 基本的な命令セット
  - NEON命令（将来）

##### 4. 命令選択
- [ ] **LIRから機械語への変換**
  - パターンマッチング
  - 命令融合（複数のLIR命令を1つの機械語命令に）
  - ピープホール最適化

##### 5. オブジェクトファイル生成
- [ ] **外部アセンブラ/リンカーの使用**
  - GNU as + ld (Linux)
  - clang (macOS)
  - MSVC link (Windows)

- [ ] **直接オブジェクトファイル生成（将来）**
  - ELF形式 (Linux)
  - Mach-O形式 (macOS)
  - PE形式 (Windows)

**実装期間**: 4-5ヶ月

**成果物**:
- x86-64コード生成
- ARM64コード生成（基本）
- "Hello World"のネイティブコンパイル成功

---

### v0.19.0 - リンカー統合とランタイム

**目標**: 実行ファイル生成とランタイムライブラリを実装する

#### 主要機能

##### 1. リンカー統合
- [ ] **静的リンク**
  - オブジェクトファイルの結合
  - シンボル解決
  - 再配置処理

- [ ] **動的リンク**
  - 共有ライブラリの使用
  - PLT/GOT生成
  - 動的ローダー対応

- [ ] **リンカースクリプト生成**
  - メモリレイアウト定義
  - セクション配置

##### 2. ランタイムライブラリ
- [ ] **メモリ管理**
  - カスタムアロケータ（malloc/free相当）
  - ガベージコレクタ（参照カウントまたはマークスイープ）
  - メモリプール

- [ ] **標準ライブラリのネイティブ実装**
  - 文字列操作
  - コレクション（Vec, HashMap等）
  - ファイルI/O
  - ネットワーク

- [ ] **パニックハンドラ**
  - スタックトレース生成
  - エラーメッセージ表示
  - クリーンアップ処理

##### 3. C互換性
- [ ] **C言語との相互運用**
  - C関数の呼び出し
  - Cライブラリのリンク
  - C構造体の受け渡し

- [ ] **FFIランタイムサポート**
  - 動的ライブラリロード
  - 型変換

##### 4. 起動コード
- [ ] **エントリポイント**
  - `_start`関数生成
  - グローバル変数の初期化
  - `main`関数の呼び出し
  - 終了コード処理

**実装期間**: 3-4ヶ月

**成果物**:
- 実行ファイル生成
- ランタイムライブラリ
- 基本的なプログラムの動作確認

---

### v0.20.0 - 高度な最適化とツールチェーン

**目標**: 本格的な最適化とコンパイラツールチェーンを完成させる

#### 主要機能

##### 1. 高度な最適化
- [ ] **関数インライン展開**
  - インライン候補の分析
  - コストベース決定
  - 再帰関数の処理

- [ ] **ループ最適化**
  - ループ展開
  - ループ融合
  - ループ交換
  - ベクトル化（SIMD）

- [ ] **グローバル最適化**
  - インライン関数解析（IPA）
  - デッドコード削除（グローバル）
  - 定数伝播（グローバル）

- [ ] **リンク時最適化 (LTO)**
  - 全プログラム最適化
  - クロスモジュール最適化

##### 2. デバッグ情報生成
- [ ] **DWARF形式サポート**
  - 行番号情報
  - 変数情報
  - 型情報
  - スコープ情報

- [ ] **デバッガ対応**
  - GDB対応
  - LLDB対応

##### 3. ビルドシステム
- [ ] **ビルドツール**
  ```bash
  cb build              # プロジェクトをビルド
  cb run                # ビルドして実行
  cb test               # テスト実行
  cb clean              # クリーンアップ
  ```

- [ ] **プロジェクト構造**
  ```
  project/
  ├── cb.toml          # プロジェクト設定
  ├── src/
  │   └── main.cb
  ├── tests/
  └── build/
  ```

- [ ] **依存関係管理**
  - パッケージマネージャー（基本機能）
  - バージョン管理
  - ビルドキャッシュ

##### 4. プロファイリングとベンチマーク
- [ ] **プロファイラ**
  - CPU時間測定
  - メモリ使用量測定
  - ホットスポット検出

- [ ] **ベンチマークフレームワーク**
  - マイクロベンチマーク
  - 統計分析
  - 比較機能

##### 5. コンパイラオプション
- [ ] **最適化レベル**
  - `-O0`: 最適化なし（デバッグ用）
  - `-O1`: 基本的な最適化
  - `-O2`: 推奨レベル
  - `-O3`: 最大限の最適化
  - `-Os`: サイズ最適化

- [ ] **デバッグオプション**
  - `-g`: デバッグ情報生成
  - `-g0`: デバッグ情報なし
  - `-gdwarf-5`: DWARF v5形式

- [ ] **その他のオプション**
  - `--target`: ターゲット指定
  - `--emit`: 出力形式指定（asm, obj, exe）
  - `--verbose`: 詳細出力

**実装期間**: 4-5ヶ月

**成果物**:
- 完全なツールチェーン
- ベンチマークスイート
- パフォーマンスレポート

---

### v1.0.0 - ネイティブコンパイラの完成

**目標**: 安定した本番利用可能なネイティブコンパイラをリリースする

#### 最終チェック
- [ ] **機能完全性**
  - すべての言語機能のサポート
  - FFI完全対応
  - 標準ライブラリ完成

- [ ] **品質保証**
  - 1000+のテストケース
  - コードカバレッジ > 90%
  - メモリリークゼロ

- [ ] **パフォーマンス**
  - Cコンパイラとの比較
  - ベンチマークでの検証
  - パフォーマンスドキュメント

- [ ] **ドキュメント**
  - 言語仕様書
  - コンパイラ実装ガイド
  - チュートリアル
  - APIリファレンス

- [ ] **クロスプラットフォーム**
  - Linux (x86-64, ARM64)
  - macOS (x86-64, ARM64)
  - Windows (x86-64)

- [ ] **インラインアセンブリ**
  - `asm("")` 構文の実装
  - プラットフォーム固有の最適化

**実装期間**: 2-3ヶ月（最終調整）

**成果物**:
- Cb v1.0.0ネイティブコンパイラ
- 完全なドキュメント
- 公式リリース

---

## 技術スタック

### コンパイラ実装
- **言語**: C++17/20
- **ビルドシステム**: CMake
- **テスト**: Google Test
- **パーサー**: 手書き再帰下降パーサー（既存）

### IR処理
- **データ構造**: C++ STL + カスタムノード
- **最適化**: カスタム最適化パス
- **解析**: データフロー解析フレームワーク

### コード生成
- **アセンブラ**: GNU as, NASM（オプション）
- **リンカー**: GNU ld, LLD, MSVC link
- **デバッグ**: libdwarf (DWARF生成)

---

## 参考実装

### 学習リソース
1. **Rustコンパイラ（rustc）**
   - HIR/MIR/LLIRの3段階IR
   - 優れた最適化パス
   - 参考: [Rust Compiler Development Guide](https://rustc-dev-guide.rust-lang.org/)

2. **LLVM**
   - IR設計
   - 最適化パス
   - コード生成
   - 参考: [LLVM Documentation](https://llvm.org/docs/)

3. **Cranelift**
   - 軽量なコード生成器
   - WebAssembly対応
   - 参考: [Cranelift Book](https://cranelift.readthedocs.io/)

4. **Tiger Book**
   - "Modern Compiler Implementation in ML/Java/C"
   - コンパイラの教科書

5. **Engineering a Compiler**
   - 最適化技術の詳細

---

## マイルストーン

| バージョン | 期間 | 目標 | 主要成果物 |
|----------|------|------|----------|
| v0.14.0 | 2-3ヶ月 | 標準ライブラリ拡充 | ファイルI/O, ネットワーク, コレクション |
| v0.15.0 | 2-3ヶ月 | パフォーマンス向上 | インタプリタ最適化, デバッグ機能 |
| v0.16.0 | 3-4ヶ月 | IR実装 | HIR, MIR, LIR, IRビューワー |
| v0.17.0 | 3-4ヶ月 | 基本最適化 | 定数畳み込み, DCE, CSE |
| v0.18.0 | 4-5ヶ月 | コード生成 | x86-64/ARM64アセンブリ生成 |
| v0.19.0 | 3-4ヶ月 | リンカー/ランタイム | 実行ファイル生成, ランタイムライブラリ |
| v0.20.0 | 4-5ヶ月 | 高度な最適化 | インライン展開, ループ最適化, LTO |
| v1.0.0 | 2-3ヶ月 | 最終調整 | ネイティブコンパイラ完成 |

**合計期間**: 約24-32ヶ月（2-2.5年）

---

## 段階的な検証

各バージョンで以下の検証を実施：

### 機能検証
- [ ] 全言語機能が正しく動作
- [ ] 既存のテストスイートがパス
- [ ] 新機能のテスト追加

### パフォーマンス検証
- [ ] ベンチマークの実行
- [ ] 前バージョンとの比較
- [ ] リグレッションの検出

### 品質検証
- [ ] メモリリークチェック（Valgrind/ASan）
- [ ] 静的解析（clang-tidy）
- [ ] コードレビュー

---

## リスクと対策

### リスク1: IR設計の失敗
**対策**:
- Rust/LLVMの設計を参考にする
- プロトタイプを早期に作成してフィードバックを得る

### リスク2: 最適化の複雑性
**対策**:
- 段階的に実装（v0.17.0で基本、v0.20.0で高度）
- テストケースを充実させる
- ベンチマークで効果を検証

### リスク3: クロスプラットフォーム対応
**対策**:
- CI/CDで複数プラットフォームをテスト
- 抽象化層を適切に設計

### リスク4: 開発期間の延長
**対策**:
- 各バージョンで最小限の機能に絞る
- 外部ツール（GCC/Clang）を活用
- LLVMバックエンドの使用も検討（将来）

---

## まとめ

このロードマップに従うことで、Cb言語は以下を達成します：

1. **v0.14.0-v0.15.0**: インタプリタの完成
2. **v0.16.0**: IR設計完了
3. **v0.17.0**: 基本的な最適化実装
4. **v0.18.0**: コード生成成功
5. **v0.19.0**: 実行ファイル生成
6. **v0.20.0**: 本格的な最適化完成
7. **v1.0.0**: ネイティブコンパイラリリース

**目標**: 2-2.5年でネイティブコンパイラを完成させ、Cb言語を本番利用可能な状態にする。
