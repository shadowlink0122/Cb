# v0.10.1 実装ギャップ詳細

このドキュメントは、v0.10.0で実装しきれなかった機能の詳細と、具体的な実装が必要な箇所を記録します。

---

## 1. 参照セマンティクスの未実装

### 1.1 メンバーアクセスでの参照解決

**問題のあるコード**: `src/backend/interpreter/evaluator/access/member.cpp`

```cpp
// 現在の実装 (行563付近)
int64_t ExpressionEvaluator::evaluate_member_access_impl(const ASTNode *node) {
    std::string var_name;
    std::string member_name = node->name;
    
    if (node->left->node_type == ASTNodeType::AST_VARIABLE) {
        var_name = node->left->name;
        // ★ 問題: 参照変数の場合、参照先を解決していない
        // var_name が参照でも、そのまま使われる
    }
    
    Variable *var = interpreter_.find_variable(var_name);
    // ...
}
```

**必要な修正**:
```cpp
// v0.10.1での修正案
int64_t ExpressionEvaluator::evaluate_member_access_impl(const ASTNode *node) {
    std::string var_name;
    std::string member_name = node->name;
    
    if (node->left->node_type == ASTNodeType::AST_VARIABLE) {
        var_name = node->left->name;
        // ★ 追加: 参照を解決
        var_name = interpreter_.resolve_reference(var_name);
    }
    
    Variable *var = interpreter_.find_variable(var_name);
    // ...
}
```

**影響を受けるテスト**:
- `tests/integration/rvalue_reference/rvalue_reference_tests.hpp::test_member_access()`
- `tests/integration/rvalue_reference/rvalue_reference_tests.hpp::test_member_assignment()`

**現在のテスト結果**:
```
Expected: 42
Actual: 0
Reason: ref.x does not update p.x
```

### 1.2 メンバー代入での参照解決

**問題のあるコード**: `src/backend/interpreter/executors/assignments/member_assignment.cpp`

```cpp
// 現在の実装
void StatementExecutor::execute_member_assignment_impl(...) {
    // メンバーアクセスノードから変数名を取得
    std::string var_name = /* 複雑なロジック */;
    
    // ★ 問題: 取得した変数名が参照の場合、解決されていない
    Variable *var = interpreter_.find_variable(var_name);
    // ...
}
```

**必要な修正**:
```cpp
// v0.10.1での修正案
void StatementExecutor::execute_member_assignment_impl(...) {
    std::string var_name = /* 複雑なロジック */;
    
    // ★ 追加: 参照を解決
    var_name = interpreter_.resolve_reference(var_name);
    
    Variable *var = interpreter_.find_variable(var_name);
    // ...
}
```

### 1.3 参照のエイリアシング（参照の参照）

**現在未実装のパターン**:
```cb
Point p1;
Point&& ref1 = p1;
Point&& ref2 = ref1;  // ref2 は ref1 ではなく p1 を参照すべき
ref2.x = 100;
assert(p1.x == 100);  // ❌ FAIL: p1.x は更新されない
```

**問題のあるコード**: `src/backend/interpreter/managers/variables/declaration.cpp` (行1807付近)

```cpp
// 現在の実装
if ((var.is_reference || var.is_rvalue_reference) && source_var) {
    // 参照先の変数名を保存
    debug_print("...", source_var_name.c_str(), ...);
    
    Variable ref_var;
    // ...
    ref_var.reference_target = source_var_name;  // ★ 問題: source_var_name が参照の場合、再帰的に解決されない
    // ...
}
```

**必要な修正**:
```cpp
// v0.10.1での修正案
if ((var.is_reference || var.is_rvalue_reference) && source_var) {
    // ★ 追加: source_var_name自体が参照の場合、最終的な参照先を取得
    std::string final_target = interpreter_->resolve_reference(source_var_name);
    
    Variable ref_var;
    // ...
    ref_var.reference_target = final_target;  // 最終的な参照先を保存
    
    // ★ 追加: 参照マップに登録
    interpreter_->register_reference(node->name, final_target);
}
```

### 1.4 参照マップの実装

**必要な新規実装**: `src/backend/interpreter/core/interpreter.h`

```cpp
class Interpreter {
private:
    // ★ 追加: 参照マップ（スコープごと）
    std::vector<std::map<std::string, std::string>> reference_maps_;
    
public:
    // ★ 追加: 参照解決メソッド
    std::string resolve_reference(const std::string& name);
    
    // ★ 追加: 参照登録メソッド
    void register_reference(const std::string& ref_name, const std::string& target_name);
    
    // 既存のメソッド
    void push_scope();  // ← 修正が必要
    void pop_scope();   // ← 修正が必要
};
```

**実装詳細**: `src/backend/interpreter/core/interpreter.cpp`

```cpp
std::string Interpreter::resolve_reference(const std::string& name) {
    // 現在のスコープから親スコープへと検索
    for (int i = reference_maps_.size() - 1; i >= 0; --i) {
        auto it = reference_maps_[i].find(name);
        if (it != reference_maps_[i].end()) {
            // 再帰的に解決（参照の参照のケース）
            return resolve_reference(it->second);
        }
    }
    // 参照でない場合は元の名前を返す
    return name;
}

void Interpreter::register_reference(const std::string& ref_name, 
                                     const std::string& target_name) {
    if (reference_maps_.empty()) {
        reference_maps_.push_back({});
    }
    reference_maps_.back()[ref_name] = target_name;
}

void Interpreter::push_scope() {
    // 既存のコード
    scope_stack.push_back(Scope());
    
    // ★ 追加: 参照マップのスコープを追加
    reference_maps_.push_back({});
}

void Interpreter::pop_scope() {
    // ★ 追加: デストラクタ呼び出し（後述）
    call_destructors_for_scope();
    
    // 既存のコード
    scope_stack.pop_back();
    
    // ★ 追加: 参照マップのスコープを削除
    if (!reference_maps_.empty()) {
        reference_maps_.pop_back();
    }
}
```

---

## 2. コンストラクタ・デストラクタの未実装

### 2.1 コピーコンストラクタ

**現在未実装のパターン**:
```cb
struct Point {
    int x;
    int y;
    
    // デフォルトコンストラクタは実装済み
    Point() { x = 0; y = 0; }
    
    // ★ 未実装: コピーコンストラクタ
    // Point(Point& other) { x = other.x; y = other.y; }
};

Point p1;
p1.x = 10;
Point p2 = p1;  // ❌ コピーコンストラクタが呼ばれない
assert(p2.x == 10);  // 結果は未定義
```

**必要な実装**:
1. コピーコンストラクタの自動生成（構造体にコピーコンストラクタが定義されていない場合）
2. メンバーワイズコピーの実装
3. 初期化時の呼び出し検出

**実装場所**:
- パーサー: コピーコンストラクタのシグネチャ認識
- インタープリター: 自動生成ロジック
- 変数宣言: 初期化式がコピーかどうかの判定

### 2.2 ムーブコンストラクタ

**現在未実装のパターン**:
```cb
struct Resource {
    int* data;
    
    Resource() { data = nullptr; }
    
    // ★ 未実装: ムーブコンストラクタ
    // Resource(Resource&& other) {
    //     data = other.data;
    //     other.data = nullptr;  // 元のリソースを無効化
    // }
};

Resource r1;
Resource r2 = move(r1);  // ❌ ムーブコンストラクタが呼ばれない
// r1は無効化されるべきだが、現在は値がコピーされる
```

**必要な実装**:
1. ムーブコンストラクタの自動生成
2. `move()` 関数の認識と特別な処理
3. ムーブ後の元変数の無効化

### 2.3 デストラクタの自動呼び出し

#### 2.3.1 スコープ終了時のデストラクタ呼び出し

**現在の実装**: `src/backend/interpreter/core/interpreter.cpp` (pop_scope)

```cpp
void Interpreter::pop_scope() {
    // ★ 未実装: デストラクタ呼び出し
    // 現在は単にスコープを削除するのみ
    
    scope_stack.pop_back();
    reference_maps_.pop_back();  // v0.10.1で追加予定
}
```

**必要な修正**:
```cpp
void Interpreter::pop_scope() {
    // ★ 追加: スコープ内の全構造体変数のデストラクタを呼び出す
    call_destructors_for_scope();
    
    scope_stack.pop_back();
    reference_maps_.pop_back();
}

void Interpreter::call_destructors_for_scope() {
    if (scope_stack.empty()) return;
    
    Scope& current = scope_stack.back();
    
    // 逆順でデストラクタを呼び出す（構築と逆順）
    for (auto it = current.variables.rbegin(); it != current.variables.rend(); ++it) {
        Variable& var = it->second;
        
        // 構造体変数のみ
        if (var.is_struct && !var.struct_type_name.empty()) {
            // デストラクタを検索
            std::string destructor_name = "~" + var.struct_type_name;
            
            // デストラクタが定義されている場合のみ呼び出し
            if (has_destructor(var.struct_type_name)) {
                call_destructor(var);
            }
        }
    }
}
```

#### 2.3.2 return文でのデストラクタ呼び出し

**現在未実装のパターン**:
```cb
Point create_point() {
    Point p1;
    if (condition) {
        return p1;  // ★ p1のデストラクタを呼ぶべき（現在は呼ばれない）
    }
    Point p2;
    return p2;  // ★ p1, p2のデストラクタを呼ぶべき
}
```

**問題のあるコード**: `src/backend/interpreter/handlers/control/return.cpp`

```cpp
// 現在の実装
void ControlFlowHandler::handle_return(ASTNode *node) {
    // 戻り値の評価
    int64_t return_value = /* ... */;
    
    // ★ 未実装: 現在のスコープの変数のデストラクタ呼び出し
    
    // return フラグを設定
    interpreter_->set_return_flag(true, return_value);
}
```

**必要な修正**:
```cpp
void ControlFlowHandler::handle_return(ASTNode *node) {
    // 戻り値の評価
    int64_t return_value = /* ... */;
    
    // ★ 追加: returnする前にデストラクタを呼び出す
    interpreter_->call_destructors_for_current_scope();
    
    // return フラグを設定
    interpreter_->set_return_flag(true, return_value);
}
```

#### 2.3.3 break/continue でのデストラクタ呼び出し

**現在未実装のパターン**:
```cb
for (int i = 0; i < 10; i++) {
    Point p;
    if (i == 5) {
        break;  // ★ pのデストラクタを呼ぶべき（現在は呼ばれない）
    }
}
```

**問題のあるコード**: `src/backend/interpreter/handlers/control/break_continue.cpp`

```cpp
// 現在の実装
void ControlFlowHandler::handle_break(ASTNode *node) {
    // ★ 未実装: ループスコープの変数のデストラクタ呼び出し
    
    interpreter_->set_break_flag(true);
}
```

**必要な修正**:
```cpp
void ControlFlowHandler::handle_break(ASTNode *node) {
    // ★ 追加: breakする前にデストラクタを呼び出す
    interpreter_->call_destructors_for_loop_scope();
    
    interpreter_->set_break_flag(true);
}
```

### 2.4 初期化リスト構文

**現在未実装のパターン**:
```cb
struct Point {
    int x;
    int y;
    
    Point(int x_, int y_) : x(x_), y(y_) {  // ★ 初期化リスト構文
        // コンストラクタ本体
    }
};
```

**実装が必要な箇所**:
1. パーサー: `:` 以降の初期化リストの解析
2. AST: 初期化リストを表すノードの追加
3. インタープリター: 初期化リストの実行（本体実行前）

---

## 3. move() 関数の未実装

### 3.1 現在の実装状態

**実装済み**: `stdlib/std/move.cb`

```cb
// move() 関数は定義されている
T&& move(T& x) {
    return x;  // ★ 問題: 単にT&&にキャストするだけ
}
```

**問題点**:
- 実際のムーブセマンティクスが実装されていない
- 元の変数が無効化されない
- ムーブコンストラクタが呼ばれない

### 3.2 必要な実装

**ムーブセマンティクスの実装方針**:
```cpp
// インタープリター側での特別な処理
if (function_name == "move") {
    // 1. 引数の変数を「ムーブ済み」としてマーク
    Variable* source_var = /* 引数から取得 */;
    source_var->is_moved = true;
    
    // 2. ムーブコンストラクタを呼び出す準備
    // （ムーブコンストラクタが定義されている場合）
    
    // 3. T&& を返す
    return /* T&& 型の値 */;
}
```

**追加が必要なフィールド**: `src/backend/interpreter/core/interpreter.h`

```cpp
struct Variable {
    // 既存のフィールド
    // ...
    
    // ★ 追加: ムーブ済みフラグ
    bool is_moved = false;
};
```

**ムーブ済み変数へのアクセス検出**:
```cpp
// 変数アクセス時のチェック
Variable* var = find_variable(name);
if (var && var->is_moved) {
    throw std::runtime_error(
        "Error: Variable '" + name + "' has been moved and is no longer valid");
}
```

---

## 4. その他の未実装機能

### 4.1 constexpr

**未実装のパターン**:
```cb
constexpr int BUFFER_SIZE = 1024;  // ★ constexpr 未サポート
```

**実装が必要な箇所**:
- パーサー: `constexpr` キーワードの認識
- 評価: コンパイル時評価の実装

### 4.2 デフォルト引数

**未実装のパターン**:
```cb
void foo(int x = 10) {  // ★ デフォルト引数 未サポート
    print(x);
}

foo();  // x = 10 として呼ばれるべき
```

### 4.3 operator overloading

**未実装のパターン**:
```cb
struct Point {
    int x, y;
    
    Point operator+(Point& other) {  // ★ 演算子オーバーロード 未サポート
        Point result;
        result.x = x + other.x;
        result.y = y + other.y;
        return result;
    }
};
```

---

## 5. 実装優先度

### 最優先 (v0.10.1)
1. ✅ **参照マップの実装** - 参照セマンティクスの基盤
2. ✅ **メンバーアクセスでの参照解決** - 最も影響の大きいバグ
3. ✅ **デストラクタの自動呼び出し（スコープ終了時）** - メモリリーク防止

### 高優先度 (v0.10.1 or v0.11.0)
4. ❌ メンバー代入での参照解決
5. ❌ 参照のエイリアシング
6. ❌ return/break/continue でのデストラクタ呼び出し

### 中優先度 (v0.11.0)
7. ❌ コピーコンストラクタの自動生成
8. ❌ ムーブコンストラクタの実装
9. ❌ move() 関数の完全実装

### 低優先度 (v0.12.0以降)
10. ❌ 初期化リスト構文
11. ❌ デフォルト引数
12. ❌ operator overloading
13. ❌ constexpr

---

## 6. テスト状況

### 現在のテスト結果（v0.10.0完了時点）

```
=== Test Summary ===
Total:  2582
Passed: 2582 ✅
Failed: 0

Integration Tests:
- Rvalue Reference Tests: 6/6 PASS
  - ✅ test_syntax_parse
  - ✅ test_type_restriction  
  - ✅ test_lvalue_ref_primitive
  - ⚠️  test_member_access (EXPECTED_FAIL)
  - ⚠️  test_member_assignment (EXPECTED_FAIL)
  - ⚠️  test_aliasing (EXPECTED_FAIL)

- Move Constructor Tests: 6/6 PASS
  - ✅ test_move_basic (syntax only)
  - ✅ test_copy_vs_move (syntax only)
  - ✅ test_chain_move (syntax only)
  - ⚠️  test_move_constructor_definition (EXPECTED_FAIL)
  - ⚠️  test_primitive_move_error (EXPECTED_FAIL)
  - ⚠️  test_lvalue_ref (EXPECTED_FAIL)
```

**注**: `EXPECTED_FAIL`は、v0.10.0では構文のみサポートで、セマンティクスは未実装のため期待通りの失敗です。

### v0.10.1で PASS にすべきテスト

1. `test_member_access` - 参照を通じたメンバーアクセス
2. `test_member_assignment` - 参照を通じたメンバー代入
3. `test_aliasing` - 参照の参照

---

## 7. 実装時の注意点

### 7.1 後方互換性

- 既存の全2582テストが引き続き PASS であること
- T& (左辺値参照) の動作に影響を与えないこと
- 通常の変数宣言・代入に影響を与えないこと

### 7.2 パフォーマンス

- `resolve_reference()` は頻繁に呼ばれる可能性があるため、効率的な実装が必要
- 可能であれば inline 化を検討
- 参照でない場合は早期リターン

### 7.3 メモリ安全性

- スコープ終了時の参照マップのクリーンアップ
- ダングリング参照の検出（可能であれば）
- デストラクタの二重呼び出し防止

---

## 8. まとめ

v0.10.0では、T&&とコンストラクタ・デストラクタの**構文レベルの実装**を完了しました。

v0.10.1では、**セマンティクスレベルの実装**に焦点を当て、特に：
1. 参照マップによる参照解決
2. メンバーアクセス・代入での参照サポート
3. デストラクタの自動呼び出し

これらを実装することで、C++に近い動作を実現します。

---

最終更新: 2025年10月12日
v0.10.0 完了時点での記録
