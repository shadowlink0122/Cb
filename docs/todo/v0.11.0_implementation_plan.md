# Cb言語 v0.11.0 実装計画

## リリース予定日
2025年12月上旬

## 概要
v0.11.0では、複合文`{}`のスコープ対応、テンプレート機能、エラーハンドリングなど、言語の表現力を大幅に向上させます。

---

## 🎯 実装予定の機能

### 1. 複合文 `{}` のスコープ対応

**優先度**: 🔴 最優先  
**見積もり**: 2週間  
**難易度**: ⭐⭐⭐⭐

#### 概要
複合文（ブロック）でスコープを作成し、defer/デストラクタをブロック終了時に実行。

#### 現状の問題
```cb
void main() {
    {
        Resource r1(1);
        defer println("Block 1 defer");
    }  // ⚠️ ここでdefer/デストラクタが実行されない（v0.10.0）
    
    {
        Resource r2(2);
        defer println("Block 2 defer");
    }  // ⚠️ ここでも実行されない
}  // 関数終了時にすべてまとめて実行される
```

#### 目標
```cb
void main() {
    println("Start");
    
    {
        Resource r1(1);
        defer println("Block 1 defer");
        println("In block 1");
    }  // ✅ Block 1 defer → r1のデストラクタ
    
    println("Between blocks");
    
    {
        Resource r2(2);
        defer println("Block 2 defer");
        println("In block 2");
    }  // ✅ Block 2 defer → r2のデストラクタ
    
    println("End");
}

// 期待される出力:
// Start
// In block 1
// Block 1 defer
// Resource destroyed 1
// Between blocks
// In block 2
// Block 2 defer
// Resource destroyed 2
// End
```

#### 実装方針
1. **複合文のスコープ管理**
   - `AST_STATEMENT_LIST` の処理時にスコープを作成
   - ブロック終了時に `pop_scope()` を呼び出し

2. **スコープスタックの拡張**
   - 関数スコープと複合文スコープを区別
   - ネストしたブロックに対応

3. **変数の可視性**
   - ブロック内で宣言された変数はブロック外からアクセス不可
   - C++と同じスコープルール

#### 影響範囲
- `src/backend/interpreter/executors/statement_list_executor.cpp`
- `src/backend/interpreter/core/cleanup.cpp`
- `src/backend/interpreter/managers/variables/*.cpp`

---

### 2. テンプレート機能（ジェネリクス）

**優先度**: 🔴 最優先  
**見積もり**: 4週間  
**難易度**: ⭐⭐⭐⭐⭐  
**詳細仕様**: `v0.11.0_generics_spec.md`

#### 概要
型パラメータを持つ構造体、関数、Interfaceのサポート。RustとC++のテンプレートを参考に、使いやすさと型安全性を両立。

#### 基本的な実装例

**ジェネリック構造体**:
```cb
struct Box<T> {
    T value;
}

struct Pair<T1, T2> {
    T1 first;
    T2 second;
}

void main() {
    Box<int> int_box;
    int_box.value = 42;
    
    Pair<int, string> p;
    p.first = 1;
    p.second = "Alice";
}
```

**ジェネリック関数**:
```cb
T max<T>(T a, T b) {
    if (a > b) {
        return a;
    }
    return b;
}

void main() {
    int i = max<int>(10, 20);
    long l = max<long>(100L, 200L);
}
```

#### 型制約

**Union型制約**:
```cb
// 整数型のみ受け入れる
struct NumericBox<T: int | tiny | short | long> {
    T value;
}

void main() {
    NumericBox<int> box;     // ✅ OK
    NumericBox<string> err;  // ❌ エラー
}
```

**Interface制約**:
```cb
interface Printable {
    void print();
}

void print_all<T: Printable>(T item) {
    item.print();
}
```

#### ジェネリックInterface

**Interface定義**:
```cb
interface Container<T> {
    void add(T item);
    T get(int index);
}

struct List<T> {
    T[100] items;
    int count;
}

impl Container<T> for List<T> {
    void add(T item) {
        self.items[self.count] = item;
        self.count = self.count + 1;
    }
    
    T get(int index) {
        return self.items[index];
    }
}
```

#### ジェネリックコンストラクタ

```cb
struct Box<T> {
    T value;
}

impl Box<T> {
    self(T v) {
        self.value = v;
    }
    
    T get() {
        return self.value;
    }
}

void main() {
    Box<int> int_box(42);
    Box<string> str_box("Hello");
}
```

#### 部分的なインスタンス化

```cb
interface Numeric {
    T add(T other);
}

struct Calculator<T: int | long | short> {
    T value;
}

// intに対してのみ実装
impl Numeric for Calculator<int> {
    int add(int other) {
        return self.value + other;
    }
}
```

#### 実装方針（4フェーズ）

**Phase 1: 基本的なジェネリクス（2週間）**
1. 構文解析: `<T>`, `<T1, T2>`
2. 型パラメータ管理
3. インスタンス化とキャッシュ
4. テスト: 基本的な構造体と関数

**Phase 2: 型制約（1週間）**
1. Union型制約の解析と検証
2. 制約違反の検出
3. テスト: 制約の検証

**Phase 3: Interface統合（1週間）**
1. ジェネリックInterfaceの解析
2. `impl I<T> for S<T>` のサポート
3. 型パラメータの一致検証
4. 部分的なインスタンス化
5. テスト: Interface統合

**Phase 4: 型推論（将来的な拡張）**
- 関数呼び出し時の型パラメータ自動推論
- v0.12.0以降で実装予定

#### 文法定義（BNF追加）

```bnf
<type_parameter_list> ::= '<' <type_parameter> { ',' <type_parameter> } '>'
<type_parameter> ::= <identifier> [ ':' <type_constraint> ]
<type_constraint> ::= <type_union> [ '&' <interface_constraint> ]
<type_union> ::= <type_specifier> { '|' <type_specifier> }

<generic_struct> ::= 'struct' <identifier> <type_parameter_list> '{' ... '}'
<generic_function> ::= <type_specifier> <identifier> <type_parameter_list> '(' ... ')' <block>
<generic_interface> ::= 'interface' <identifier> <type_parameter_list> '{' ... '}'
<generic_impl> ::= 'impl' <identifier> [ <type_parameter_list> ] 'for' <identifier> [ <type_parameter_list> ] '{' ... '}'
```

#### テスト計画（150個）
- 基本テスト: 50個（構造体、関数、ネスト）
- 型制約テスト: 30個（Union型、制約違反）
- Interfaceテスト: 40個（ジェネリックInterface、impl）
- エッジケース: 30個（深いネスト、エラーメッセージ）

#### 影響範囲
- `src/frontend/recursive_parser/parsers/*.cpp` (すべて)
- `src/backend/interpreter/core/interpreter.cpp`
- `src/backend/interpreter/managers/types/manager.cpp`
- `src/common/ast.h` (新しいASTノード)

#### 参考言語
- **Rust**: トレイト境界、ジェネリックの構文
- **C++**: テンプレート、SFINAE、コンセプト
- **TypeScript**: ジェネリックの構文、型制約

---

### 3. エラーハンドリング（try-catch-finally）

**優先度**: 🟡 高  
**見積もり**: 2週間  
**難易度**: ⭐⭐⭐⭐

#### 概要
例外処理機構の実装。

#### 実装例
```cb
struct FileError {
    string message;
};

void read_file(string path) {
    if (!file_exists(path)) {
        throw FileError("File not found: " + path);
    }
    // ファイル読み込み処理
}

void main() {
    try {
        read_file("data.txt");
        println("File read successfully");
    } catch (FileError& e) {
        println("Error: ", e.message);
    } finally {
        println("Cleanup");
    }
}
```

#### 実装方針
1. **例外の投げ上げ**
   - `throw` 文のサポート
   - スタック巻き戻し（stack unwinding）

2. **catch ブロック**
   - 型マッチング
   - 複数の catch ブロック

3. **finally ブロック**
   - 必ず実行される処理
   - defer との統合

4. **defer との関係**
   - 例外発生時もdeferを実行
   - finally → defer → デストラクタの順序

#### 影響範囲
- `src/frontend/recursive_parser/parsers/statement_parser.cpp`
- `src/backend/interpreter/handlers/control/*.cpp`
- `src/backend/interpreter/core/cleanup.cpp`

---

### 4. パターンマッチング

**優先度**: 🟢 中  
**見積もり**: 2週間  
**難易度**: ⭐⭐⭐⭐

#### 概要
Rustスタイルのパターンマッチング。

#### 実装例
```cb
enum Option<T> {
    Some(T),
    None
};

void main() {
    Option<int> opt = Some(42);
    
    match (opt) {
        Some(value) => {
            println("Value: ", value);
        },
        None => {
            println("No value");
        }
    }
}
```

---

### 5. 標準ライブラリの拡張

**優先度**: 🟢 中  
**見積もり**: 継続的  
**難易度**: ⭐⭐

#### 追加予定のモジュール
1. **stdlib/collections.cb**
   - `Vec<T>`: 動的配列
   - `HashMap<K, V>`: ハッシュマップ
   - `LinkedList<T>`: 連結リスト

2. **stdlib/string.cb**
   - 文字列操作関数
   - UTF-8サポート

3. **stdlib/file.cb**
   - ファイル入出力
   - パス操作

4. **stdlib/net.cb**
   - ソケット通信
   - HTTP クライアント

---

## 🔨 バグ修正と改善

### 1. 複合文スコープ（v0.10.0からの持ち越し）
**優先度**: 🔴 最優先  
**ステータス**: v0.10.0で未実装

### 2. 関数オーバーロード
**優先度**: 🟡 高  
**ステータス**: v0.10.1で実装予定

### 3. マクロシステム
**優先度**: 🟢 中  
**見積もり**: 3週間

```cb
macro debug_print(expr) {
    println("[DEBUG] ", stringify(expr), " = ", expr);
}

void main() {
    int x = 42;
    debug_print(x);  // [DEBUG] x = 42
}
```

---

## 📋 実装タスクリスト

### Phase 1: スコープとエラーハンドリング (4週間)
- [ ] 複合文のスコープ対応
- [ ] try-catch-finally の実装
- [ ] 統合テスト

### Phase 2: テンプレート機能 (3週間)
- [ ] ジェネリック構造体
- [ ] ジェネリック関数
- [ ] 型推論の改善
- [ ] 統合テスト

### Phase 3: パターンマッチング (2週間)
- [ ] match 文の実装
- [ ] enum との統合
- [ ] 統合テスト

### Phase 4: 標準ライブラリ (継続的)
- [ ] collections モジュール
- [ ] string モジュール
- [ ] file モジュール
- [ ] net モジュール

---

## 🧪 テスト計画

### 新規テストカテゴリ
1. **scope_test/** (複合文スコープ)
2. **template_test/** (テンプレート)
3. **exception_test/** (エラーハンドリング)
4. **pattern_match_test/** (パターンマッチング)

### 統合テスト目標
- 総テスト数: 4000個以上
- カバレッジ: 85%以上

---

## 📝 ドキュメント

### 更新予定
1. **spec.md**
   - スコープルールの詳細化
   - テンプレート構文
   - エラーハンドリング構文

2. **BNF.md**
   - 新構文の追加

3. **tutorial/**
   - スコープとライフタイム
   - テンプレートの使い方
   - エラーハンドリング
   - パターンマッチング

4. **stdlib/**
   - 各モジュールのAPI仕様

---

## 🎓 参考言語

### スコープとライフタイム
- **C++**: RAII, スコープベースのリソース管理
- **Rust**: 借用チェッカー、ライフタイム

### テンプレート
- **C++**: テンプレート、SFINAE
- **Rust**: ジェネリクス、trait bounds
- **Go**: インターフェース

### エラーハンドリング
- **C++**: try-catch-throw
- **Rust**: Result<T, E>
- **Go**: error返値

### パターンマッチング
- **Rust**: match式
- **Swift**: switch-case (強力版)
- **ML系言語**: パターンマッチング

---

## 🚀 リリース基準

### 必須条件
- ✅ 複合文スコープの完全実装
- ✅ テンプレート機能の基本実装
- ✅ すべてのテストが通過
- ✅ ドキュメントの更新完了

### 望ましい条件
- 🎯 エラーハンドリングの実装
- 🎯 パターンマッチングの実装
- 🎯 標準ライブラリの充実
- 🎯 パフォーマンステスト

---

## 🔮 将来の展望（v0.12.0以降）

### 並行処理
- goroutine風の軽量スレッド
- チャネル通信

### 非同期処理
- async/await
- Future/Promise

### 所有権システムの強化
- Rust風の借用チェッカー
- コンパイル時のメモリ安全性保証

### コンパイラバックエンド
- LLVM IR生成
- ネイティブコード生成
- 最適化

---

**作成日**: 2025年10月12日  
**作成者**: shadowlink0122
