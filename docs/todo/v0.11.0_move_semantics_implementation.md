# v0.11.0 ムーブセマンティクス実装計画

## 📋 概要

C++と同じ仕様で右辺値参照（`T&&`）による所有権移動を実装する。

## 🎯 実装方針

### ユーザー要求
1. **通常の変数でもムーブ（所有権の移動）を実装**
2. **`T&&` で完全に所有権を渡す**
3. **ムーブコンストラクタも同様**
4. **C++と同じ仕様**
5. **右辺値のムーブは禁止**

### C++との整合性

```cpp
// C++の仕様
struct Buffer {
    int* data;
    
    // コピーコンストラクタ（左辺値参照 + const）
    Buffer(const Buffer& other);
    
    // ムーブコンストラクタ（右辺値参照）
    Buffer(Buffer&& other) noexcept;
};

Buffer b1;
Buffer b2 = b1;         // コピー
Buffer b3 = std::move(b1);  // ムーブ（b1は無効化）
// Buffer b4 = std::move(123);  // エラー: 右辺値はムーブ不可
```

## 🔧 実装タスク

### Phase 1: 構文解析（Parser）

#### 1.1 右辺値参照の構文サポート

**場所**: `src/frontend/recursive_parser/`

**必要な変更**:
```cpp
// パラメータ型の解析拡張
enum ReferenceType {
    NO_REFERENCE,
    LVALUE_REFERENCE,   // T&
    RVALUE_REFERENCE    // T&&
};

struct Parameter {
    std::string type;
    std::string name;
    bool is_const;
    ReferenceType ref_type;  // NEW
};
```

**構文例**:
```cb
// 左辺値参照（コピー）
self(const Point& other) { }

// 右辺値参照（ムーブ）
self(Point&& other) { }
```

#### 1.2 move() 関数の認識

**場所**: `src/common/ast.h`

**AST拡張**:
```cpp
struct MoveExpressionNode : public ASTNode {
    std::unique_ptr<ASTNode> expression;
    std::string var_name;
};
```

**構文例**:
```cb
Buffer b1(100);
Buffer b2 = move(b1);  // move()呼び出しを認識
```

---

### Phase 2: 型システム（Type Manager）

#### 2.1 右辺値参照の型管理

**場所**: `src/common/type_utils.h`, `src/common/type_utils.cpp`

**追加フィールド**:
```cpp
struct TypeInfo {
    VariableType type;
    bool is_const;
    bool is_pointer;
    bool is_reference;
    bool is_rvalue_reference;  // NEW: T&& の判定
    std::string type_alias;
};
```

#### 2.2 値カテゴリの判定

**新規関数**:
```cpp
enum ValueCategory {
    LVALUE,   // 左辺値（名前付き変数）
    RVALUE    // 右辺値（一時オブジェクト、リテラル）
};

ValueCategory determine_value_category(const ASTNode* node);
```

**判定ルール**:
- 変数名 → LVALUE
- リテラル → RVALUE
- `move(x)` → RVALUE（明示的な右辺値化）
- 関数の戻り値 → RVALUE（最適化可能）

---

### Phase 3: インタープリタ（Interpreter）

#### 3.1 ムーブコンストラクタの検出

**場所**: `src/backend/interpreter/core/interpreter.cpp`

**新規関数**:
```cpp
void Interpreter::call_move_constructor(
    const std::string& dest_var_name,
    const std::string& struct_type_name,
    const std::string& source_var_name
);
```

**検出ロジック**:
```cpp
// ムーブコンストラクタを探す
// 条件: パラメータが1つで、T&& 型（右辺値参照）
const ASTNode* find_move_constructor(const std::string& struct_type) {
    auto it = struct_constructors_.find(struct_type);
    if (it == struct_constructors_.end()) return nullptr;
    
    for (const auto* ctor : it->second) {
        if (ctor->parameters.size() == 1) {
            const auto& param = ctor->parameters[0];
            // T&& かつ非const
            if (param->is_rvalue_reference && !param->is_const) {
                return ctor;
            }
        }
    }
    return nullptr;
}
```

#### 3.2 move() 関数の実装

**場所**: `src/backend/interpreter/handlers/expressions/`

**実装**:
```cpp
Variable Interpreter::execute_move_expression(const ASTNode* node) {
    // move(x) の引数を取得
    const std::string& var_name = node->var_name;
    
    // 左辺値（変数）でなければエラー
    Variable* var = find_variable(var_name);
    if (!var) {
        throw std::runtime_error("move() requires an lvalue (variable)");
    }
    
    // 右辺値への変換（値カテゴリの変更のみ）
    Variable result = *var;
    result.value_category = RVALUE;
    result.is_moved_from = false;  // まだムーブされていない
    
    return result;
}
```

#### 3.3 所有権移動の実装

**場所**: `src/backend/interpreter/core/interpreter.cpp`

**ムーブコンストラクタ呼び出し**:
```cpp
void Interpreter::call_move_constructor(
    const std::string& dest_var_name,
    const std::string& struct_type_name,
    const std::string& source_var_name
) {
    const ASTNode* move_ctor = find_move_constructor(struct_type_name);
    
    if (!move_ctor) {
        // ムーブコンストラクタがない場合、コピーコンストラクタを使用
        call_copy_constructor(dest_var_name, struct_type_name, source_var_name);
        return;
    }
    
    Variable* dest_var = find_variable(dest_var_name);
    Variable* source_var = find_variable(source_var_name);
    
    if (!dest_var || !source_var) {
        throw std::runtime_error("Variable not found in move constructor");
    }
    
    // ムーブコンストラクタ用のスコープを作成
    push_scope();
    
    // self を dest_var として設定
    current_scope().variables["self"] = *dest_var;
    
    // パラメータ（ソース変数への右辺値参照）を設定
    const auto& param = move_ctor->parameters[0];
    current_scope().variables[param->name] = *source_var;
    
    // ムーブコンストラクタ本体を実行
    if (move_ctor->body) {
        execute_statement(move_ctor->body.get());
    }
    
    // selfへの変更を dest_var に反映
    Variable* self = find_variable("self");
    if (self) {
        dest_var->struct_members = self->struct_members;
        
        // メンバー変数も更新
        for (const auto& [member_name, member_value] : self->struct_members) {
            std::string member_path = dest_var_name + "." + member_name;
            Variable* dest_member = find_variable(member_path);
            if (dest_member) {
                *dest_member = member_value;
            }
        }
    }
    
    pop_scope();
    
    // ⚠️ 重要: ソース変数を「ムーブ済み」状態にマーク
    source_var->is_moved_from = true;
    
    // デストラクタスタックから削除（ムーブ済みオブジェクトはデストラクタ呼び出し不要）
    remove_from_destructor_stack(source_var_name);
    
    if (debug_mode) {
        debug_print("Move constructor called: %s -> %s (source invalidated)\n",
                    source_var_name.c_str(), dest_var_name.c_str());
    }
}
```

#### 3.4 デストラクタスタックからの削除

**新規関数**:
```cpp
void Interpreter::remove_from_destructor_stack(const std::string& var_name) {
    if (destructor_stacks_.empty()) return;
    
    auto& current_stack = destructor_stacks_.back();
    
    // var_name に一致するエントリを削除
    current_stack.erase(
        std::remove_if(current_stack.begin(), current_stack.end(),
            [&var_name](const auto& entry) {
                return entry.first == var_name;
            }),
        current_stack.end()
    );
    
    if (debug_mode) {
        debug_print("Removed %s from destructor stack (moved from)\n",
                    var_name.c_str());
    }
}
```

---

### Phase 4: 変数宣言での自動判定

#### 4.1 初期化での判定

**場所**: `src/backend/interpreter/handlers/variables/declaration.cpp`

**ロジック**:
```cpp
void Interpreter::execute_variable_declaration(const ASTNode* node) {
    // ... 既存のコード ...
    
    // 初期化式がある場合
    if (node->initializer) {
        // 初期化式の値カテゴリを判定
        ValueCategory category = determine_value_category(node->initializer.get());
        
        if (node->type == TYPE_STRUCT) {
            std::string struct_type = resolve_typedef(node->type_alias);
            
            if (category == RVALUE) {
                // 右辺値 → ムーブコンストラクタ
                call_move_constructor(var_name, struct_type, source_var_name);
            } else {
                // 左辺値 → コピーコンストラクタ
                call_copy_constructor(var_name, struct_type, source_var_name);
            }
        }
    }
}
```

---

### Phase 5: 右辺値のムーブ禁止

#### 5.1 move() の引数チェック

**場所**: `src/backend/interpreter/handlers/expressions/move.cpp`

**検証**:
```cpp
Variable Interpreter::execute_move_expression(const ASTNode* node) {
    const std::string& var_name = node->var_name;
    
    // 右辺値チェック
    if (is_rvalue_expression(node->expression.get())) {
        throw std::runtime_error(
            "Cannot move from rvalue (literals, temporary objects). "
            "move() requires a variable (lvalue)."
        );
    }
    
    // 左辺値（変数）であることを確認
    Variable* var = find_variable(var_name);
    if (!var) {
        throw std::runtime_error(
            "move() requires a variable name, not an expression"
        );
    }
    
    // 既にムーブ済みの変数からはムーブできない
    if (var->is_moved_from) {
        throw std::runtime_error(
            "Cannot move from already moved variable: " + var_name
        );
    }
    
    // 右辺値への変換
    Variable result = *var;
    result.value_category = RVALUE;
    return result;
}
```

**エラーメッセージ例**:
```cb
Buffer b = move(123);        // エラー: 右辺値はムーブできません
Buffer b = move(get_buffer());  // エラー: 一時オブジェクトはムーブできません
```

---

## 📊 データ構造の拡張

### Variable 構造体

**場所**: `src/common/ast.h` または `src/backend/interpreter/core/interpreter.h`

```cpp
struct Variable {
    // 既存フィールド
    std::string name;
    VariableType type;
    TypedValue value;
    bool is_const;
    bool is_pointer;
    bool is_reference;
    
    // NEW: ムーブセマンティクス用
    bool is_rvalue_reference;  // T&& 型か
    ValueCategory value_category;  // LVALUE or RVALUE
    bool is_moved_from;  // ムーブ済みフラグ
    
    Variable() 
        : is_rvalue_reference(false),
          value_category(LVALUE),
          is_moved_from(false) {}
};
```

---

## 🧪 テストケース

### Test 1: 基本的なムーブ

**ファイル**: `tests/cases/constructor/basic_move_test.cb`

```cb
struct Point {
    int x;
    int y;
}

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    // コピーコンストラクタ
    self(const Point& other) {
        self.x = other.x;
        self.y = other.y;
        println("Copy constructor");
    }
    
    // ムーブコンストラクタ
    self(Point&& other) {
        self.x = other.x;
        self.y = other.y;
        other.x = 0;
        other.y = 0;
        println("Move constructor");
    }
    
    ~self() {
        println("Destructor: (", self.x, ", ", self.y, ")");
    }
}

void main() {
    Point p1(10, 20);
    println("p1: (", p1.x, ", ", p1.y, ")");
    
    Point p2 = move(p1);  // ムーブコンストラクタ呼び出し
    println("After move:");
    println("  p1: (", p1.x, ", ", p1.y, ")");  // (0, 0)
    println("  p2: (", p2.x, ", ", p2.y, ")");  // (10, 20)
}

// 期待される出力:
// p1: (10, 20)
// Move constructor
// After move:
//   p1: (0, 0)
//   p2: (10, 20)
// Destructor: (10, 20)  ← p2のみ（p1はムーブ済みなのでスキップ）
```

### Test 2: リソース所有権の移動

**ファイル**: `tests/cases/constructor/move_ownership_test.cb`

```cb
struct Buffer {
    int* data;
    int size;
    bool owns_data;
}

impl Buffer {
    self(int s) {
        self.size = s;
        self.owns_data = true;
        println("Buffer created: size=", s);
    }
    
    // コピーコンストラクタ（ディープコピー）
    self(const Buffer& other) {
        self.size = other.size;
        self.owns_data = true;
        println("Buffer copied (DEEP): size=", self.size);
    }
    
    // ムーブコンストラクタ（所有権移動）
    self(Buffer&& other) {
        self.size = other.size;
        self.data = other.data;
        self.owns_data = other.owns_data;
        
        // ムーブ元を無効化
        other.size = 0;
        other.data = nullptr;
        other.owns_data = false;
        
        println("Buffer moved (FAST): size=", self.size);
    }
    
    ~self() {
        if (self.owns_data) {
            println("Buffer destroyed: size=", self.size);
        } else {
            println("Buffer destroyed: (moved from, no cleanup)");
        }
    }
}

void main() {
    println("=== Copy vs Move Test ===");
    
    Buffer b1(100);
    Buffer b2 = b1;        // コピー（重い）
    Buffer b3 = move(b1);  // ムーブ（軽い）
    
    println("End of main");
}

// 期待される出力:
// === Copy vs Move Test ===
// Buffer created: size=100
// Buffer copied (DEEP): size=100
// Buffer moved (FAST): size=100
// End of main
// Buffer destroyed: size=100  ← b3（所有権あり）
// Buffer destroyed: size=100  ← b2（所有権あり）
// Buffer destroyed: (moved from, no cleanup)  ← b1（ムーブ済み）
```

### Test 3: 右辺値のムーブ禁止

**ファイル**: `tests/cases/constructor/move_error_test.cb`

```cb
struct Point {
    int x;
    int y;
}

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    self(Point&& other) {
        self.x = other.x;
        self.y = other.y;
    }
}

Point create_point() {
    Point p(10, 20);
    return p;
}

void main() {
    // エラー: 右辺値はムーブできない
    // Point p1 = move(123);  // コンパイルエラー
    
    // エラー: 一時オブジェクトはムーブできない
    // Point p2 = move(create_point());  // コンパイルエラー
    
    // OK: 変数（左辺値）はムーブできる
    Point p3(30, 40);
    Point p4 = move(p3);  // OK
    
    println("Test passed");
}
```

### Test 4: ムーブ後のアクセス禁止

**ファイル**: `tests/cases/constructor/moved_from_access_test.cb`

```cb
struct Point {
    int x;
    int y;
}

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    self(Point&& other) {
        self.x = other.x;
        self.y = other.y;
        other.x = 0;
        other.y = 0;
    }
}

void main() {
    Point p1(10, 20);
    Point p2 = move(p1);
    
    // ⚠️ 警告: ムーブ後のオブジェクトへのアクセス
    // println(p1.x);  // 技術的には可能だが、未定義動作
    
    // エラー: ムーブ済み変数から再度ムーブはできない
    // Point p3 = move(p1);  // エラー
    
    println("p2: (", p2.x, ", ", p2.y, ")");
}
```

---

## 📝 実装順序

### ステップ1: データ構造の拡張（1日）
- [ ] `Variable` に `is_rvalue_reference`, `value_category`, `is_moved_from` を追加
- [ ] `ValueCategory` enum の定義
- [ ] `ReferenceType` enum の定義

### ステップ2: 構文解析（2日）
- [ ] `&&` トークンの認識
- [ ] パラメータ解析で `T&&` をサポート
- [ ] `move()` 関数呼び出しのASTノード

### ステップ3: 型システム（1日）
- [ ] `determine_value_category()` 関数の実装
- [ ] 右辺値参照の型チェック

### ステップ4: ムーブコンストラクタ（3日）
- [ ] `find_move_constructor()` の実装
- [ ] `call_move_constructor()` の実装
- [ ] `remove_from_destructor_stack()` の実装

### ステップ5: move() 関数（2日）
- [ ] `execute_move_expression()` の実装
- [ ] 右辺値チェックとエラーハンドリング
- [ ] ムーブ済み変数のチェック

### ステップ6: 変数宣言の自動判定（1日）
- [ ] 初期化式の値カテゴリ判定
- [ ] コピー/ムーブの自動選択

### ステップ7: テスト（2日）
- [ ] 基本的なムーブテスト
- [ ] リソース所有権テスト
- [ ] エラーケーステスト
- [ ] 統合テストの更新

**合計**: 約12日（2週間）

---

## 🚨 注意事項

### 1. C++との違い

**C++**:
```cpp
Buffer b = Buffer(100);  // 自動的にムーブされる（RVO）
```

**Cb言語**:
```cb
Buffer b = create_buffer();  // コピー（明示的なmove()が必要）
Buffer b = move(create_buffer());  // エラー: 右辺値はムーブ不可
```

### 2. ムーブ後の状態

**C++**: ムーブ後のオブジェクトは「有効だが未規定」
**Cb言語**: ムーブ後のオブジェクトは明示的に無効化（デストラクタ呼び出しなし）

### 3. 暗黙のムーブ

**実装しない機能**:
- 関数の戻り値での自動ムーブ（RVO/NRVO）
- 一時オブジェクトの自動ムーブ

**理由**: シンプルさを保つため、明示的な`move()`のみサポート

---

## 📚 参考資料

### C++11 ムーブセマンティクス
- 右辺値参照: `T&&`
- `std::move()`: 左辺値を右辺値にキャスト
- ムーブコンストラクタ: `T(T&& other)`

### 実装参考
- GCC の libstdc++ implementation
- Clang の libc++ implementation
- Microsoft STL implementation

---

## ✅ 完了基準

- [ ] `T&&` 構文がパースできる
- [ ] `move()` 関数が実装されている
- [ ] ムーブコンストラクタが呼び出される
- [ ] ムーブ後、ソース変数のデストラクタが呼ばれない
- [ ] 右辺値のムーブがエラーになる
- [ ] すべてのテストケースが合格
- [ ] ドキュメントが更新されている

---

## 🔄 次のバージョンでの拡張（v0.12.0）

- [ ] Return Value Optimization (RVO)
- [ ] Named Return Value Optimization (NRVO)
- [ ] Perfect Forwarding（完全転送）
- [ ] Universal References（`T&&` in templates）

---

**作成日**: 2025-10-11
**ステータス**: 計画中（v0.11.0）
**担当**: @shadowlink0122
