# デフォルトメンバ（default修飾子）実装計画

**作成日**: 2025年10月9日  
**対象バージョン**: v0.10.0  
**優先度**: 🔴 高

---

## 📋 概要

構造体に1つだけ `default` 修飾子を持つメンバーを設定し、型推論による暗黙的アクセスを可能にする。これにより、構造体を基本型のラッパーとして透過的に使用できる。

---

## 🎯 目的

1. **型安全なラッパー型**: 基本型を構造体でラップしつつ、透過的にアクセス
2. **コードの簡潔化**: `.member` を省略して直接アクセス
3. **構造体の柔軟な使用**: 文脈に応じて構造体/基本型として振る舞う

---

## 📝 基本仕様

### 構文

```cb
struct String {
    default string value;
};

void main() {
    // 構造体リテラルとして初期化
    String s = {"Hello"};
    
    // デフォルトメンバへの暗黙的アクセス（読み取り）
    println(s);  // "Hello" と出力（s.value として解釈）
    
    // デフォルトメンバへの暗黙的代入
    s = "World";  // s.value = "World" として解釈
    println(s);   // "World"
    
    // 明示的なメンバーアクセスも可能
    s.value = "Direct";
    println(s.value);  // "Direct"
    
    // 構造体として明示的に扱う
    s = {"Explicit"};  // 構造体リテラル
}
```

---

## 🔍 詳細仕様

### 1. default修飾子の制約

**ルール**:
- 構造体に1つだけ `default` メンバーを設定可能
- 2つ以上の `default` メンバーがある場合はコンパイルエラー

**正しい例**:
```cb
struct String {
    default string value;
    int length;  // 他のメンバーは通常通り
};
```

**エラー例**:
```cb
struct Invalid {
    default int x;
    default int y;  // ❌ エラー: 複数のdefaultメンバー
};
```

### 2. 型推論による暗黙的アクセス

#### 2.1 代入時の挙動

**基本型の値が代入される場合**:
```cb
String s;
s = "text";  // s.value = "text" として解釈
```

判定ロジック:
1. 右辺の型がdefaultメンバーの型と一致するか確認
2. 一致すれば `s.value = 右辺` として解釈
3. 一致しなければ通常の構造体代入（構造体リテラル必須）

**構造体リテラルの場合**:
```cb
String s;
s = {"text"};  // 構造体全体の代入
```

#### 2.2 参照時の挙動

**基本型が期待される文脈**:
```cb
String s = {"Hello"};

// 関数引数
println(s);  // println(s.value) として解釈

// 変数への代入
string str = s;  // str = s.value として解釈

// 演算
string result = s + " World";  // s.value + " World"

// 比較
if (s == "Hello") { }  // s.value == "Hello"
```

**構造体が期待される文脈**:
```cb
String s1 = {"A"};
String s2 = s1;  // 構造体全体のコピー
```

### 3. 関数引数での動作

**パラメータが基本型の場合**:
```cb
func void print_string(string s) {
    println(s);
}

String wrapper = {"Hello"};
print_string(wrapper);  // wrapper.value が渡される
```

**パラメータが構造体型の場合**:
```cb
func void process(String s) {
    println(s.value);
}

String wrapper = {"Hello"};
process(wrapper);  // 構造体全体が渡される
```

### 4. 戻り値での動作

**戻り値が基本型の場合**:
```cb
func string get_string(String s) {
    return s;  // s.value を返す
}
```

**戻り値が構造体型の場合**:
```cb
func String create_string(string val) {
    String s = {val};
    return s;  // 構造体全体を返す
}
```

---

## 🔧 実装要件

### 1. 構文拡張

**Lexer**:
- キーワード追加: `default`

**Parser**:
- 構造体メンバー宣言で `default` 修飾子を解析
- 構造体リテラル `{}` と基本型の区別

### 2. AST拡張

```cpp
struct MemberVariable {
    std::string name;
    TypeInfo type;
    bool is_default;  // NEW: デフォルトメンバーか
    // ...
};

struct StructDef {
    std::string name;
    std::vector<MemberVariable> members;
    std::string default_member_name;  // NEW: デフォルトメンバーの名前
    bool has_default_member;          // NEW: デフォルトメンバーを持つか
    // ...
};
```

### 3. 型チェック

**検証項目**:
1. 構造体に複数の `default` メンバーが無いか
2. 代入時の型の整合性

**実装例**:
```cpp
void TypeChecker::validate_struct_definition(StructDef* struct_def) {
    int default_count = 0;
    std::string default_member;
    
    for (auto& member : struct_def->members) {
        if (member.is_default) {
            default_count++;
            default_member = member.name;
            
            if (default_count > 1) {
                throw std::runtime_error(
                    "Struct '" + struct_def->name + 
                    "' has multiple default members"
                );
            }
        }
    }
    
    if (default_count == 1) {
        struct_def->has_default_member = true;
        struct_def->default_member_name = default_member;
    }
}
```

### 4. 型推論と暗黙的変換

**代入時の変換**:
```cpp
void Interpreter::assign_to_struct(Variable& lhs, ExpressionNode* rhs) {
    auto rhs_type = infer_type(rhs);
    
    // 構造体がdefaultメンバーを持ち、右辺の型が一致する場合
    if (lhs.struct_def->has_default_member &&
        rhs_type == get_default_member_type(lhs.struct_def)) {
        
        // デフォルトメンバーへの代入
        auto value = evaluate(rhs);
        assign_struct_member(lhs, lhs.struct_def->default_member_name, value);
    } else {
        // 通常の構造体代入
        assign_struct_literal(lhs, rhs);
    }
}
```

**参照時の変換**:
```cpp
int64_t Interpreter::evaluate_struct_as_value(Variable& var, TypeInfo expected_type) {
    // 構造体がdefaultメンバーを持ち、期待される型と一致する場合
    if (var.struct_def->has_default_member &&
        get_default_member_type(var.struct_def) == expected_type) {
        
        // デフォルトメンバーの値を返す
        return get_struct_member(var, var.struct_def->default_member_name);
    }
    
    throw std::runtime_error("Cannot convert struct to value");
}
```

### 5. 構造体リテラルの判定

**構文による区別**:
```cb
String s;

s = "text";    // 基本型 → デフォルトメンバーへの代入
s = {"text"};  // 構造体リテラル → 構造体全体の代入
```

**パーサーでの判定**:
```cpp
// 構造体リテラルは必ず {} で囲まれる
bool is_struct_literal(ExpressionNode* expr) {
    return expr->type == NodeType::STRUCT_LITERAL;
}
```

---

## 📊 実装ステップ

### Phase 1: 基本構造（1週間）
- [ ] `default` キーワードの追加
- [ ] パーサーでの `default` 修飾子解析
- [ ] AST構造の拡張

### Phase 2: 型チェック（1週間）
- [ ] 複数のdefaultメンバーの検出
- [ ] デフォルトメンバーのメタデータ管理
- [ ] エラーメッセージの実装

### Phase 3: 暗黙的変換（2週間）
- [ ] 代入時の型推論と変換
- [ ] 参照時の型推論と変換
- [ ] 構造体リテラルとの区別

### Phase 4: テストと検証（1週間）
- [ ] 基本的なデフォルトメンバーテスト
- [ ] 関数引数/戻り値テスト
- [ ] エラーケーステスト

---

## 🧪 テストケース

### 1. 基本的なデフォルトメンバー
```cb
struct String {
    default string value;
};

void main() {
    String s = {"Hello"};
    
    // 暗黙的参照
    println(s);  // "Hello"
    
    // 暗黙的代入
    s = "World";
    println(s);  // "World"
    
    // 明示的アクセス
    s.value = "Direct";
    println(s.value);  // "Direct"
}
```

### 2. 型推論の動作
```cb
struct Integer {
    default int value;
};

func void print_int(int n) {
    println(n);
}

void main() {
    Integer i = {42};
    
    // 関数引数での暗黙的変換
    print_int(i);  // i.value が渡される
    
    // 変数への暗黙的変換
    int n = i;  // n = i.value
    println(n);  // 42
    
    // 演算での暗黙的変換
    int result = i + 10;  // i.value + 10
    println(result);  // 52
}
```

### 3. 構造体リテラルとの区別
```cb
struct Point {
    default int x;
    int y;
};

void main() {
    Point p = {10, 20};  // 構造体リテラル: x=10, y=20
    
    p = 5;  // p.x = 5 (yは変更されない)
    println(p.x);  // 5
    println(p.y);  // 20
    
    p = {15, 25};  // 構造体リテラル: x=15, y=25
    println(p.x);  // 15
    println(p.y);  // 25
}
```

### 4. 複数メンバーを持つ構造体
```cb
struct String {
    default string value;
    int length;
    
    String(string s) {
        this.value = s;
        this.length = strlen(s);
    }
};

void main() {
    String s("Hello");
    
    // 暗黙的参照（デフォルトメンバーのみ）
    println(s);  // "Hello"
    
    // 明示的アクセス（他のメンバー）
    println(s.length);  // 5
    
    // 暗黙的代入（デフォルトメンバーのみ）
    s = "World";
    println(s);  // "World"
    println(s.length);  // 5 (変更されていない!)
}
```

### 5. エラーケース
```cb
// エラー1: 複数のdefaultメンバー
struct Bad1 {
    default int x;
    default int y;  // ❌ コンパイルエラー
};

// エラー2: 型不一致
struct String {
    default string value;
};

void main() {
    String s;
    s = 123;  // ❌ エラー: intをstring型に代入できない
}

// エラー3: defaultメンバーが無い構造体への暗黙的代入
struct Point {
    int x;
    int y;
};

void main() {
    Point p;
    p = 10;  // ❌ エラー: defaultメンバーが無い
}
```

---

## 💡 使用例

### 例1: 型安全なString型

```cb
struct String {
    default string value;
};

impl String {
    String(string s) {
        this.value = s;
    }
    
    ~String() {
        // クリーンアップ
    }
}

func void print_message(string msg) {
    println("Message: " + msg);
}

void main() {
    String s("Hello");
    
    // 透過的に使用
    print_message(s);  // s.value が渡される
    
    if (s == "Hello") {  // s.value == "Hello"
        println("Match!");
    }
}
```

### 例2: 単位付き数値

```cb
struct Meters {
    default float value;
};

struct Kilometers {
    default float value;
};

func Meters to_meters(Kilometers km) {
    Meters m;
    m = km * 1000.0;  // km.value * 1000.0
    return m;
}

void main() {
    Kilometers km = {5.0};
    Meters m = to_meters(km);
    
    println(m);  // 5000.0
}
```

### 例3: オプショナル型（簡易版）

```cb
struct Optional {
    default int value;
    bool has_value;
};

impl Optional {
    Optional(int v) {
        this.value = v;
        this.has_value = true;
    }
    
    Optional() {
        this.value = 0;
        this.has_value = false;
    }
}

func Optional find(int[10] arr, int target) {
    for (int i = 0; i < 10; i++) {
        if (arr[i] == target) {
            return Optional(i);
        }
    }
    return Optional();  // not found
}

void main() {
    int[10] arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    Optional result = find(arr, 5);
    
    if (result.has_value) {
        println("Found at index: " + result);  // result.value
    }
}
```

---

## ⚠️ 注意事項

1. **暗黙的変換の範囲**: 過度に暗黙的な変換はコードの可読性を下げる可能性
2. **デバッグ**: 暗黙的変換がデバッグを困難にする可能性
3. **パフォーマンス**: 型推論のオーバーヘッド
4. **他の機能との相互作用**: コンストラクタ、デフォルト引数との組み合わせ

---

## 🔄 将来の拡張

1. **カスタム変換関数**: `operator string()` のような明示的な変換演算子
2. **複数のdefaultメンバー**: 文脈によって使い分け（要検討）
3. **const default**: 読み取り専用のデフォルトメンバー

---

## 🔗 関連機能との統合

### コンストラクタとの組み合わせ

```cb
struct String {
    default string value;
};

impl String {
    String() {
        this.value = "";
    }
    
    String(string s) {
        this.value = s;
    }
}

void main() {
    String s1;          // デフォルトコンストラクタ
    String s2("Hello"); // パラメータ付きコンストラクタ
    
    s1 = "World";       // デフォルトメンバーへの代入
    println(s1);        // "World"
}
```

---

**更新履歴**:
- 2025/10/09: 初版作成
