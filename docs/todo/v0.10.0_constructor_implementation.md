# コンストラクタ/デストラクタ実装計画

**作成日**: 2025年10月11日  
**対象バージョン**: v0.10.0  
**優先度**: 🔴 高  
**担当**: Core Team

---

## 📋 実装概要

構造体に対するコンストラクタとデストラクタを実装し、RAIIパターンによるリソース管理を実現します。

**設計方針**:
```cb
struct Point { int x; int y; }

impl Point {
    self(int px, int py) { self.x = px; self.y = py; }
    ~self() { println("Destroyed"); }
}
```

**重要な制約**:
- `impl Struct {}` 内のメンバー変数・メソッドはすべて **private**
- 通常のメソッドは `impl Interface for Struct` で定義

---

## 🎯 実装目標

### 必須機能（v0.10.0）

- [x] ✅ 仕様書の作成・修正
  - [x] ムーブコンストラクタを&&からポインタに変更
  - [x] impl Struct {} のカプセル化規則を明確化
  - [x] nullptr の動作を明確化
- [ ] 🔄 基本的なコンストラクタ
  - [ ] デフォルトコンストラクタ
  - [ ] パラメータ付きコンストラクタ
  - [ ] オーバーロード解決
- [ ] 🔄 デストラクタ
  - [ ] スコープ終了時の自動呼び出し
  - [ ] 破棄順序の保証（逆順）
  - [ ] 早期returnへの対応
- [ ] 🔄 `self` キーワード
  - [ ] コンストラクタ/デストラクタ内での使用
  - [ ] メンバーアクセス: `self.member`
- [ ] 🔄 配列のサポート
  - [ ] 配列要素の初期化
  - [ ] 配列要素の破棄
- [ ] 🔄 カプセル化
  - [ ] impl Struct {} 内のメソッドをprivateに制限
  - [ ] private メンバー変数
  - [ ] private メソッド

### 拡張機能（v0.11.0以降）

- [ ] ⏳ コピーコンストラクタ（const参照引数: `self(const Struct& other)`）
- [ ] ⏳ ムーブコンストラクタ（参照引数: `self(Struct& other)`）
- [ ] ⏳ コピー/ムーブの自動判定
- [ ] ⏳ デフォルト引数

---

## 📐 実装アーキテクチャ

### 1. Lexer拡張

**ファイル**: `src/frontend/recursive_parser/lexer.cpp`

```cpp
// 新しいキーワードの追加
enum class TokenType {
    // ... 既存のトークン ...
    SELF,      // "self" キーワード
    TILDE,     // "~" デストラクタ
    PRIVATE,   // "private" キーワード（将来実装）
};

Token Lexer::get_next_token() {
    // ... 既存の処理 ...
    
    // キーワード認識
    if (identifier == "self") {
        return Token(TokenType::SELF, "self");
    }
    
    // "~" の認識
    if (current_char == '~') {
        advance();
        return Token(TokenType::TILDE, "~");
    }
}
```

### 2. AST拡張

**ファイル**: `src/common/ast.h`

```cpp
// ノードタイプの追加
enum class ASTNodeType {
    // ... 既存のノードタイプ ...
    AST_CONSTRUCTOR_DECL,     // コンストラクタ宣言
    AST_DESTRUCTOR_DECL,      // デストラクタ宣言
    AST_SELF_KEYWORD,         // self キーワード
};

// ImplDefinitionの拡張
struct ImplDefinition {
    std::string interface_name;  // 空の場合、構造体用impl
    std::string struct_name;
    
    // NEW: コンストラクタ/デストラクタ
    std::vector<const ASTNode*> constructors;
    const ASTNode* destructor = nullptr;
    
    // 既存
    std::vector<const ASTNode*> methods;
    std::vector<const ASTNode*> impl_static_variables;
    
    // Helper関数
    const ASTNode* find_constructor(const std::vector<TypeInfo>& arg_types) const {
        for (const auto* ctor : constructors) {
            if (matches_signature(ctor, arg_types)) {
                return ctor;
            }
        }
        return nullptr;
    }
    
    bool has_default_constructor() const {
        for (const auto* ctor : constructors) {
            if (ctor->parameters.empty()) {
                return true;
            }
        }
        return false;
    }
};

// コンストラクタノード
struct ASTNode {
    // ... 既存のメンバー ...
    
    // コンストラクタ用（AST_CONSTRUCTOR_DECLの場合）
    std::vector<std::unique_ptr<ASTNode>> constructor_params;
    std::unique_ptr<ASTNode> constructor_body;
    bool is_default_constructor;
    
    // デストラクタ用（AST_DESTRUCTOR_DECLの場合）
    std::unique_ptr<ASTNode> destructor_body;
};
```

### 3. Parser拡張

**ファイル**: `src/frontend/recursive_parser/parsers/interface_parser.cpp`

```cpp
class InterfaceParser {
public:
    // impl宣言の解析
    ASTNode* parseImplDeclaration();
    
private:
    // 構造体用implの解析
    ASTNode* parseStructImpl();
    
    // interface用implの解析（既存）
    ASTNode* parseInterfaceImpl();
    
    // コンストラクタの解析
    ASTNode* parseConstructor(const std::string& struct_name);
    
    // デストラクタの解析
    ASTNode* parseDestructor(const std::string& struct_name);
    
    // コンストラクタ/デストラクタの判定
    bool isConstructor();
    bool isDestructor();
};

ASTNode* InterfaceParser::parseImplDeclaration() {
    consume(TokenType::IMPL);
    
    std::string first_identifier = parseIdentifier();
    
    // パターン判定
    if (current_token->type == TokenType::LBRACE) {
        // impl Struct { ... }
        return parseStructImpl(first_identifier);
    } else if (current_token->type == TokenType::FOR) {
        // impl Interface for Struct { ... }
        consume(TokenType::FOR);
        std::string struct_name = parseIdentifier();
        return parseInterfaceImpl(first_identifier, struct_name);
    } else {
        error("Expected '{' or 'for' after impl declaration");
    }
}

ASTNode* InterfaceParser::parseStructImpl(const std::string& struct_name) {
    auto impl_node = std::make_unique<ASTNode>();
    impl_node->node_type = ASTNodeType::AST_IMPL_DECL;
    impl_node->name = struct_name;
    
    consume(TokenType::LBRACE);
    
    while (current_token->type != TokenType::RBRACE) {
        if (isConstructor()) {
            auto ctor = parseConstructor(struct_name);
            impl_node->impl_constructors.push_back(std::move(ctor));
        } else if (isDestructor()) {
            if (impl_node->impl_destructor) {
                error("Multiple destructors are not allowed");
            }
            impl_node->impl_destructor = parseDestructor(struct_name);
        } else if (current_token->type == TokenType::PRIVATE) {
            // 将来実装
            auto priv = parsePrivateMember();
            impl_node->impl_private_members.push_back(std::move(priv));
        } else if (current_token->type == TokenType::STATIC) {
            auto static_var = parseStaticVariable();
            impl_node->impl_static_variables.push_back(std::move(static_var));
        } else {
            auto method = parseMethod();
            impl_node->impl_methods.push_back(std::move(method));
        }
    }
    
    consume(TokenType::RBRACE);
    return impl_node.release();
}

bool InterfaceParser::isConstructor() {
    // "self" "(" のパターン
    return current_token->type == TokenType::SELF &&
           peek()->type == TokenType::LPAREN;
}

bool InterfaceParser::isDestructor() {
    // "~" "self" "(" のパターン
    return current_token->type == TokenType::TILDE &&
           peek()->type == TokenType::SELF;
}

ASTNode* InterfaceParser::parseConstructor(const std::string& struct_name) {
    auto ctor_node = std::make_unique<ASTNode>();
    ctor_node->node_type = ASTNodeType::AST_CONSTRUCTOR_DECL;
    ctor_node->name = struct_name;
    
    consume(TokenType::SELF);
    consume(TokenType::LPAREN);
    
    // パラメータの解析
    while (current_token->type != TokenType::RPAREN) {
        auto param = parseParameter();
        ctor_node->constructor_params.push_back(std::move(param));
        
        if (current_token->type == TokenType::COMMA) {
            consume(TokenType::COMMA);
        }
    }
    
    consume(TokenType::RPAREN);
    
    // 本体の解析
    ctor_node->constructor_body = parseBlock();
    
    ctor_node->is_default_constructor = ctor_node->constructor_params.empty();
    
    return ctor_node.release();
}

ASTNode* InterfaceParser::parseDestructor(const std::string& struct_name) {
    auto dtor_node = std::make_unique<ASTNode>();
    dtor_node->node_type = ASTNodeType::AST_DESTRUCTOR_DECL;
    dtor_node->name = struct_name;
    
    consume(TokenType::TILDE);
    consume(TokenType::SELF);
    consume(TokenType::LPAREN);
    consume(TokenType::RPAREN);
    
    // 本体の解析
    dtor_node->destructor_body = parseBlock();
    
    return dtor_node.release();
}
```

### 4. Interpreter拡張

**ファイル**: `src/backend/interpreter/core/interpreter.h`

```cpp
class Interpreter {
private:
    // スコープ情報の拡張
    struct ScopeInfo {
        std::map<std::string, Variable> variables;
        std::vector<std::string> destruction_order;  // NEW: デストラクタ呼び出し順序
        bool is_function_scope;
        bool is_loop_scope;
    };
    
    std::vector<ScopeInfo> scope_stack_;
    
    // self ポインタ
    Variable* current_self_ = nullptr;
    
    // ImplDefinition の管理
    std::map<std::string, ImplDefinition> struct_impl_map_;  // struct名 -> impl定義
    
public:
    // コンストラクタ/デストラクタ関連
    void call_constructor(Variable& instance,
                         const ASTNode* ctor_node,
                         const std::vector<Variable>& args);
    
    void call_destructor(Variable& instance);
    
    const ASTNode* find_constructor(const std::string& struct_name,
                                   const std::vector<TypeInfo>& arg_types);
    
    const ASTNode* find_destructor(const std::string& struct_name);
    
    // スコープ管理の拡張
    void enter_scope(bool is_function = false);
    void exit_scope();  // デストラクタを自動呼び出し
    
    // 変数宣言の拡張
    void declare_struct_variable(const ASTNode* decl_node);
    
    // self アクセス
    Variable* get_self() { return current_self_; }
    void set_self(Variable* self) { current_self_ = self; }
};
```

**ファイル**: `src/backend/interpreter/core/interpreter.cpp`

```cpp
void Interpreter::register_impl_definition(const ImplDefinition& impl_def) {
    if (impl_def.interface_name.empty()) {
        // 構造体用impl
        struct_impl_map_[impl_def.struct_name] = impl_def;
        debug_msg(DebugMsgId::PARSE_IMPL_DEF,
                 ("Registered struct impl: " + impl_def.struct_name).c_str());
    } else {
        // interface用impl（既存の処理）
        interface_operations_->register_impl_definition(impl_def);
    }
}

void Interpreter::declare_struct_variable(const ASTNode* decl_node) {
    const std::string& var_name = decl_node->name;
    const std::string& struct_name = decl_node->type_name;
    
    // 構造体型の変数を作成
    Variable var;
    var.type = TypeInfo::STRUCT;
    var.struct_name = struct_name;
    
    // 構造体の定義を取得してメンバー初期化
    auto struct_def = find_struct_definition(struct_name);
    if (struct_def) {
        initialize_struct_members(var, struct_def);
    }
    
    // コンストラクタの検索
    std::vector<TypeInfo> arg_types;
    for (const auto& arg : decl_node->arguments) {
        arg_types.push_back(evaluate_expression(arg.get()).type);
    }
    
    const ASTNode* ctor = find_constructor(struct_name, arg_types);
    
    if (ctor) {
        // 引数を評価
        std::vector<Variable> args;
        for (const auto& arg : decl_node->arguments) {
            args.push_back(evaluate_expression(arg.get()));
        }
        
        // コンストラクタ呼び出し
        call_constructor(var, ctor, args);
    } else if (!decl_node->arguments.empty()) {
        // コンストラクタが見つからないがコンストラクタ引数がある
        error("No matching constructor for struct '" + struct_name + 
              "' with given arguments");
    }
    
    // スコープに変数追加
    add_variable_to_current_scope(var_name, var);
    
    // デストラクタが定義されている場合、破棄順序に追加
    if (find_destructor(struct_name)) {
        current_scope().destruction_order.push_back(var_name);
    }
}

void Interpreter::call_constructor(Variable& instance,
                                   const ASTNode* ctor_node,
                                   const std::vector<Variable>& args) {
    debug_msg(DebugMsgId::FUNC_CALL,
             ("Calling constructor: " + ctor_node->name).c_str());
    
    // self を instance に設定
    Variable* old_self = current_self_;
    current_self_ = &instance;
    
    // 新しいスコープに入る
    enter_scope();
    
    // パラメータを引数で初期化
    for (size_t i = 0; i < args.size(); i++) {
        const auto& param = ctor_node->constructor_params[i];
        add_variable_to_current_scope(param->name, args[i]);
    }
    
    // コンストラクタ本体を実行
    execute_statement(ctor_node->constructor_body.get());
    
    // スコープを抜ける
    exit_scope();
    
    // self を復元
    current_self_ = old_self;
}

void Interpreter::call_destructor(Variable& instance) {
    const ASTNode* dtor = find_destructor(instance.struct_name);
    if (!dtor) {
        return;  // デストラクタが定義されていない
    }
    
    debug_msg(DebugMsgId::FUNC_CALL,
             ("Calling destructor: ~" + instance.struct_name).c_str());
    
    // self を instance に設定
    Variable* old_self = current_self_;
    current_self_ = &instance;
    
    // 新しいスコープに入る
    enter_scope();
    
    // デストラクタ本体を実行
    execute_statement(dtor->destructor_body.get());
    
    // スコープを抜ける
    exit_scope();
    
    // self を復元
    current_self_ = old_self;
}

const ASTNode* Interpreter::find_constructor(
    const std::string& struct_name,
    const std::vector<TypeInfo>& arg_types) {
    
    auto it = struct_impl_map_.find(struct_name);
    if (it == struct_impl_map_.end()) {
        return nullptr;  // impl定義なし
    }
    
    const ImplDefinition& impl_def = it->second;
    return impl_def.find_constructor(arg_types);
}

const ASTNode* Interpreter::find_destructor(const std::string& struct_name) {
    auto it = struct_impl_map_.find(struct_name);
    if (it == struct_impl_map_.end()) {
        return nullptr;
    }
    
    return it->second.destructor;
}

void Interpreter::enter_scope(bool is_function) {
    ScopeInfo scope;
    scope.is_function_scope = is_function;
    scope.is_loop_scope = false;
    scope_stack_.push_back(scope);
    
    debug_msg(DebugMsgId::SCOPE_ENTER,
             ("Scope depth: " + std::to_string(scope_stack_.size())).c_str());
}

void Interpreter::exit_scope() {
    if (scope_stack_.empty()) {
        error("Cannot exit scope: no scope to exit");
        return;
    }
    
    ScopeInfo& scope = scope_stack_.back();
    
    // デストラクタを逆順で呼び出し
    for (auto it = scope.destruction_order.rbegin();
         it != scope.destruction_order.rend(); ++it) {
        
        auto var_it = scope.variables.find(*it);
        if (var_it != scope.variables.end()) {
            Variable& var = var_it->second;
            
            if (var.type == TypeInfo::STRUCT) {
                call_destructor(var);
            }
        }
    }
    
    // スコープをpop
    scope_stack_.pop_back();
    
    debug_msg(DebugMsgId::SCOPE_EXIT,
             ("Scope depth: " + std::to_string(scope_stack_.size())).c_str());
}

Variable Interpreter::evaluate_expression(const ASTNode* node) {
    // ... 既存の処理 ...
    
    switch (node->node_type) {
        // ... 既存のケース ...
        
        case ASTNodeType::AST_SELF_KEYWORD:
            if (!current_self_) {
                error("'self' can only be used inside impl methods/constructors/destructors");
            }
            return *current_self_;
        
        // ... その他のケース ...
    }
}
```

### 5. 配列のコンストラクタ/デストラクタ

**ファイル**: `src/backend/interpreter/managers/variables/array_operations.cpp`

```cpp
void ArrayOperations::initialize_struct_array(Variable& array_var) {
    if (array_var.type != TypeInfo::ARRAY) {
        return;
    }
    
    // 配列要素の型が構造体の場合
    if (array_var.element_type == TypeInfo::STRUCT) {
        const std::string& struct_name = array_var.struct_name;
        
        // デフォルトコンストラクタの検索
        const ASTNode* default_ctor = 
            interpreter_->find_constructor(struct_name, {});
        
        if (default_ctor) {
            // 各要素でデフォルトコンストラクタを呼び出し
            for (auto& element : array_var.array_elements) {
                interpreter_->call_constructor(element, default_ctor, {});
            }
        }
    }
}

void ArrayOperations::destroy_struct_array(Variable& array_var) {
    if (array_var.type != TypeInfo::ARRAY ||
        array_var.element_type != TypeInfo::STRUCT) {
        return;
    }
    
    // 配列要素を逆順でデストラクタ呼び出し
    for (auto it = array_var.array_elements.rbegin();
         it != array_var.array_elements.rend(); ++it) {
        interpreter_->call_destructor(*it);
    }
}
```

---

## 🧪 テスト計画

### Phase 1: 基本的なコンストラクタ/デストラクタ

**テストファイル**: `tests/cases/constructor/test_basic_constructor.cb`

```cb
struct Counter {
    int value;
}

impl Counter {
    self() {
        self.value = 0;
        println("Default constructor");
    }
    
    self(int v) {
        self.value = v;
        println("Parameterized constructor: ", v);
    }
    
    ~self() {
        println("Destructor: ", self.value);
    }
}

void main() {
    Counter c1;
    println("c1.value = ", c1.value);
    
    Counter c2(42);
    println("c2.value = ", c2.value);
}

// 期待される出力:
// Default constructor
// c1.value = 0
// Parameterized constructor: 42
// c2.value = 42
// Destructor: 42
// Destructor: 0
```

**テストファイル**: `tests/cases/constructor/test_destructor_order.cb`

```cb
struct Logger {
    string name;
}

impl Logger {
    self(string n) {
        self.name = n;
        println("Created: ", n);
    }
    
    ~self() {
        println("Destroyed: ", self.name);
    }
}

void main() {
    Logger a("First");
    Logger b("Second");
    Logger c("Third");
}

// 期待される出力:
// Created: First
// Created: Second
// Created: Third
// Destroyed: Third
// Destroyed: Second
// Destroyed: First
```

### Phase 2: スコープとデストラクタ

**テストファイル**: `tests/cases/constructor/test_scope_destructor.cb`

```cb
struct Resource {
    int id;
}

impl Resource {
    self(int i) {
        self.id = i;
        println("Resource acquired: ", i);
    }
    
    ~self() {
        println("Resource released: ", self.id);
    }
}

void main() {
    Resource r1(1);
    {
        Resource r2(2);
        {
            Resource r3(3);
        }
        Resource r4(4);
    }
    Resource r5(5);
}

// 期待される出力:
// Resource acquired: 1
// Resource acquired: 2
// Resource acquired: 3
// Resource released: 3
// Resource acquired: 4
// Resource released: 4
// Resource released: 2
// Resource acquired: 5
// Resource released: 5
// Resource released: 1
```

### Phase 3: 配列のコンストラクタ/デストラクタ

**テストファイル**: `tests/cases/constructor/test_array_constructor.cb`

```cb
struct Item {
    int id;
}

impl Item {
    self() {
        self.id = 0;
        println("Item constructed");
    }
    
    ~self() {
        println("Item destructed");
    }
}

void main() {
    Item[3] items;
    println("Array initialized");
}

// 期待される出力:
// Item constructed
// Item constructed
// Item constructed
// Array initialized
// Item destructed
// Item destructed
// Item destructed
```

### Phase 4: 早期returnとデストラクタ

**テストファイル**: `tests/cases/constructor/test_early_return.cb`

```cb
struct Guard {
    string name;
}

impl Guard {
    self(string n) {
        self.name = n;
        println("Guard entered: ", n);
    }
    
    ~self() {
        println("Guard exited: ", self.name);
    }
}

void test(bool early_exit) {
    Guard g1("outer");
    
    if (early_exit) {
        Guard g2("inner");
        println("Early return");
        return;
    }
    
    println("Normal path");
}

void main() {
    println("=== Test 1: Early return ===");
    test(true);
    
    println("\n=== Test 2: Normal path ===");
    test(false);
}

// 期待される出力:
// === Test 1: Early return ===
// Guard entered: outer
// Guard entered: inner
// Early return
// Guard exited: inner
// Guard exited: outer
//
// === Test 2: Normal path ===
// Guard entered: outer
// Normal path
// Guard exited: outer
```

### Phase 5: 統合テスト

**テストファイル**: `tests/cases/constructor/test_comprehensive.cb`

```cb
struct BankAccount {
    string owner;
}

impl BankAccount {
    private int balance;
    
    self(string name, int initial) {
        self.owner = name;
        balance = initial;
        println("Account created for ", name, " with balance ", initial);
    }
    
    ~self() {
        println("Account closed for ", self.owner, " with final balance ", balance);
    }
    
    void deposit(int amount) {
        balance = balance + amount;
        println(self.owner, " deposited ", amount, ", new balance: ", balance);
    }
    
    void withdraw(int amount) {
        if (balance >= amount) {
            balance = balance - amount;
            println(self.owner, " withdrew ", amount, ", new balance: ", balance);
        } else {
            println(self.owner, " insufficient funds");
        }
    }
    
    int getBalance() {
        return balance;
    }
}

void main() {
    BankAccount alice("Alice", 1000);
    alice.deposit(500);
    alice.withdraw(300);
    
    {
        BankAccount bob("Bob", 2000);
        bob.deposit(1000);
    }
    
    println("Alice final balance: ", alice.getBalance());
}

// 期待される出力:
// Account created for Alice with balance 1000
// Alice deposited 500, new balance: 1500
// Alice withdrew 300, new balance: 1200
// Account created for Bob with balance 2000
// Bob deposited 1000, new balance: 3000
// Account closed for Bob with final balance 3000
// Alice final balance: 1200
// Account closed for Alice with final balance 1200
```

---

## 📊 実装スケジュール

### Week 1-2: 基本構造の実装

- [ ] Day 1-2: Lexer拡張（`self`, `~` トークン）
- [ ] Day 3-4: AST拡張（ConstructorNode, DestructorNode）
- [ ] Day 5-7: Parser拡張（`impl Struct {}` 解析）
- [ ] Day 8-10: 基本的な構文エラー検出とテスト

**マイルストーン**: 構文解析が正しく動作し、ASTが構築される

### Week 3-4: コンストラクタの実装

- [ ] Day 11-13: Interpreter拡張（コンストラクタ呼び出し機構）
- [ ] Day 14-16: デフォルトコンストラクタの自動呼び出し
- [ ] Day 17-19: パラメータ付きコンストラクタ
- [ ] Day 20-22: オーバーロード解決
- [ ] Day 23-24: `self` キーワードの実装
- [ ] Day 25-28: 配列要素の初期化

**マイルストーン**: コンストラクタが正しく呼び出される

### Week 5-6: デストラクタの実装

- [ ] Day 29-31: スコープ管理機構の拡張
- [ ] Day 32-34: デストラクタの自動呼び出し
- [ ] Day 35-37: 破棄順序の実装（逆順）
- [ ] Day 38-40: 早期return時のデストラクタ呼び出し
- [ ] Day 41-42: 配列要素の破棄

**マイルストーン**: デストラクタが正しいタイミングで呼び出される

### Week 7: テストと最適化

- [ ] Day 43-45: 包括的なテストケース作成
- [ ] Day 46-47: バグ修正
- [ ] Day 48-49: パフォーマンステスト・最適化

**マイルストーン**: v0.10.0リリース準備完了

---

## ⚠️ 実装上の注意事項

### 1. 既存機能との統合

#### defer文との関係

```cb
struct Resource { int id; }
impl Resource {
    self(int i) { self.id = i; }
    ~self() { println("Destructor: ", self.id); }
}

void main() {
    Resource r(1);
    defer { println("Defer 1"); }
    Resource r2(2);
    defer { println("Defer 2"); }
}

// 実行順序の保証:
// 1. "Defer 2" (最後のdefer)
// 2. Destructor: 2 (r2 のデストラクタ)
// 3. "Defer 1" (最初のdefer)
// 4. Destructor: 1 (r のデストラクタ)
```

**実装**: defer文とデストラクタの実行順序を適切に管理する必要があります。

#### default メンバーとの併用

```cb
struct Wrapper {
    default int value;
}

impl Wrapper {
    self() {
        self.value = 0;  // default メンバーも初期化可能
    }
    
    self(int v) {
        self.value = v;
    }
}
```

**実装**: default メンバーを持つ構造体でもコンストラクタが正しく動作するようにする。

#### interface実装との分離

```cb
interface Printable {
    string toString();
}

struct Point { int x; int y; }

// ✅ OK: 別々のimplブロック
impl Point {
    self(int px, int py) { self.x = px; self.y = py; }
}

impl Printable for Point {
    string toString() { return "Point"; }
}

// ❌ NG: 同じimplブロックには記述不可
// impl Printable for Point {
//     self(int px, int py) { }  // エラー
// }
```

**実装**: `impl Struct {}` と `impl Interface for Struct {}` を明確に区別する。

### 2. エラーメッセージ

```
// 重複したコンストラクタ
Error: Multiple constructors with the same signature in impl for 'Point'
  --> test.cb:5
   |
 5 |     self(int x, int y) { ... }
   |     ^^^^^^^^^^^^^^^^^^^^^^^ duplicate constructor
   |
Note: First defined here:
  --> test.cb:3
   |
 3 |     self(int x, int y) { ... }
   |     ^^^^^^^^^^^^^^^^^^^^^^^

// コンストラクタが見つからない
Error: No matching constructor for struct 'Point' with arguments (int, string)
  --> test.cb:15
   |
15 |     Point p(10, "hello");
   |             ^^^^^^^^^^^^ no matching constructor
   |
Note: Available constructors:
   - Point()
   - Point(int, int)

// 複数のデストラクタ
Error: Multiple destructors are not allowed
  --> test.cb:10
   |
10 |     ~self() { ... }
   |     ^^^^^^^^^^^^^^^ second destructor
   |
Note: First defined here:
  --> test.cb:8
   |
 8 |     ~self() { ... }
   |     ^^^^^^^^^^^^^^^
```

### 3. デバッグメッセージ

```cpp
// デバッグメッセージの追加
enum class DebugMsgId {
    // ... 既存のID ...
    CONSTRUCTOR_CALL,      // コンストラクタ呼び出し
    DESTRUCTOR_CALL,       // デストラクタ呼び出し
    SCOPE_DESTRUCTOR,      // スコープ終了時のデストラクタ
};

// 使用例
debug_msg(DebugMsgId::CONSTRUCTOR_CALL,
         ("Calling constructor: " + struct_name + 
          "(" + arg_types + ")").c_str());

debug_msg(DebugMsgId::DESTRUCTOR_CALL,
         ("Calling destructor: ~" + struct_name).c_str());
```

### 4. パフォーマンス最適化

- **配列の初期化**: 大きな配列での初期化コストを最小化
- **コンストラクタのインライン化**: 小さなコンストラクタは最適化
- **RVO（Return Value Optimization）**: 不要なコピーを削減（将来実装）

---

## 🔄 将来の拡張（v0.11.0以降）

### コピーコンストラクタ

```cb
struct Point { int x; int y; }

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    // コピーコンストラクタ
    self(const Point other) {
        self.x = other.x;
        self.y = other.y;
        println("Copied");
    }
}
```

### ムーブコンストラクタ

```cb
struct Buffer { int* data; int size; }

impl Buffer {
    // ムーブコンストラクタ
    self(Buffer&& other) {
        self.data = other.data;
        self.size = other.size;
        other.data = nullptr;
        other.size = 0;
    }
}
```

### private メンバー

```cb
struct BankAccount { string owner; }

impl BankAccount {
    private int balance;  // private変数
    
    self(string name, int initial) {
        self.owner = name;
        balance = initial;
    }
}
```

---

## 📚 関連ドキュメント

- [コンストラクタ/デストラクタ仕様書](../features/constructor_destructor.md)
- [Cb言語仕様書](../spec.md)
- [v0.10.0実装ロードマップ](./v0.10.0_implementation_plan.md)

---

**作成日**: 2025年10月11日  
**最終更新**: 2025年10月11日  
**ステータス**: 📝 実装準備中
