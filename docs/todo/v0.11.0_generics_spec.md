# Cb言語 v0.11.0 ジェネリクス仕様

**作成日**: 2025年10月12日  
**ステータス**: 設計段階  
**優先度**: 🔴 最優先

---

## 📋 目次

1. [概要](#概要)
2. [基本構文](#基本構文)
3. [型制約](#型制約)
4. [Interface とジェネリクス](#interfaceとジェネリクス)
5. [実装の詳細](#実装の詳細)
6. [矛盾の解決](#矛盾の解決)
7. [実装計画](#実装計画)

---

## 概要

Cb言語のジェネリクス機能は、RustとC++のテンプレートを参考に、使いやすさと型安全性を両立します。

### 設計目標

1. **型安全性**: コンパイル時に型チェック
2. **柔軟性**: 構造体、関数、interfaceで使用可能
3. **制約サポート**: 型パラメータに制約を設定可能
4. **推論**: 関数呼び出し時の型パラメータ推論
5. **明示性**: 曖昧さを排除し、明確な構文

---

## 基本構文

### 1. ジェネリック構造体

#### 単一型パラメータ

```cb
struct Box<T> {
    T value;
}

void main() {
    Box<int> int_box;
    int_box.value = 42;
    
    Box<string> str_box;
    str_box.value = "Hello";
}
```

#### 複数型パラメータ

```cb
struct Pair<T1, T2> {
    T1 first;
    T2 second;
}

void main() {
    Pair<int, string> p;
    p.first = 1;
    p.second = "Alice";
}
```

#### ネストしたジェネリクス

```cb
struct Nested<T> {
    Box<T> inner;
    T value;
}

void main() {
    Nested<int> n;
    n.inner.value = 10;
    n.value = 20;
}
```

---

### 2. ジェネリック関数

#### 基本形

```cb
T max<T>(T a, T b) {
    if (a > b) {
        return a;
    }
    return b;
}

void main() {
    int i = max<int>(10, 20);        // 明示的な型指定
    long l = max<long>(100L, 200L);  // 明示的な型指定
}
```

#### 型推論（将来的な拡張）

```cb
T max<T>(T a, T b) {
    if (a > b) {
        return a;
    }
    return b;
}

void main() {
    int i = max(10, 20);      // ✅ T=int と推論
    long l = max(100L, 200L); // ✅ T=long と推論
}
```

#### 複数型パラメータ

```cb
T2 convert<T1, T2>(T1 input) {
    // 型変換処理
    T2 result;
    // ...
    return result;
}

void main() {
    int i = 42;
    long l = convert<int, long>(i);
}
```

---

## 型制約

### 1. Union型制約

特定の型のみを受け入れる制約。

```cb
// 整数型のみ受け入れる
struct NumericBox<T: int | tiny | short | long> {
    T value;
}

void main() {
    NumericBox<int> box1;     // ✅ OK
    NumericBox<string> box2;  // ❌ エラー: stringは制約を満たさない
}
```

### 2. Interface制約

Interface を実装している型のみを受け入れる。

```cb
interface Printable {
    void print();
}

struct Point {
    int x;
    int y;
}

impl Printable for Point {
    void print() {
        println("Point(", self.x, ", ", self.y, ")");
    }
}

// Printableを実装している型のみ受け入れる
void print_all<T: Printable>(T item) {
    item.print();
}

void main() {
    Point p = {x: 10, y: 20};
    print_all<Point>(p);  // ✅ OK
}
```

### 3. 複合制約

複数の制約を組み合わせる。

```cb
interface Comparable {
    int compare(const self& other);
}

// Comparableを実装し、かつint, long, shortのいずれか
struct Container<T: Comparable & (int | long | short)> {
    T value;
}
```

---

## Interface とジェネリクス

### 1. ジェネリックInterface

Interface自体に型パラメータを持たせる。

```cb
interface Container<T> {
    void add(T item);
    T get(int index);
    int size();
}

struct List<T> {
    T[100] items;
    int count;
}

impl Container<T> for List<T> {
    void add(T item) {
        self.items[self.count] = item;
        self.count = self.count + 1;
    }
    
    T get(int index) {
        return self.items[index];
    }
    
    int size() {
        return self.count;
    }
}

void main() {
    List<int> list;
    list.add(10);
    list.add(20);
    println(list.get(0));  // 10
}
```

### 2. 型パラメータの一致

**ルール**: `impl I<T> for S<T>` の場合、Interfaceと構造体の型パラメータは一致する必要がある。

```cb
interface Process<T> {
    T process(T input);
}

struct Processor<T> {
    T value;
}

// ✅ OK: 型パラメータが一致
impl Process<T> for Processor<T> {
    T process(T input) {
        return input;
    }
}

// ❌ エラー: 型パラメータが一致しない
impl Process<int> for Processor<T> {
    int process(int input) {
        return input;
    }
}
```

### 3. 型パラメータの省略

構造体にジェネリクスが設定されている場合、Interfaceの型パラメータを省略可能。

```cb
interface Show {
    void show();
}

struct Box<T> {
    T value;
}

// 省略形: Tは暗黙的に使用可能
impl Show for Box<T> {
    void show() {
        println("Box with value");
    }
}

// 完全形（上記と同等）
impl Show for Box<T> {
    void show() {
        println("Box with value");
    }
}
```

### 4. 部分的なインスタンス化

構造体が型制約を持つ場合、特定の型に対してのみInterfaceを実装可能。

```cb
interface Numeric {
    T add(T other);
}

struct Calculator<T: int | long | short> {
    T value;
}

// intに対してのみ実装
impl Numeric for Calculator<int> {
    int add(int other) {
        return self.value + other;
    }
}

void main() {
    Calculator<int> calc_int;
    calc_int.value = 10;
    int result = calc_int.add(5);  // ✅ OK
    
    Calculator<long> calc_long;
    // calc_long.add(5L);  // ❌ エラー: longに対するNumericは実装されていない
}
```

### 5. 型制約に対するInterface実装

**⚠️ 矛盾の指摘**: 元の提案にあった以下の構文は曖昧です:

```cb
// ❓ これは何を意味するのか？
impl I for <T: int | ...> {
    T func()
}
```

**解決案**: この構文は削除し、代わりに以下のいずれかを使用:

#### Option A: 構造体に対する実装

```cb
struct S<T: int | long | short> {
    T value;
}

impl I for S<T> {
    T func() {
        return self.value;
    }
}
```

#### Option B: すべての制約型に対する実装（将来的な拡張）

```cb
// すべてのint, long, shortに対してIを実装
impl<T: int | long | short> I for T {
    T func() {
        return self;
    }
}
```

---

### 6. ジェネリックコンストラクタ

構造体がジェネリックの場合、コンストラクタも型パラメータを使用。

```cb
struct Box<T> {
    T value;
}

impl Box<T> {
    self(T v) {
        self.value = v;
    }
    
    T get() {
        return self.value;
    }
    
    void set(T v) {
        self.value = v;
    }
}

void main() {
    Box<int> int_box(42);
    println(int_box.get());  // 42
    
    Box<string> str_box("Hello");
    println(str_box.get());  // Hello
}
```

#### 型制約付きコンストラクタ

```cb
struct NumericBox<T: int | long | short> {
    T value;
}

impl NumericBox<T> {
    self(T v) {
        self.value = v;
    }
    
    T add(T other) {
        return self.value + other;
    }
}

void main() {
    NumericBox<int> box(10);
    int result = box.add(5);  // 15
}
```

---

## 矛盾の解決

### 1. Interface定義時の型パラメータ

**元の提案**:
```cb
interface I<T> for S<T> {
    T func1();
}
```

**問題**: `interface` 定義に `for S<T>` は含まれない。Interface定義とimpl宣言を混同している。

**正しい構文**:
```cb
// Interface定義（for句なし）
interface I<T> {
    T func1();
    T func2(T arg);
}

// impl宣言（for句あり）
impl I<T> for S<T> {
    T func1() {
        // 実装
    }
    
    T func2(T arg) {
        // 実装
    }
}
```

---

### 2. 型パラメータの省略規則

**明確化**:

1. **Interfaceがジェネリック、構造体もジェネリック**
   ```cb
   interface I<T> { ... }
   struct S<T> { ... }
   
   // 完全形
   impl I<T> for S<T> { ... }
   
   // 省略不可: 型パラメータは一致する必要がある
   ```

2. **Interfaceが非ジェネリック、構造体がジェネリック**
   ```cb
   interface I { ... }
   struct S<T> { ... }
   
   // 完全形
   impl I for S<T> { ... }
   
   // 省略可能: 構造体の型パラメータは自明
   impl I for S { ... }  // ✅ Tは暗黙的に使用可能
   ```

3. **部分的なインスタンス化**
   ```cb
   interface I { ... }
   struct S<T: int | long | short> { ... }
   
   // intに対してのみ実装
   impl I for S<int> { ... }
   ```

---

### 3. 可変長引数とジェネリクス

**元の提案**:
```cb
interface I<T> {
    T func2(T...);
}
```

**問題**: `T...` の意味が不明確（可変長引数？配列？）

**解決案**: 可変長引数はv0.11.0の範囲外とし、将来的な拡張として検討。

**代替案（配列を使用）**:
```cb
interface I<T> {
    T func2(T[] args, int count);
}
```

---

### 4. implブロックの型パラメータ宣言

**元の提案**:
```cb
impl I<T: type | ...> {
    self(T ...)
}
```

**問題**:
- `type` という制約は不明確
- `T ...` の意味が不明確

**正しい構文**:
```cb
struct Box<T: int | long | short> {
    T value;
}

impl Box<T> {
    self(T v) {
        self.value = v;
    }
}
```

---

## 実装の詳細

### Phase 1: 基本的なジェネリクス（2週間）

#### 1.1 構文解析
- `<T>`, `<T1, T2>` のパース
- `struct S<T> { ... }` の解析
- `T func<T>(...) { ... }` の解析

#### 1.2 型パラメータの管理
- 型パラメータテーブルの作成
- スコープ管理（型パラメータの可視性）

#### 1.3 インスタンス化
- `S<int>` → 具体的な構造体定義を生成
- テンプレートのキャッシュ

#### テストケース
- 単一型パラメータの構造体
- 複数型パラメータの構造体
- ネストしたジェネリック構造体
- ジェネリック関数

---

### Phase 2: 型制約（1週間）

#### 2.1 Union型制約
- `<T: int | long | short>` の解析
- 制約違反の検出とエラー報告

#### 2.2 Interface制約（将来的な拡張）
- `<T: Printable>` の解析
- Interface実装の検証

#### テストケース
- Union型制約の検証
- 制約違反時のエラーメッセージ

---

### Phase 3: Interface統合（1週間）

#### 3.1 ジェネリックInterface
- `interface I<T> { ... }` の解析
- 型パラメータの伝播

#### 3.2 ジェネリックimpl
- `impl I<T> for S<T> { ... }` の解析
- 型パラメータの一致検証
- 部分的なインスタンス化のサポート

#### テストケース
- ジェネリックInterfaceの定義と実装
- 型パラメータの一致検証
- 部分的なインスタンス化

---

### Phase 4: 型推論（将来的な拡張）

関数呼び出し時の型パラメータ推論は、Phase 1-3の完成後に実装。

```cb
T max<T>(T a, T b) { ... }

void main() {
    int i = max(10, 20);  // T=int と推論
}
```

---

## 文法定義（BNF）

```bnf
<type_parameter_list> ::= '<' <type_parameter> { ',' <type_parameter> } '>'

<type_parameter> ::= <identifier>
                   | <identifier> ':' <type_constraint>

<type_constraint> ::= <type_union>
                    | <interface_constraint>
                    | <type_union> '&' <interface_constraint>

<type_union> ::= <type_specifier> { '|' <type_specifier> }

<interface_constraint> ::= <identifier>

<generic_struct> ::= 'struct' <identifier> <type_parameter_list> '{' <struct_members> '}'

<generic_function> ::= <type_specifier> <identifier> <type_parameter_list> '(' <parameter_list> ')' <block>

<generic_interface> ::= 'interface' <identifier> <type_parameter_list> '{' <interface_members> '}'

<generic_impl> ::= 'impl' <identifier> [ <type_parameter_list> ] 'for' <identifier> [ <type_parameter_list> ] '{' <impl_members> '}'

<type_application> ::= <identifier> <type_parameter_list>
```

---

## テスト計画

### 基本テスト（50個）
- ジェネリック構造体の宣言と使用
- ジェネリック関数の宣言と使用
- 複数型パラメータ
- ネストしたジェネリクス

### 型制約テスト（30個）
- Union型制約の検証
- 制約違反のエラー検出
- 複合制約

### Interfaceテスト（40個）
- ジェネリックInterfaceの定義
- ジェネリックimplの実装
- 型パラメータの一致検証
- 部分的なインスタンス化

### エッジケーステスト（30個）
- 深くネストしたジェネリクス
- 循環参照の検出
- エラーメッセージの検証

**合計**: 150個のテストケース

---

## 参考実装

### Rust
- トレイト境界（trait bounds）
- ジェネリックの構文
- 型推論

### C++
- テンプレート
- SFINAE
- コンセプト（C++20）

### TypeScript
- ジェネリックの構文
- 型制約

---

## 今後の拡張

### v0.12.0以降
1. **型推論の強化**: 関数呼び出し時の自動推論
2. **可変長ジェネリクス**: `T...` のサポート
3. **デフォルト型パラメータ**: `struct S<T = int> { ... }`
4. **コンセプト**: より高度な制約システム
5. **ジェネリックlambda**: `|x: T| -> T { ... }`

---

## まとめ

### 設計の明確化

1. **Interface定義とimpl宣言の分離**
   - Interface: `interface I<T> { ... }`
   - impl: `impl I<T> for S<T> { ... }`

2. **型パラメータの省略規則**
   - 構造体がジェネリックの場合のみ省略可能
   - 型パラメータは一致する必要がある

3. **曖昧な構文の削除**
   - `impl I for <T: ...>` は削除
   - 代わりに構造体に対する実装を使用

4. **可変長引数は将来的な拡張**
   - v0.11.0では配列を使用
   - v0.12.0以降で検討

### 実装優先度

1. 🔴 Phase 1: 基本的なジェネリクス（2週間）
2. 🔴 Phase 2: 型制約（1週間）
3. 🟡 Phase 3: Interface統合（1週間）
4. 🟢 Phase 4: 型推論（将来的な拡張）

**合計見積もり**: 4週間（Phase 1-3）

---

**作成者**: shadowlink0122  
**レビュー**: AI Assistant  
**日付**: 2025年10月12日
