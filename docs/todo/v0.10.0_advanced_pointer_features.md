# Cb言語 v0.10.0 高度なポインタ機能・メモリ管理実装計画

**作成日**: 2025年10月6日  
**対象バージョン**: v0.10.0  
**前提バージョン**: v0.9.0（関数ポインタ完全実装版）

---

## 📋 概要

v0.10.0では、v0.9.0で延期した高度なポインタ機能に加えて、動的メモリ管理機能を実装します。これらの機能により、Cb言語のメモリ管理能力が大幅に向上し、より実用的なプログラムが作成可能になります。

---

## 🎯 実装対象機能

### A. 高度なポインタ機能（v0.9.0から延期）

### 1. constポインタ（完全実装）

**現状**: 基本const変数のみサポート（`const int x = 42;`）

**実装内容**:
- `const T*` - pointer to const T（指し先が定数）
- `T* const` - const pointer to T（ポインタ自体が定数）
- `const T* const` - const pointer to const T（両方定数）

**構文例**:
```c++
void main() {
    int x = 10;
    int y = 20;
    
    // pointer to const int
    const int* ptr1 = &x;
    println(*ptr1);  // 10 (読み取り可能)
    // *ptr1 = 20;   // エラー: 指し先を変更できない
    ptr1 = &y;       // OK: ポインタ自体は変更可能
    
    // const pointer to int
    int* const ptr2 = &x;
    *ptr2 = 30;      // OK: 指し先を変更可能
    // ptr2 = &y;    // エラー: ポインタ自体を変更できない
    
    // const pointer to const int
    const int* const ptr3 = &x;
    // *ptr3 = 40;   // エラー: 指し先を変更できない
    // ptr3 = &y;    // エラー: ポインタ自体を変更できない
}
```

**実装箇所**:
1. **Parser** (`src/frontend/recursive_parser/recursive_parser.cpp`)
   - const修飾子の位置解析（前置/後置）
   - 型情報へのconst情報の追加

2. **TypeManager** (`src/backend/interpreter/managers/type_manager.cpp`)
   - `TypeInfo`にconst修飾フラグ追加
   - constポインタ型のチェック関数

3. **ExpressionEvaluator** (`src/backend/interpreter/evaluators/expression_evaluator.cpp`)
   - constポインタへの代入エラーチェック
   - constポインタのデリファレンス代入エラーチェック

**見積もり**: 2-3日

---

### 2. 多次元配列へのポインタ

**現状**: 多次元配列要素へのアドレス取得でエラー

```
Error: Multi-dimensional array address-of not yet supported
```

**実装内容**:
- 多次元配列要素へのアドレス取得（`&matrix[i][j]`）
- 配列全体へのポインタ（`int(*)[3]` - 3要素配列へのポインタ）

**構文例**:
```c++
void main() {
    int[2][3] matrix = [[1, 2, 3], [4, 5, 6]];
    
    // 要素へのポインタ
    int* ptr = &matrix[0][0];
    println(*ptr);  // 1
    ptr = &matrix[1][2];
    println(*ptr);  // 6
    
    // ポインタ演算
    ptr = &matrix[0][0];
    ptr = ptr + 4;
    println(*ptr);  // 5 (フラット化されたメモリレイアウトでアクセス)
}
```

**実装箇所**:
1. **ExpressionEvaluator** (`src/backend/interpreter/evaluators/expression_evaluator.cpp`)
   - `ADDRESS_OF`オペレータの拡張
   - 多次元配列インデックスのフラット化計算
   - `ArrayPointerTypeInfo`の活用

2. **VariableManager** (`src/backend/interpreter/managers/variable_manager.cpp`)
   - 多次元配列要素のメモリアドレス計算

**技術的課題**:
- メモリレイアウトのフラット化（row-major order）
- インデックス境界チェック
- 配列全体へのポインタ型（`int(*)[N]`）の型システム実装

**見積もり**: 2-3日

---

### 3. 構造体配列メンバーの関数戻り値代入

**現状**: 代入時にプログラム停止

```c++
Student s;
s.scores = get_scores();  // プログラム停止
```

**実装内容**:
- 配列型メンバーへの配列コピー処理
- 関数戻り値配列の一時変数管理

**構文例**:
```c++
struct Student {
    int[3] scores;
};

int[3] get_scores() {
    int[3] result = [85, 90, 95];
    return result;
}

void main() {
    Student s;
    s.scores = get_scores();  // 配列コピーが実行される
    println(s.scores[0]);     // 85
    println(s.scores[1]);     // 90
    println(s.scores[2]);     // 95
}
```

**実装箇所**:
1. **StatementExecutor** (`src/backend/interpreter/executors/statement_executor.cpp`)
   - 配列型メンバーへの代入処理
   - `copy_array_recursive()` ヘルパー関数の追加

2. **VariableManager** (`src/backend/interpreter/managers/variable_manager.cpp`)
   - 構造体メンバー配列の代入処理
   - 一時変数からの配列コピー

**技術的課題**:
- 配列サイズの整合性チェック
- 深いコピー（要素ごとのコピー）
- 一時変数の適切なライフタイム管理

**見積もり**: 1-2日

---

### 4. 多次元配列の関数戻り値からメンバー代入

**現状**: 構造体配列メンバー代入と同様の問題

**実装内容**:
- 多次元配列型メンバーへの再帰的コピー処理
- 多次元配列の関数戻り値処理

**構文例**:
```c++
struct Matrix {
    int[2][3] data;
};

int[2][3] get_matrix() {
    int[2][3] result = [[1, 2, 3], [4, 5, 6]];
    return result;
}

void main() {
    Matrix m;
    m.data = get_matrix();  // 多次元配列コピーが実行される
    println(m.data[0][0]);  // 1
    println(m.data[1][2]);  // 6
}
```

**実装箇所**:
- 構造体配列メンバー代入と同じ箇所
- `copy_array_recursive()` で多次元配列に対応

**技術的課題**:
- 再帰的配列コピーの実装
- 多次元配列サイズの整合性チェック
- パフォーマンス最適化

**見積もり**: 1日（構造体配列メンバー代入と同時実装）

---

### 5. 多重ポインタ

**現状**: 未実装

**実装内容**:
- `T**` - pointer to pointer
- `T***` - pointer to pointer to pointer
- 任意の深さのポインタチェーン

**構文例**:
```c++
void main() {
    int x = 42;
    int* ptr = &x;
    int** pptr = &ptr;
    int*** ppptr = &pptr;
    
    println(x);        // 42
    println(*ptr);     // 42
    println(**pptr);   // 42
    println(***ppptr); // 42
    
    **pptr = 100;
    println(x);        // 100
}
```

**実装箇所**:
1. **Parser** (`src/frontend/recursive_parser/recursive_parser.cpp`)
   - 複数の`*`の解析
   - ポインタ深度カウント

2. **TypeInfo** (`src/common/ast.h`)
   - `pointer_depth`フィールド（既存）の活用
   - 多重ポインタ型チェック

3. **ExpressionEvaluator** (`src/backend/interpreter/evaluators/expression_evaluator.cpp`)
   - 多重デリファレンス処理
   - 多重ADDRESS_OF処理

**技術的課題**:
- ポインタ深度の正確な追跡
- 型安全性の保証
- デバッグ情報の表示（`int*** ppptr = 0x...`）

**見積もり**: 2日

---

### 6. 配列参照型

**現状**: 未実装（構文エラー）

```
Error: Expected parameter name
```

**実装内容**:
- `int[N]&` - 配列への参照
- 配列の参照渡し

**構文例**:
```c++
void modify_array(int[3]& arr) {
    arr[0] = 100;
    arr[1] = 200;
    arr[2] = 300;
}

void main() {
    int[3] nums = [1, 2, 3];
    println(nums[0]);  // 1
    modify_array(nums);
    println(nums[0]);  // 100
    println(nums[1]);  // 200
    println(nums[2]);  // 300
}
```

**実装箇所**:
1. **Parser** (`src/frontend/recursive_parser/recursive_parser.cpp`)
   - 配列型+参照型の組み合わせ解析
   - 関数パラメータでの配列参照型パース

2. **VariableManager** (`src/backend/interpreter/managers/variable_manager.cpp`)
   - 配列参照の実装（ポインタベース）

**技術的課題**:
- 配列型と参照型の組み合わせの型システム実装
- 配列サイズの型情報への組み込み
- 配列要素への参照経由アクセス

**見積もり**: 2日

---

### B. 動的メモリ管理機能（新規）

#### 7. new演算子

**現状**: 未実装

**実装内容**:
- 動的メモリ割り当て
- プリミティブ型、構造体、配列の動的確保

**構文例**:
```c++
void main() {
    // プリミティブ型
    int* ptr = new int;
    *ptr = 42;
    println(*ptr);  // 42
    delete ptr;
    
    // 構造体
    Point* p = new Point;
    p->x = 10;
    p->y = 20;
    delete p;
    
    // 配列
    int* arr = new int[10];
    arr[0] = 100;
    delete[] arr;
}
```

**実装箇所**:
- `src/frontend/recursive_parser/recursive_parser.cpp` - new式のパース
- `src/backend/interpreter/evaluators/expression_evaluator.cpp` - メモリ割り当て処理
- `src/backend/interpreter/managers/memory_manager.cpp` - ヒープメモリ管理（新規）

**見積もり**: 3-4日

---

#### 8. delete演算子

**現状**: 未実装

**実装内容**:
- 動的メモリ解放
- `delete` と `delete[]` の区別
- 二重解放の検出

**構文例**:
```c++
void main() {
    int* ptr = new int;
    *ptr = 42;
    delete ptr;  // 単一オブジェクトの解放
    
    int* arr = new int[10];
    delete[] arr;  // 配列の解放
}
```

**実装箇所**:
- `src/frontend/recursive_parser/recursive_parser.cpp` - delete式のパース
- `src/backend/interpreter/executors/statement_executor.cpp` - メモリ解放処理
- `src/backend/interpreter/managers/memory_manager.cpp` - メモリ追跡・解放

**技術的課題**:
- メモリリーク検出
- 二重解放防止
- dangling pointer検出

**見積もり**: 2-3日

---

#### 9. キャスト演算子

**現状**: 未実装

**実装内容**:
- 型キャスト（C/C++スタイル）
- プリミティブ型間のキャスト
- ポインタ型のキャスト

**構文例**:
```c++
void main() {
    // プリミティブ型キャスト
    int x = 42;
    long y = (long)x;
    float f = (float)x;
    
    // ポインタキャスト
    void* vptr = (void*)&x;
    int* iptr = (int*)vptr;
    
    // ダウンキャスト（構造体階層）
    Base* base = get_object();
    Derived* derived = (Derived*)base;
}
```

**実装箇所**:
- `src/frontend/recursive_parser/recursive_parser.cpp` - キャスト式のパース
- `src/backend/interpreter/evaluators/expression_evaluator.cpp` - 型変換処理
- `src/backend/interpreter/managers/type_manager.cpp` - キャスト可否判定

**見積もり**: 2-3日

---

#### 10. 動的配列アクセス `[]`

**現状**: 静的配列のみサポート

**実装内容**:
- 動的配列へのアクセス演算子
- ポインタ演算との統合

**構文例**:
```c++
void main() {
    int* arr = new int[10];
    
    // 配列アクセス
    arr[0] = 100;
    arr[5] = 500;
    println(arr[0]);  // 100
    println(arr[5]);  // 500
    
    // ポインタ演算と等価
    *(arr + 3) = 300;
    println(arr[3]);  // 300
    
    delete[] arr;
}
```

**実装箇所**:
- `src/backend/interpreter/evaluators/expression_evaluator.cpp` - 動的配列アクセス
- `src/backend/interpreter/managers/variable_manager.cpp` - 動的配列変数管理

**見積もり**: 1-2日

---

## 📊 実装優先度

### A. 高度なポインタ機能

| 機能 | 難易度 | 見積もり | 優先度 | 依存関係 |
|------|--------|---------|--------|---------|
| 1. constポインタ | 中 | 2-3日 | 高 | なし |
| 2. 多次元配列ポインタ | 高 | 2-3日 | 高 | なし |
| 3. 構造体配列メンバー代入 | 中 | 1-2日 | 中 | なし |
| 4. 多次元配列メンバー代入 | 中 | 1日 | 中 | #3 |
| 5. 多重ポインタ | 中 | 2日 | 低 | なし |
| 6. 配列参照型 | 中 | 2日 | 低 | なし |

**小計**: 10-15日

### B. 動的メモリ管理機能

| 機能 | 難易度 | 見積もり | 優先度 | 依存関係 |
|------|--------|---------|--------|---------|
| 7. new演算子 | 高 | 3-4日 | 高 | なし |
| 8. delete演算子 | 中 | 2-3日 | 高 | #7 |
| 9. キャスト演算子 | 中 | 2-3日 | 中 | なし |
| 10. 動的配列アクセス[] | 低 | 1-2日 | 中 | #7 |

**小計**: 8-12日

---

**合計見積もり**: 18-27日

---

## 🧪 テストケース

各機能に対して以下のテストケースを作成済み：

### 1. constポインタ
- `tests/cases/pointer/test_const_pointer.cb`（基本constのみ）
- → 完全実装版に更新

### 2. 多次元配列ポインタ
- `tests/cases/pointer/test_multidim_array_pointer.cb`（基本多次元配列のみ）
- → 多次元配列要素へのポインタテストに更新

### 3. 構造体配列メンバー代入
- `tests/cases/struct/test_struct_array_member_function_return.cb`（基本構造体のみ）
- → 関数戻り値代入テストに更新

### 4. 多次元配列メンバー代入
- `tests/cases/struct/test_multidim_array_member_function_return.cb`（基本多次元配列のみ）
- → 関数戻り値代入テストに更新

### 5. 多重ポインタ
- `tests/cases/pointer/test_multi_pointer.cb`（基本ポインタのみ）
- → 多重ポインタテストに更新

### 6. 配列参照型
- 新規作成: `tests/cases/reference/test_array_reference.cb`

---

## 🔧 実装フェーズ

### フェーズ1: 型システム拡張（2-3日）
1. constポインタ完全実装
2. 多重ポインタ型サポート

### フェーズ2: 配列コピー処理（2-3日）
3. 構造体配列メンバー代入
4. 多次元配列メンバー代入

### フェーズ3: 高度なポインタ機能（3-4日）
5. 多次元配列へのポインタ
6. 配列参照型

### フェーズ4: 統合テスト（1-2日）
- 全機能の組み合わせテスト
- パフォーマンステスト
- ドキュメント更新

---

## 📝 ドキュメント更新

実装完了後、以下を更新：
1. `docs/spec.md` - 各機能の仕様追加
2. `release_notes/v0.10.0.md` - リリースノート作成
3. `README.md` - 新機能の追加
4. サンプルコード追加（`sample/`）

---

## ✅ 完了基準

- [ ] 6つの機能すべてが実装済み
- [ ] 各機能のテストケースが100%成功
- [ ] 統合テストが100%成功（既存テスト含む）
- [ ] ドキュメント更新完了
- [ ] コードレビュー完了

---

## 🎯 成功メトリクス

- **テスト成功率**: 100%（全2430+新規テスト）
- **実装期間**: 10-15日
- **バグ数**: 0（リリース時）
- **ドキュメント完成度**: 100%

---

**次のステップ**: v0.10.0の実装開始時に、このドキュメントを参照して優先度順に実装を進める。
