# ç„¡åé–¢æ•°ï¼ˆãƒ©ãƒ ãƒ€å¼ï¼‰å®Ÿè£…è¨ˆç”»

**ä½œæˆæ—¥**: 2025å¹´10æœˆ9æ—¥  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.10.0  
**å„ªå…ˆåº¦**: ğŸ”´ é«˜

---

## ğŸ“‹ æ¦‚è¦

é–¢æ•°ã‚’å¼ã¨ã—ã¦æ‰±ãˆã‚‹ç„¡åé–¢æ•°ï¼ˆãƒ©ãƒ ãƒ€å¼ï¼‰ã‚’å®Ÿè£…ã™ã‚‹ã€‚é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã‚„é«˜éšé–¢æ•°ã§ã®ä½¿ç”¨ã‚’æƒ³å®šã€‚

---

## ğŸ¯ ç›®çš„

1. **é–¢æ•°ã®å³æ™‚å®šç¾©**: é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã¸ã®ä»£å…¥æ™‚ã«å³åº§ã«å®šç¾©
2. **é«˜éšé–¢æ•°ã®ã‚µãƒãƒ¼ãƒˆ**: ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®ç°¡æ½”ãªè¨˜è¿°
3. **ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®åŸºç›¤**: å°†æ¥çš„ãªã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å®Ÿè£…ã¸ã®å¸ƒçŸ³

---

## ğŸ“ åŸºæœ¬ä»•æ§˜

### æ§‹æ–‡

#### ãƒ‘ã‚¿ãƒ¼ãƒ³1: é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã¸ã®ä»£å…¥ï¼ˆå‹æ˜ç¤ºï¼‰

```cb
void main() {
    // å‹* å¤‰æ•° = å‹ func(å¼•æ•°) { å‡¦ç†; }
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    println(add(5, 3));  // 8
}
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³2: ç›´æ¥ä»£å…¥ï¼ˆå‹æ¨è«–ï¼‰

```cb
void main() {
    // å‹ func(å¼•æ•°) { å‡¦ç†; }
    int func(int x) {
        return x * 2;
    };
    
    // å†…éƒ¨çš„ã«ã¯ä¸€æ„ãªè­˜åˆ¥å­ãŒç”Ÿæˆã•ã‚Œã‚‹
    // ä¾‹: __lambda_1, __lambda_2, ...
}
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³3: é–¢æ•°å¼•æ•°ã¨ã—ã¦

```cb
func void apply(int* callback, int x) {
    println(callback(x));
}

void main() {
    // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å³åº§ã«å®šç¾©
    apply(int func(int n) { return n * n; }, 5);  // 25
}
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³4: é…åˆ—è¦ç´ ã¨ã—ã¦

```cb
void main() {
    // é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã®é…åˆ—
    int*[3] operations = [
        int func(int x) { return x + 1; },
        int func(int x) { return x * 2; },
        int func(int x) { return x * x; }
    ];
    
    for (int i = 0; i < 3; i++) {
        println(operations[i](10));
    }
    // å‡ºåŠ›: 11, 20, 100
}
```

### é‡è¦ãªç‰¹æ€§

#### 1. funcã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è‡ªä½“ã¯ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŒãŸãªã„

```cb
void main() {
    // åŒã˜ã‚¹ã‚³ãƒ¼ãƒ—å†…ã«è¤‡æ•°ã®func()ãŒå­˜åœ¨å¯èƒ½
    int* f1 = int func(int x) { return x + 1; };
    int* f2 = int func(int x) { return x * 2; };
    
    // é‡è¤‡ã‚¨ãƒ©ãƒ¼ã¯ç™ºç”Ÿã—ãªã„
    // å†…éƒ¨çš„ã«ã¯ __lambda_1, __lambda_2 ã®ã‚ˆã†ã«è­˜åˆ¥
}
```

#### 2. å†…éƒ¨è­˜åˆ¥å­ã®è‡ªå‹•ç”Ÿæˆ

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©/ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒè‡ªå‹•çš„ã«ä¸€æ„ãªè­˜åˆ¥å­ã‚’ç”Ÿæˆ:

```cb
// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰
int* f = int func(int x) { return x * 2; };

// å†…éƒ¨çš„ã«ã¯
int __lambda_1(int x) { return x * 2; }
int* f = &__lambda_1;
```

#### 3. å¼ã¨ã—ã¦ã®æ‰±ã„

ç„¡åé–¢æ•°ã¯å¼ã¨ã—ã¦è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ã€æ§˜ã€…ãªå ´æ‰€ã§ä½¿ç”¨å¯èƒ½:

```cb
// ä»£å…¥å¼
int* f = int func(int x) { return x; };

// é–¢æ•°å¼•æ•°
process(int func(int x) { return x * 2; });

// returnæ–‡
func int* get_doubler() {
    return int func(int x) { return x * 2; };
}

// é…åˆ—åˆæœŸåŒ–
int*[2] funcs = [
    int func(int x) { return x; },
    int func(int x) { return -x; }
];
```

---

## ğŸ”§ å®Ÿè£…è¦ä»¶

### 1. æ§‹æ–‡æ‹¡å¼µ

**Lexer**:
- `func` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯æ—¢å­˜ï¼ˆé–¢æ•°å®šç¾©ã§ä½¿ç”¨ä¸­ï¼‰
- æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã¯ä¸è¦

**Parser**:
- å¼ã®ä¸­ã§ `func` ã‚’æ¤œå‡ºã—ãŸå ´åˆã€ç„¡åé–¢æ•°ã¨ã—ã¦è§£æ
- æˆ»ã‚Šå€¤ã®å‹ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã€æœ¬ä½“ã‚’è§£æ
- ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§çµ‚ç«¯

### 2. ASTæ‹¡å¼µ

```cpp
// ç„¡åé–¢æ•°ãƒãƒ¼ãƒ‰
struct LambdaExpressionNode : public ExpressionNode {
    TypeInfo return_type;
    std::vector<Parameter> parameters;
    std::unique_ptr<StatementNode> body;
    std::string generated_name;  // è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸå†…éƒ¨è­˜åˆ¥å­
};

// é€šå¸¸ã®å¼ã¨ã—ã¦æ‰±ãˆã‚‹ã‚ˆã†ã«ExpressionNodeã‚’ç¶™æ‰¿
```

### 3. è­˜åˆ¥å­ã®è‡ªå‹•ç”Ÿæˆ

**å‘½åè¦å‰‡**:
```cpp
class LambdaNameGenerator {
    static int lambda_counter;
    
public:
    static std::string generate() {
        return "__lambda_" + std::to_string(++lambda_counter);
    }
};
```

**ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†**:
- å„ç„¡åé–¢æ•°ã«ä¸€æ„ãªå†…éƒ¨è­˜åˆ¥å­ã‚’å‰²ã‚Šå½“ã¦
- é–¢æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ã«é€šå¸¸ã®é–¢æ•°ã¨åŒæ§˜ã«ç™»éŒ²
- ã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†æ™‚ã«å‰Šé™¤ï¼ˆã¾ãŸã¯é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹é–“ã¯ä¿æŒï¼‰

### 4. å‹æ¨è«–

#### é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã¸ã®ä»£å…¥

```cb
// å‹æ˜ç¤º
int* f = int func(int x) { return x * 2; };
```

å‹ãƒã‚§ãƒƒã‚¯:
1. å·¦è¾ºã®å‹: `int*`ï¼ˆintå‹ã‚’è¿”ã™é–¢æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼‰
2. å³è¾ºã®å‹: `int func(int) { ... }`
3. ã‚·ã‚°ãƒãƒãƒ£ãŒä¸€è‡´ã™ã‚‹ã‹æ¤œè¨¼

#### ç›´æ¥å‘¼ã³å‡ºã—

```cb
// å³åº§ã«å‘¼ã³å‡ºã—ï¼ˆIIFE: Immediately Invoked Function Expressionï¼‰
int result = (int func(int x) { return x * 2; })(5);
println(result);  // 10
```

### 5. ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§ã®å®Ÿè£…

**ç„¡åé–¢æ•°ã®ç™»éŒ²**:
```cpp
void Interpreter::evaluate_lambda(LambdaExpressionNode* lambda) {
    // 1. ä¸€æ„ãªåå‰ã‚’ç”Ÿæˆ
    std::string internal_name = LambdaNameGenerator::generate();
    lambda->generated_name = internal_name;
    
    // 2. é€šå¸¸ã®é–¢æ•°ã¨ã—ã¦ç™»éŒ²
    FunctionDef func_def;
    func_def.name = internal_name;
    func_def.return_type = lambda->return_type;
    func_def.parameters = lambda->parameters;
    func_def.body = std::move(lambda->body);
    
    register_function(func_def);
    
    // 3. é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦è¿”ã™
    return create_function_pointer(internal_name);
}
```

**é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã¸ã®å¤‰æ›**:
```cpp
int64_t Interpreter::lambda_to_function_pointer(LambdaExpressionNode* lambda) {
    std::string internal_name = evaluate_lambda(lambda);
    return get_function_address(internal_name);
}
```

---

## ğŸ“Š å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—

### Phase 1: åŸºæœ¬æ§‹é€ ï¼ˆ2é€±é–“ï¼‰
- [ ] LambdaExpressionNode ã®å®šç¾©
- [ ] è­˜åˆ¥å­è‡ªå‹•ç”Ÿæˆæ©Ÿæ§‹
- [ ] åŸºæœ¬çš„ãªæ§‹æ–‡è§£æ

### Phase 2: å¼ã¨ã—ã¦ã®çµ±åˆï¼ˆ2é€±é–“ï¼‰
- [ ] ä»£å…¥å¼ã§ã®ä½¿ç”¨
- [ ] é–¢æ•°å¼•æ•°ã§ã®ä½¿ç”¨
- [ ] é…åˆ—åˆæœŸåŒ–ã§ã®ä½¿ç”¨

### Phase 3: å‹ãƒã‚§ãƒƒã‚¯ï¼ˆ1é€±é–“ï¼‰
- [ ] ã‚·ã‚°ãƒãƒãƒ£ã®ä¸€è‡´æ¤œè¨¼
- [ ] å‹æ¨è«–ã®å®Ÿè£…
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ”¹å–„

### Phase 4: ãƒ†ã‚¹ãƒˆã¨æ¤œè¨¼ï¼ˆ1é€±é–“ï¼‰
- [ ] åŸºæœ¬çš„ãªç„¡åé–¢æ•°ãƒ†ã‚¹ãƒˆ
- [ ] é«˜éšé–¢æ•°ãƒ†ã‚¹ãƒˆ
- [ ] ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### 1. åŸºæœ¬çš„ãªç„¡åé–¢æ•°
```cb
void main() {
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    assert(add(3, 4) == 7);
    assert(add(10, 20) == 30);
}
```

### 2. è¤‡æ•°ã®ç„¡åé–¢æ•°ï¼ˆåŒã˜ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
```cb
void main() {
    int* f1 = int func(int x) { return x + 1; };
    int* f2 = int func(int x) { return x * 2; };
    int* f3 = int func(int x) { return x * x; };
    
    assert(f1(5) == 6);
    assert(f2(5) == 10);
    assert(f3(5) == 25);
}
```

### 3. é«˜éšé–¢æ•°
```cb
func void apply_twice(int* f, int x) {
    int result = f(f(x));
    println(result);
}

void main() {
    apply_twice(int func(int n) { return n + 1; }, 5);  // 7
    apply_twice(int func(int n) { return n * 2; }, 5);  // 20
}
```

### 4. é–¢æ•°ã‚’è¿”ã™é–¢æ•°
```cb
func int* make_multiplier(int factor) {
    return int func(int x) {
        return x * factor;  // å¤–éƒ¨å¤‰æ•°ã‚’å‚ç…§ï¼ˆã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£çš„ï¼‰
    };
}

void main() {
    int* double = make_multiplier(2);
    int* triple = make_multiplier(3);
    
    assert(double(5) == 10);
    assert(triple(5) == 15);
}
```

### 5. é…åˆ—ã§ã®ä½¿ç”¨
```cb
void main() {
    int*[3] operations = [
        int func(int x) { return x + 10; },
        int func(int x) { return x - 10; },
        int func(int x) { return x * 10; }
    ];
    
    for (int i = 0; i < 3; i++) {
        println(operations[i](5));
    }
    // å‡ºåŠ›: 15, -5, 50
}
```

### 6. IIFEï¼ˆå³åº§ã«å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°å¼ï¼‰
```cb
void main() {
    // ç„¡åé–¢æ•°ã‚’å®šç¾©ã—ã¦å³åº§ã«å®Ÿè¡Œ
    int result = (int func(int x) { return x * x; })(7);
    println(result);  // 49
}
```

### 7. æ¡ä»¶åˆ†å²ã§ã®ä½¿ç”¨
```cb
void main() {
    bool is_positive = true;
    
    int* operation = is_positive 
        ? int func(int x) { return x; }
        : int func(int x) { return -x; };
    
    println(operation(10));  // 10 or -10
}
```

---

## ğŸ”— é–¢é€£æ©Ÿèƒ½

### ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ï¼ˆå°†æ¥ã®æ‹¡å¼µï¼‰

ç¾åœ¨ã®ç„¡åé–¢æ•°ã¯å¤–éƒ¨å¤‰æ•°ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¾ã›ã‚“ãŒã€å°†æ¥çš„ã«ã¯:

```cb
func int* make_counter() {
    int count = 0;  // å¤–éƒ¨å¤‰æ•°
    
    return int func() {
        count = count + 1;  // å¤–éƒ¨å¤‰æ•°ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
        return count;
    };
}

void main() {
    int* counter = make_counter();
    println(counter());  // 1
    println(counter());  // 2
    println(counter());  // 3
}
```

**å®Ÿè£…èª²é¡Œ**:
- ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚ŒãŸå¤‰æ•°ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ç®¡ç†
- å€¤ã‚­ãƒ£ãƒ—ãƒãƒ£ vs å‚ç…§ã‚­ãƒ£ãƒ—ãƒãƒ£
- ãƒ¡ãƒ¢ãƒªç®¡ç†

---

## âš ï¸ æ³¨æ„äº‹é …

1. **ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†**: ç„¡åé–¢æ•°ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã®ç”Ÿå­˜æœŸé–“ã«ä¾å­˜
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: é–¢æ•°ç”Ÿæˆã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰
3. **ãƒ‡ãƒãƒƒã‚°**: å†…éƒ¨è­˜åˆ¥å­ãŒç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ”¹å–„ãŒå¿…è¦
4. **å†å¸°**: ç„¡åé–¢æ•°å†…ã‹ã‚‰è‡ªèº«ã‚’å‘¼ã³å‡ºã™æ–¹æ³•ï¼ˆç¾çŠ¶ã§ã¯ä¸å¯èƒ½ï¼‰

---

## ğŸ”„ å°†æ¥ã®æ‹¡å¼µ

1. **å‹æ¨è«–ã®å¼·åŒ–**: æˆ»ã‚Šå€¤ã®å‹ã‚’çœç•¥å¯èƒ½ã«
   ```cb
   int* f = func(int x) { return x * 2; };  // int ã‚’æ¨è«–
   ```

2. **çŸ­ç¸®æ§‹æ–‡**: ã‚¢ãƒ­ãƒ¼é–¢æ•°ã‚¹ã‚¿ã‚¤ãƒ«
   ```cb
   int* f = (int x) => x * 2;
   ```

3. **ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£**: å¤–éƒ¨å¤‰æ•°ã®ã‚­ãƒ£ãƒ—ãƒãƒ£
   ```cb
   int factor = 10;
   int* f = int func(int x) { return x * factor; };
   ```

4. **ã‚¸ã‚§ãƒãƒªãƒƒã‚¯**: å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤ç„¡åé–¢æ•°
   ```cb
   T* identity<T> = T func(T x) { return x; };
   ```

---

## ğŸ“ TypeScriptã¨ã®æ¯”è¼ƒ

**TypeScript**:
```typescript
// ç„¡åé–¢æ•°
const add = function(a: number, b: number): number {
    return a + b;
};

// ã‚¢ãƒ­ãƒ¼é–¢æ•°
const double = (x: number): number => x * 2;

// å³åº§ã«å‘¼ã³å‡ºã—
const result = (function(x: number) { return x * x; })(5);
```

**Cbï¼ˆææ¡ˆï¼‰**:
```cb
// ç„¡åé–¢æ•°
int* add = int func(int a, int b) {
    return a + b;
};

// å³åº§ã«å‘¼ã³å‡ºã—
int result = (int func(int x) { return x * x; })(5);
```

**é¡ä¼¼ç‚¹**:
- é–¢æ•°ã‚’å¼ã¨ã—ã¦æ‰±ãˆã‚‹
- é«˜éšé–¢æ•°ã®ã‚µãƒãƒ¼ãƒˆ
- å³åº§ã«å‘¼ã³å‡ºã—å¯èƒ½

**ç›¸é•ç‚¹**:
- Cbã¯å‹ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šï¼ˆç¾æ™‚ç‚¹ï¼‰
- Cbã¯ã‚¢ãƒ­ãƒ¼é–¢æ•°æ§‹æ–‡ãªã—ï¼ˆå°†æ¥è¿½åŠ å¯èƒ½ï¼‰
- TypeScriptã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å®Œå…¨ã‚µãƒãƒ¼ãƒˆ

---

**æ›´æ–°å±¥æ­´**:
- 2025/10/09: åˆç‰ˆä½œæˆ
