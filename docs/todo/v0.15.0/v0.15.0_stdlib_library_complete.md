# v0.17.0 標準ライブラリの完全ライブラリ化

**バージョン**: v0.17.0
**目標**: OS依存機能の標準ライブラリ化 - 組み込み関数ゼロ
**期間**: 2-3ヶ月
**作成日**: 2025年11月14日
**ステータス**: 計画中

---

## 🎯 概要

v0.17.0では、現在コンパイラに組み込まれている**全てのOS依存機能**（`println`, `malloc` 等）を標準ライブラリとして分離・パッケージ化します。これにより、Cbコンパイラはプラットフォーム非依存となり、標準ライブラリがOS抽象化を担当します。

### 🔑 重要な目標

**組み込み関数をゼロにする**

現在の状態（v0.16.0まで）:
```cb
void main() {
    println("Hello");  // ← コンパイラ組み込み関数
    int* ptr = malloc(100);  // ← コンパイラ組み込み関数
}
```

v0.17.0以降:
```cb
import std::io::println;
import std::mem::alloc;

void main() {
    println("Hello");  // ← std/io/stdio.cb の実装
    void* ptr = alloc(100);  // ← std/mem/alloc.cb の実装
}
```

---

## 📊 v0.16.0で準備された機能

### v0.16.0で実装済みの必須機能

v0.17.0を実現するために、v0.16.0で以下の機能が実装されています：

1. ✅ **インラインアセンブラ**: システムコール直接呼び出し
2. ✅ **FFI**: Windows API等の外部関数呼び出し（v0.13.0で実装済み）
3. ✅ **条件付きコンパイル**: プラットフォーム別コード切り替え
4. ✅ **モジュールシステム強化**: Re-export、`mod`キーワード
5. ✅ **ベアメタル実行サポート**: freestanding環境

---

## 📋 実装計画

### Month 1: コア標準ライブラリ実装

#### Week 1-2: 入出力ライブラリ（std/io/stdio.cb）

**実装する関数**:
- `println(string s)` - 標準出力に文字列 + 改行を出力
- `print(string s)` - 標準出力に文字列を出力
- `readln() -> string` - 標準入力から1行読み込み

**Linux実装（インラインアセンブラ）**:
```cb
// std/io/stdio.cb
#[cfg(target_os = "linux")]
export void println(string s) {
    long len = strlen(s);

    // write(1, s, len) システムコール
    asm volatile (
        "mov $1, %rax\n"       // SYS_WRITE
        "mov $1, %rdi\n"       // fd = stdout
        "mov %0, %rsi\n"       // buf = s
        "mov %1, %rdx\n"       // count = len
        "syscall"
        :
        : "r"(s), "r"(len)
        : "rax", "rdi", "rsi", "rdx", "r11", "rcx", "memory"
    );

    // 改行出力
    char newline = '\n';
    asm volatile (
        "mov $1, %rax\n"
        "mov $1, %rdi\n"
        "lea %0, %rsi\n"
        "mov $1, %rdx\n"
        "syscall"
        :
        : "m"(newline)
        : "rax", "rdi", "rsi", "rdx", "r11", "rcx", "memory"
    );
}

export void print(string s) {
    long len = strlen(s);
    asm volatile (
        "mov $1, %rax\n"
        "mov $1, %rdi\n"
        "mov %0, %rsi\n"
        "mov %1, %rdx\n"
        "syscall"
        :
        : "r"(s), "r"(len)
        : "rax", "rdi", "rsi", "rdx", "r11", "rcx", "memory"
    );
}
```

**Windows実装（FFI）**:
```cb
// std/io/stdio.cb
#[cfg(target_os = "windows")]
extern "C" {
    #[link(name = "kernel32")]
    int WriteFile(
        void* hFile,
        void* lpBuffer,
        int nNumberOfBytesToWrite,
        int* lpNumberOfBytesWritten,
        void* lpOverlapped
    );

    #[link(name = "kernel32")]
    void* GetStdHandle(int nStdHandle);
}

const STD_OUTPUT_HANDLE: int = -11;

export void println(string s) {
    void* stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
    int written;

    WriteFile(stdout_handle, s, strlen(s), &written, NULL);

    char newline = '\n';
    WriteFile(stdout_handle, &newline, 1, &written, NULL);
}
```

**ベアメタル実装（UART）**:
```cb
// std/io/stdio.cb
#[cfg(target_os = "none")]

struct UART {
    volatile int data;
    volatile int status;
};

export void println(string s) {
    UART* uart = 0x40000000 as UART*;

    for (long i = 0; i < strlen(s); i++) {
        volatile {
            uart->data = s[i] as int;
        }
    }

    volatile {
        uart->data = '\n' as int;
    }
}
```

**実装タスク**:
- [ ] 各プラットフォーム実装（Linux/Windows/macOS/Baremetal）
- [ ] ユニットテスト（20個）
- [ ] 統合テスト（10個）

---

#### Week 3: メモリ管理ライブラリ（std/mem/alloc.cb）

**実装する関数**:
- `alloc(long size) -> void*` - メモリ確保
- `free(void* ptr, long size)` - メモリ解放
- `realloc(void* ptr, long old_size, long new_size) -> void*` - メモリ再確保

**Linux実装（mmap/munmap）**:
```cb
// std/mem/alloc.cb
#[cfg(target_os = "linux")]
export void* alloc(long size) {
    void* result;
    asm volatile (
        "mov $9, %rax\n"       // SYS_MMAP
        "xor %rdi, %rdi\n"     // addr = NULL
        "mov %1, %rsi\n"       // length = size
        "mov $3, %rdx\n"       // prot = PROT_READ | PROT_WRITE
        "mov $34, %r10\n"      // flags = MAP_PRIVATE | MAP_ANONYMOUS
        "mov $-1, %r8\n"       // fd = -1
        "xor %r9, %r9\n"       // offset = 0
        "syscall\n"
        "mov %rax, %0"
        : "=r"(result)
        : "r"(size)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "r11", "rcx", "memory"
    );
    return result;
}

export void free(void* ptr, long size) {
    asm volatile (
        "mov $11, %rax\n"      // SYS_MUNMAP
        "mov %0, %rdi\n"       // addr = ptr
        "mov %1, %rsi\n"       // length = size
        "syscall"
        :
        : "r"(ptr), "r"(size)
        : "rax", "rdi", "rsi", "r11", "rcx", "memory"
    );
}
```

**Windows実装（HeapAlloc/HeapFree）**:
```cb
// std/mem/alloc.cb
#[cfg(target_os = "windows")]
extern "C" {
    #[link(name = "kernel32")]
    void* HeapAlloc(void* hHeap, int dwFlags, long dwBytes);

    #[link(name = "kernel32")]
    int HeapFree(void* hHeap, int dwFlags, void* lpMem);

    #[link(name = "kernel32")]
    void* GetProcessHeap();
}

export void* alloc(long size) {
    void* heap = GetProcessHeap();
    return HeapAlloc(heap, 0, size);
}

export void free(void* ptr, long size) {
    void* heap = GetProcessHeap();
    HeapFree(heap, 0, ptr);
}
```

**ベアメタル実装（バンプアロケーター）**:
```cb
// std/mem/alloc.cb
#[cfg(target_os = "none")]

static long HEAP_START = 0x20000000;  // カスタム設定可能
static long HEAP_SIZE = 0x20000;      // 128KB
static long HEAP_CURRENT = HEAP_START;

export void* alloc(long size) {
    long heap_end = HEAP_START + HEAP_SIZE;

    if (HEAP_CURRENT + size > heap_end) {
        return NULL;  // Out of memory
    }

    void* ptr = HEAP_CURRENT as void*;
    HEAP_CURRENT += size;

    // アライメント調整（8バイト境界）
    HEAP_CURRENT = (HEAP_CURRENT + 7) & ~7;

    return ptr;
}

export void free(void* ptr, long size) {
    // バンプアロケーターは解放をサポートしない
    // 将来的には簡単なフリーリスト実装を追加可能
}
```

**実装タスク**:
- [ ] 各プラットフォーム実装
- [ ] ユニットテスト（20個）
- [ ] 統合テスト（10個）
- [ ] メモリリークテスト

---

#### Week 4: ランタイムサポート（std/runtime/）

**実装する機能**:
- `panic(string msg)` - パニックハンドラ
- `_start()` - プログラムエントリーポイント（ベアメタル用）

**panic実装**:
```cb
// std/runtime/panic.cb
import std::io::println;

export void panic(string msg) {
    println("[PANIC] ");
    println(msg);

    #[cfg(target_os = "linux")]
    {
        // exit(1)システムコール
        asm volatile (
            "mov $60, %rax\n"  // SYS_EXIT
            "mov $1, %rdi\n"   // status = 1
            "syscall"
            :
            :
            : "rax", "rdi"
        );
    }

    #[cfg(target_os = "none")]
    {
        // ベアメタル: 無限ループ
        loop {}
    }
}
```

**実装タスク**:
- [ ] panic実装（全プラットフォーム）
- [ ] _start実装（ベアメタル）
- [ ] ユニットテスト（10個）

---

### Month 2: プラットフォーム固有実装

#### Week 1: Linux実装の完成

**実装するシステムコール**:
- `write`, `read` - I/O
- `open`, `close` - ファイル操作
- `mmap`, `munmap` - メモリ管理
- `exit` - プログラム終了

**ファイル構造**:
```
std/sys/linux.cb    # Linux固有の実装
```

**テスト**:
- 統合テスト（15個）: Linuxでの実行確認

---

#### Week 2: Windows実装の完成

**実装するAPI**:
- `WriteFile`, `ReadFile` - I/O
- `CreateFile`, `CloseHandle` - ファイル操作
- `HeapAlloc`, `HeapFree` - メモリ管理
- `ExitProcess` - プログラム終了

**ファイル構造**:
```
std/sys/windows.cb  # Windows固有の実装
```

**テスト**:
- 統合テスト（15個）: Windowsでの実行確認

---

#### Week 3: macOS実装の完成

**実装**:
- Linuxとほぼ同じ（システムコール番号が異なる）
- BSDスタイルのシステムコール規約

**ファイル構造**:
```
std/sys/macos.cb    # macOS固有の実装
```

**テスト**:
- 統合テスト（15個）: macOSでの実行確認

---

#### Week 4: ベアメタル実装の完成

**実装する機能**:
- UARTドライバ（複数アーキテクチャ）
- バンプアロケーター
- タイマー（オプショナル）

**ファイル構造**:
```
std/sys/none.cb         # ベアメタル共通
std/sys/none/arm.cb     # ARM Cortex-M
std/sys/none/riscv.cb   # RISC-V
```

**テスト**:
- 統合テスト（10個）: QEMUでの実行確認

---

### Month 3: 移行とテスト

#### Week 1-2: コンパイラからの組み込み関数削除

**削除する組み込み関数**:
- `println(...)` - 標準ライブラリの `std::io::println` に置き換え
- `print(...)` - 標準ライブラリの `std::io::print` に置き換え
- `malloc(...)` - 標準ライブラリの `std::mem::alloc` に置き換え
- `free(...)` - 標準ライブラリの `std::mem::free` に置き換え

**自動インポート機能（互換性のため）**:
```cb
// ユーザーコード（importなし）
void main() {
    println("Hello");  // エラーではなく、自動的に std::io::println をインポート
}

// コンパイラが自動的に以下を追加
import std::io::println;

void main() {
    println("Hello");
}
```

**実装タスク**:
- [ ] コンパイラから組み込み関数を削除
- [ ] 自動インポート機能の実装
- [ ] 既存テストの更新
- [ ] 後方互換性テスト（50個）

---

#### Week 3: 移行テストと検証

**テストケース**:
- [ ] **既存コード互換性**（30個）
  - v0.16.0までのコードがそのまま動作するか

- [ ] **標準ライブラリ直接使用**（20個）
  - 明示的に `import std::*` してから使用

- [ ] **プラットフォーム別実行**（20個）
  - Linux/Windows/macOS/Baremetal での動作確認

- [ ] **メモリリークテスト**（10個）
  - Valgrind/AddressSanitizerでのチェック

---

#### Week 4: ドキュメントとサンプル作成

**ドキュメント**:
- [ ] 標準ライブラリAPIリファレンス
- [ ] プラットフォーム別実装ガイド
- [ ] 移行ガイド（v0.16.0 → v0.17.0）
- [ ] カスタムアロケーターの実装方法

**サンプルコード**:
- [ ] Hello World（各プラットフォーム）
- [ ] メモリ管理のサンプル
- [ ] ファイルI/Oのサンプル（v0.18.0で追加予定）
- [ ] ベアメタルプロジェクトのサンプル

---

## 📚 完成する標準ライブラリ構造

```
std/
├── io/
│   ├── stdio.cb       # println, print, readln
│   └── file.cb        # ファイルI/O（v0.18.0で追加予定）
├── mem/
│   ├── alloc.cb       # alloc, free, realloc
│   └── ptr.cb         # ポインタ操作ユーティリティ
├── sys/
│   ├── linux.cb       # Linux固有実装（インラインアセンブラ）
│   ├── macos.cb       # macOS固有実装（インラインアセンブラ）
│   ├── windows.cb     # Windows固有実装（FFI）
│   └── none/          # ベアメタル実装
│       ├── none.cb    # 共通
│       ├── arm.cb     # ARM Cortex-M
│       └── riscv.cb   # RISC-V
└── runtime/
    ├── panic.cb       # パニックハンドラ
    └── start.cb       # エントリーポイント（ベアメタル）
```

---

## 💡 使用例

### 例1: 基本的な使用（自動インポート）

```cb
// v0.17.0以降も互換性あり
void main() {
    println("Hello, World!");  // 自動的に std::io::println がインポートされる
}
```

### 例2: 明示的インポート（推奨）

```cb
import std::io::println;
import std::mem::alloc;
import std::mem::free;

void main() {
    println("Explicit import");

    void* ptr = alloc(1024);
    // 使用...
    free(ptr, 1024);
}
```

### 例3: プラットフォーム別コード

```cb
import std::io::println;

#[cfg(target_os = "linux")]
void platform_info() {
    println("Running on Linux");
}

#[cfg(target_os = "windows")]
void platform_info() {
    println("Running on Windows");
}

#[cfg(target_os = "none")]
void platform_info() {
    println("Running on bare metal");
}

void main() {
    platform_info();
}
```

### 例4: ベアメタルプロジェクト

```cb
import std::io::println;
import std::runtime::panic;

#[no_mangle]
#[entry_point]
fn _start() -> ! {
    main();
    loop {}
}

void main() {
    println("Hello from bare metal!");

    // 初期化...

    loop {
        // メインループ
    }
}
```

---

## 🧪 テスト

### ユニットテスト（合計80個）

**入出力ライブラリ（20個）**:
- println/print実装（各プラットフォーム）

**メモリ管理ライブラリ（20個）**:
- alloc/free実装（各プラットフォーム）

**ランタイムサポート（10個）**:
- panic実装

**プラットフォーム固有（30個）**:
- Linux（10個）
- Windows（10個）
- macOS（5個）
- Baremetal（5個）

---

### 統合テスト（合計100個）

**プラットフォーム別実行（60個）**:
- Linux実行（15個）
- Windows実行（15個）
- macOS実行（15個）
- Baremetal実行（15個）

**後方互換性（30個）**:
- 既存コードがそのまま動作

**総合テスト（10個）**:
- 複雑なアプリケーション

---

## ✅ 完了条件

### 必須条件（Must Have）

- [ ] **コンパイラ組み込み関数ゼロ** ✅
- [ ] **4プラットフォームで動作**（Linux/Windows/macOS/Baremetal） ✅
- [ ] **100+ライブラリテスト成功** ✅
- [ ] **後方互換性100%**（自動インポートで既存コード動作） ✅
- [ ] **ベアメタル環境でも動作** ✅
- [ ] **メモリリークゼロ** ✅

### 推奨条件（Should Have）

- [ ] APIリファレンス完成
- [ ] 移行ガイド完成
- [ ] サンプルコード完成

### 任意条件（Nice to Have）

- [ ] ファイルI/O実装（v0.18.0に延期可）
- [ ] 高度なアロケーター（v0.18.0に延期可）

---

## 🔗 関連ドキュメント

- **v0.16.0実装計画**: [`../v0.16.0/v0.16.0_revised_roadmap.md`](../v0.16.0/v0.16.0_revised_roadmap.md) - v0.17.0準備機能
- **v0.18.0実装計画**: [`../v0.18.0/README.md`](../v0.18.0/README.md) - パッケージエコシステム
- **総合ロードマップ**: [`../ROADMAP_v0.14-v0.18_SUMMARY.md`](../ROADMAP_v0.14-v0.18_SUMMARY.md)

---

## 📝 重要な注意事項

### v0.16.0への依存

v0.17.0は以下のv0.16.0機能に完全に依存しています：

1. **インラインアセンブラ**: システムコール直接呼び出しに必須
2. **条件付きコンパイル**: プラットフォーム別実装に必須
3. **FFI**: Windows API呼び出しに必須（v0.13.0で実装済み）

これらが実装されていないと、v0.17.0は実現できません。

### 後方互換性の保証

- v0.16.0までのコードは全て動作する（自動インポート機能により）
- ユーザーは段階的に明示的インポートに移行可能
- コンパイラは警告を出して明示的インポートを推奨

### パフォーマンス

- システムコール直接呼び出しによりオーバーヘッドは最小
- FFI経由でも追加コストはほぼゼロ

---

**作成者**: Cb Language Team
**最終更新**: 2025年11月14日
**ステータス**: Planning（v0.16.0完了後に実装開始）

---

## 🎯 v0.17.0のハイライト

1. **組み込み関数ゼロ** - 完全にライブラリ化
2. **プラットフォーム独立** - コンパイラはOS非依存
3. **4プラットフォーム対応** - Linux/Windows/macOS/Baremetal
4. **後方互換性100%** - 既存コードがそのまま動作

v0.17.0の完成により、Cbコンパイラは真にプラットフォーム独立となり、標準ライブラリがOS抽象化の責任を担います。
