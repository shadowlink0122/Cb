# v0.14.0: テストアーキテクチャ再設計ドキュメント

**日付**: 2025-11-16  
**バージョン**: v0.14.0  
**ステータス**: 設計段階

---

## 1. 現状の問題点

### 1.1 現在のテストアーキテクチャ

```
tests/integration/
├── main.cpp              # 全テストを統括（インタプリタ専用）
├── framework/
│   └── integration_test_framework.hpp  # コマンド実行フレームワーク
└── [各テストカテゴリ]/
    └── test_*.hpp        # 個別のテストケース
```

**現在の実行方式**:
```cpp
// tests/integration/framework/integration_test_framework.hpp
int run_command_and_capture(const std::string& command, std::string& output) {
    FILE* pipe = popen(command.c_str(), "r");
    // インタプリタを直接実行: ./main file.cb
}
```

### 1.2 問題点

1. **実行モードが固定**
   - 現在: インタプリタモード専用 (`./main file.cb`)
   - HIRテストには非対応（コンパイル+実行が必要）

2. **テストケースとフレームワークの密結合**
   - テストケースが実行コマンドを直接指定
   - 実行方式を変更するには全テストを書き換える必要

3. **HIR統合テストの課題**
   - 別スクリプト (`run_hir_tests.sh`) で実装
   - C++テストフレームワークと統合できない
   - テストケースの重複管理が必要

---

## 2. 提案する新アーキテクチャ

### 2.1 設計原則

1. **実行戦略の抽象化**
   - テストケースは実行方式に依存しない
   - 実行戦略を選択可能にする

2. **統一テストケース**
   - インタプリタ/コンパイラで同じテストケースを使用
   - テストロジックの重複排除

3. **段階的移行**
   - 既存のインタプリタテストは維持
   - 新しいHIRテストを追加

### 2.2 新しいディレクトリ構造

```
tests/integration/
├── main.cpp                          # 廃止予定（後方互換性のため残す）
├── test_interpreter.cpp              # インタプリタモード専用エントリポイント
├── test_main_hir.cpp                 # HIRコンパイラモード専用エントリポイント
├── test_main.cpp                     # 共通テストケース定義（実行方式非依存）
├── framework/
│   ├── integration_test_framework.hpp    # 基本フレームワーク
│   ├── execution_strategy.hpp            # NEW: 実行戦略の抽象化
│   ├── interpreter_strategy.hpp          # NEW: インタプリタ実行戦略
│   └── compiler_strategy.hpp             # NEW: コンパイラ実行戦略
└── [各テストカテゴリ]/
    └── test_*.hpp                    # テストケース（実行方式非依存に改修）
```

---

## 3. 詳細設計

### 3.1 実行戦略インターフェース

```cpp
// framework/execution_strategy.hpp
#pragma once
#include <string>

namespace cb {
namespace test {

// 実行戦略の抽象基底クラス
class ExecutionStrategy {
public:
    virtual ~ExecutionStrategy() = default;
    
    // Cbファイルを実行して結果を取得
    // @param cb_file: 実行するCbファイルのパス
    // @param output: 実行結果の出力
    // @param execution_time_ms: 実行時間（ミリ秒）
    // @return: 終了コード
    virtual int execute(const std::string& cb_file,
                       std::string& output,
                       double& execution_time_ms) = 0;
    
    // クリーンアップ（一時ファイル削除等）
    virtual void cleanup() = 0;
    
    // 戦略名を取得
    virtual std::string get_name() const = 0;
};

// グローバル実行戦略（テストフレームワークが使用）
extern ExecutionStrategy* g_execution_strategy;

} // namespace test
} // namespace cb
```

### 3.2 インタプリタ実行戦略

```cpp
// framework/interpreter_strategy.hpp
#pragma once
#include "execution_strategy.hpp"
#include <cstdlib>
#include <chrono>

namespace cb {
namespace test {

class InterpreterStrategy : public ExecutionStrategy {
public:
    int execute(const std::string& cb_file,
               std::string& output,
               double& execution_time_ms) override {
        // インタプリタとして実行: ./main file.cb
        std::string command = "../../main " + cb_file + " 2>&1";
        
        auto start = std::chrono::high_resolution_clock::now();
        
        char buffer[128];
        std::string result;
        FILE* pipe = popen(command.c_str(), "r");
        if (!pipe) {
            throw std::runtime_error("popen() failed!");
        }
        
        while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            result += buffer;
        }
        
        int exit_code = pclose(pipe);
        
        auto end = std::chrono::high_resolution_clock::now();
        execution_time_ms = std::chrono::duration<double, std::milli>(end - start).count();
        
        output = result;
        return exit_code;
    }
    
    void cleanup() override {
        // インタプリタは一時ファイルを生成しない
    }
    
    std::string get_name() const override {
        return "Interpreter";
    }
};

} // namespace test
} // namespace cb
```

### 3.3 コンパイラ実行戦略（HIR）

```cpp
// framework/compiler_strategy.hpp
#pragma once
#include "execution_strategy.hpp"
#include <cstdlib>
#include <chrono>
#include <unistd.h>
#include <libgen.h>

namespace cb {
namespace test {

class CompilerStrategy : public ExecutionStrategy {
private:
    std::vector<std::string> temp_files; // 一時ファイルリスト
    
public:
    int execute(const std::string& cb_file,
               std::string& output,
               double& execution_time_ms) override {
        // 1. コンパイル: ./main -c file.cb
        //    出力: file または file.out
        
        // 出力実行ファイル名を決定
        char* cb_file_copy = strdup(cb_file.c_str());
        char* base = basename(cb_file_copy);
        std::string base_name(base);
        free(cb_file_copy);
        
        // .cbを削除
        size_t dot_pos = base_name.find(".cb");
        if (dot_pos != std::string::npos) {
            base_name = base_name.substr(0, dot_pos);
        }
        
        std::string exe_file = "./" + base_name;
        temp_files.push_back(exe_file);
        
        // コンパイル
        std::string compile_cmd = "../../main -c " + cb_file + " 2>&1";
        std::string compile_output;
        
        auto compile_start = std::chrono::high_resolution_clock::now();
        
        FILE* compile_pipe = popen(compile_cmd.c_str(), "r");
        if (!compile_pipe) {
            throw std::runtime_error("Compile command failed!");
        }
        
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), compile_pipe) != nullptr) {
            compile_output += buffer;
        }
        
        int compile_exit = pclose(compile_pipe);
        
        if (compile_exit != 0) {
            // コンパイルエラー
            output = "COMPILE ERROR:\n" + compile_output;
            execution_time_ms = 0;
            return compile_exit;
        }
        
        // 2. 実行: ./file
        std::string run_cmd = exe_file + " 2>&1";
        
        auto run_start = std::chrono::high_resolution_clock::now();
        
        FILE* run_pipe = popen(run_cmd.c_str(), "r");
        if (!run_pipe) {
            throw std::runtime_error("Execution command failed!");
        }
        
        std::string result;
        while (fgets(buffer, sizeof(buffer), run_pipe) != nullptr) {
            result += buffer;
        }
        
        int run_exit = pclose(run_pipe);
        
        auto end = std::chrono::high_resolution_clock::now();
        execution_time_ms = std::chrono::duration<double, std::milli>(end - run_start).count();
        
        output = result;
        return run_exit;
    }
    
    void cleanup() override {
        // 一時ファイルを削除
        for (const auto& file : temp_files) {
            std::remove(file.c_str());
        }
        temp_files.clear();
    }
    
    std::string get_name() const override {
        return "HIR Compiler";
    }
};

} // namespace test
} // namespace cb
```

### 3.4 テストケースの修正例

**Before（現在）**:
```cpp
// tests/integration/basic/test_basic.hpp
void test_basic_hello() {
    std::string output;
    int exit_code = run_command_and_capture("../../main basic/hello.cb", output);
    INTEGRATION_TEST_ASSERT(exit_code == 0);
    INTEGRATION_TEST_ASSERT(output == "Hello, World!\n");
}
```

**After（新設計）**:
```cpp
// tests/integration/basic/test_basic.hpp
void test_basic_hello() {
    std::string output;
    double exec_time;
    
    // グローバル実行戦略を使用
    int exit_code = g_execution_strategy->execute("basic/hello.cb", output, exec_time);
    
    INTEGRATION_TEST_ASSERT(exit_code == 0);
    INTEGRATION_TEST_ASSERT(output == "Hello, World!\n");
}
```

### 3.5 エントリポイント

#### test_interpreter.cpp（インタプリタモード）
```cpp
#include "framework/execution_strategy.hpp"
#include "framework/interpreter_strategy.hpp"
#include "test_main.cpp"  // 共通テストケース

using namespace cb::test;

// グローバル戦略の実体
ExecutionStrategy* g_execution_strategy = nullptr;

int main() {
    std::cout << "Running Integration Tests (Interpreter Mode)" << std::endl;
    
    // インタプリタ戦略を設定
    InterpreterStrategy interpreter_strategy;
    g_execution_strategy = &interpreter_strategy;
    
    // 共通テストケースを実行
    int result = run_all_tests();
    
    g_execution_strategy = nullptr;
    return result;
}
```

#### test_main_hir.cpp（コンパイラモード）
```cpp
#include "framework/execution_strategy.hpp"
#include "framework/compiler_strategy.hpp"
#include "test_main.cpp"  // 共通テストケース

using namespace cb::test;

// グローバル戦略の実体
ExecutionStrategy* g_execution_strategy = nullptr;

int main() {
    std::cout << "Running Integration Tests (HIR Compiler Mode)" << std::endl;
    
    // コンパイラ戦略を設定
    CompilerStrategy compiler_strategy;
    g_execution_strategy = &compiler_strategy;
    
    // 共通テストケースを実行
    int result = run_all_tests();
    
    // クリーンアップ
    compiler_strategy.cleanup();
    
    g_execution_strategy = nullptr;
    return result;
}
```

#### test_main.cpp（共通テストケース定義）
```cpp
// 現在のmain.cppから実行ロジックを分離
// テストケースの定義のみを含む

// テスト実行関数
int run_all_tests() {
    std::vector<std::string> failed_tests;
    
    // 既存のテスト実行ロジック
    run_test_with_continue(test_basic, "basic", failed_tests);
    run_test_with_continue(test_arithmetic, "arithmetic", failed_tests);
    // ... 他のテスト
    
    return failed_tests.empty() ? 0 : 1;
}
```

---

## 4. 実装計画

### Phase 1: フレームワーク実装（v0.14.0）
1. ✅ 実行戦略インターフェースの実装
   - `execution_strategy.hpp`
   - `interpreter_strategy.hpp`
   - `compiler_strategy.hpp`

2. ✅ 既存テストの互換性確認
   - 現在の`main.cpp`を`test_interpreter.cpp`にリネーム
   - `run_command_and_capture()`を戦略パターンに置き換え

3. ✅ HIRエントリポイント作成
   - `test_main_hir.cpp`の実装
   - Makefileターゲット追加

### Phase 2: テストケース移行（段階的）
1. ⏳ サンプルテストの移行
   - `basic/test_basic.hpp`を新設計に対応
   - 動作確認

2. ⏳ 全テストケースの段階的移行
   - カテゴリごとに移行
   - 各段階で動作確認

### Phase 3: 統合と最適化
1. ⏳ 両モードでの完全動作確認
2. ⏳ CI/CD統合
3. ⏳ ドキュメント更新

---

## 5. Makefileターゲット

```makefile
# インタプリタモード（現行）
integration-test: $(TESTS_DIR)/integration/test_interpreter
	@cd tests/integration && ./test_interpreter

# HIRコンパイラモード（新規）
hir-integration-test: $(TESTS_DIR)/integration/test_main_hir
	@cd tests/integration && ./test_main_hir

# ビルドターゲット
$(TESTS_DIR)/integration/test_interpreter: $(TESTS_DIR)/integration/test_interpreter.cpp $(MAIN_TARGET)
	@cd tests/integration && $(CC) $(CFLAGS) -I. -o test_interpreter test_interpreter.cpp

$(TESTS_DIR)/integration/test_main_hir: $(TESTS_DIR)/integration/test_main_hir.cpp $(MAIN_TARGET)
	@cd tests/integration && $(CC) $(CFLAGS) -I. -o test_main_hir test_main_hir.cpp
```

---

## 6. メリット

### 6.1 柔軟性
- ✅ 実行方式を簡単に切り替え可能
- ✅ 新しい実行戦略（LLVM, WASM等）を追加しやすい

### 6.2 保守性
- ✅ テストケースと実行方式が分離
- ✅ テストロジックの重複排除

### 6.3 拡張性
- ✅ 段階的な移行が可能
- ✅ 既存テストを壊さない

### 6.4 テストカバレッジ
- ✅ インタプリタとコンパイラの両方をテスト
- ✅ HIRの動作保証

---

## 7. 留意点

### 7.1 実装上の注意
1. **一時ファイル管理**
   - コンパイラモードは実行ファイルを生成
   - 適切なクリーンアップが必要

2. **パス解決**
   - テストケースからの相対パスを正しく解決
   - 作業ディレクトリに注意

3. **エラーハンドリング**
   - コンパイルエラーと実行エラーを区別
   - わかりやすいエラーメッセージ

### 7.2 互換性
1. **後方互換性**
   - 現在の`main.cpp`を`test_interpreter.cpp`として維持
   - 既存の`make integration-test`は引き続き動作

2. **段階的移行**
   - 全テストケースを一度に変更しない
   - カテゴリごとに検証

---

## 8. 次のステップ

### 8.1 即時対応（v0.14.0）
1. ✅ このドキュメントの作成
2. ⏳ フレームワークの実装
3. ⏳ サンプルテストで動作確認

### 8.2 短期（v0.14.1）
1. ⏳ 主要テストカテゴリの移行
2. ⏳ 両モードでの完全動作確認

### 8.3 中期（v0.15.0）
1. ⏳ 全テストケースの移行完了
2. ⏳ 旧アーキテクチャの廃止

---

## 9. 結論

この設計により、以下が実現されます：

1. **統一されたテストアーキテクチャ**
   - インタプリタ/コンパイラで同じテストケースを使用
   - 実行戦略の抽象化により柔軟性を確保

2. **段階的な移行パス**
   - 既存テストを壊さない
   - リスクを最小化

3. **将来の拡張性**
   - 新しいバックエンド（LLVM, WASM等）への対応が容易
   - テストフレームワークの進化を継続可能

**このアーキテクチャはv0.14.0で基盤を実装し、v0.14.1以降で段階的に移行を完了します。**

---

**作成者**: Cb言語開発チーム  
**レビュー日**: 2025-11-16  
**承認**: 設計レビュー待ち
