# Cb言語 機能実装ロードマップ

**最終更新**: 2025年10月5日  
**対象バージョン**: v0.10.0以降

---

## 📊 実装状況サマリー

### ✅ 完全実装済み（v0.9.0）

1. ✅ **基本ポインタシステム**: 宣言、デリファレンス、演算
2. ✅ **構造体ポインタ**: アロー演算子、ネストアクセス
3. ✅ **Interface/Implポインタ**: ポリモーフィズム
4. ✅ **impl内static変数**: 共有状態管理
5. ✅ **参照型**: `int&` 引数・戻り値
6. ✅ **nullptr**: nullポインタリテラル
7. ✅ **enum型**: スコープアクセス
8. ✅ **浮動小数点数**: float/double
9. ✅ **多次元配列**: 2D/3D配列
10. ✅ **private修飾子**: メンバー・メソッド

---

## 🎯 v0.10.0 実装計画（優先度順）

### Phase 1: ポインタ機能の完成（必須）

#### 1.1 ポインタ配列添字 `ptr[n]` ⭐⭐⭐
**優先度**: 🔴 高（利便性に大きく影響）

**現状**: ❌ 未実装
```c++
int* ptr = &arr[0];
int value = ptr[2];  // ❌ エラー: 配列ではない
```

**実装要件**:
- パーサーで`ptr[n]`を`*(ptr + n)`に変換
- 型チェック: ポインタ型に対してのみ有効
- 読み書き両方をサポート

**推定工数**: 2-3日
**ファイル**: 
- `recursive_parser.cpp`: 構文解析
- `expression_evaluator.cpp`: 評価ロジック

**テスト**: `test_ptr_subscript.cb`（作成済み）

---

#### 1.2 多次元配列へのポインタ ⭐⭐
**優先度**: 🟡 中

**現状**: ❌ 未実装
```c++
int[3][4] matrix;
int[4]* row_ptr = &matrix[0];  // ❌ 型システムがサポートしていない
```

**実装要件**:
- 配列ポインタ型の追加: `int[N]*`
- ポインタ演算: `row_ptr++`で次の行
- デリファレンス: `(*row_ptr)[2]`

**推定工数**: 4-5日
**難易度**: 高（型システムの拡張が必要）

---

### Phase 2: 関数ポインタ・コールバック機能 ⭐⭐⭐

#### 2.1 関数ポインタ型定義
**優先度**: 🔴 高（コールバック機能に必須）

**現状**: ❌ 未実装
```c++
typedef int (*BinaryOp)(int, int);  // ❌ 構文エラー
```

**実装要件**:
- 関数ポインタ型の構文解析
- 関数シグネチャの型チェック
- 関数名→ポインタ変換

**推定工数**: 5-7日
**難易度**: 高（新しい型システムの追加）

**実装ステップ**:
1. パーサーで`(*name)(params)`構文を認識
2. `TYPE_FUNCTION_POINTER`型の追加
3. 関数アドレス取得メカニズム
4. 間接呼び出しの実装

---

#### 2.2 関数ポインタ配列
**優先度**: 🟡 中

```c++
BinaryOp[3] ops = [add, subtract, multiply];
int result = ops[0](5, 3);
```

**依存**: 2.1の完了後

---

#### 2.3 関数ポインタ引数・戻り値
**優先度**: 🟡 中

```c++
void apply(int (*func)(int), int value) {
    return func(value);
}
```

**依存**: 2.1の完了後

---

### Phase 3: 構造体配列メンバーの改善

#### 3.1 構造体配列メンバーへの関数戻り値代入
**優先度**: 🟡 中

**現状**: ❌ 未サポート
```c++
struct Container {
    int[5] data;
};

int[5] create_array() { return [1,2,3,4,5]; }

Container c;
c.data = create_array();  // ❌ エラー
```

**推定工数**: 3-4日

---

#### 3.2 多次元配列メンバーへの関数戻り値代入
**優先度**: 🟡 中

**依存**: 3.1の完了後

---

### Phase 4: 高度なポインタ機能（低優先度）

#### 4.1 const ポインタ
**優先度**: 🟢 低

```c++
const int* ptr1;      // ポイント先がconst
int* const ptr2;      // ポインタ自体がconst
const int* const ptr3;  // 両方const
```

**推定工数**: 2-3日

---

#### 4.2 多重ポインタ
**優先度**: 🟢 低

```c++
int** pptr;  // ポインタのポインタ
***pptr = 42;  // 3レベル間接参照
```

**推定工数**: 3-4日

---

#### 4.3 void* 汎用ポインタ
**優先度**: 🟢 低

```c++
void* generic = &some_value;
int* typed = (int*)generic;  // キャストが必要
```

**推定工数**: 2-3日

---

### Phase 5: メモリ管理（v1.0.0以降）

#### 5.1 動的メモリ確保 `new`/`delete`
**優先度**: 🟢 低（v1.0.0）

```c++
Point* p = new Point;
delete p;

int* arr = new int[10];
delete[] arr;
```

**推定工数**: 1-2週間
**難易度**: 高（メモリ管理機構の追加）

---

#### 5.2 スマートポインタ
**優先度**: 🟢 低（v1.0.0以降）

```c++
unique_ptr<Point> p = make_unique<Point>();
shared_ptr<int> sp = make_shared<int>(42);
```

**推定工数**: 2-3週間
**難易度**: 非常に高（RAII、参照カウント）

---

## 📅 実装スケジュール

### v0.10.0（1-2ヶ月）
- ✅ Phase 1.1: `ptr[n]`構文（必須）
- ✅ Phase 2.1-2.2: 関数ポインタ基本（必須）
- ⚠️ Phase 1.2: 多次元配列ポインタ（可能なら）

### v0.11.0（2-3ヶ月後）
- ✅ Phase 3: 構造体配列メンバー改善
- ✅ Phase 2.3: 関数ポインタ引数・戻り値
- ⚠️ Phase 4.1: const ポインタ（可能なら）

### v1.0.0（6-12ヶ月後）
- ✅ Phase 4: 高度なポインタ機能完全実装
- ✅ Phase 5.1: 動的メモリ管理
- ⚠️ Phase 5.2: スマートポインタ（検討）

---

## 🔧 技術的課題

### 関数ポインタ実装の課題
1. **型システムの拡張**
   - 現在: `TYPE_INT`, `TYPE_POINTER`, `TYPE_ARRAY`
   - 必要: `TYPE_FUNCTION_POINTER`
   - 関数シグネチャ情報の保持

2. **関数アドレスの表現**
   - ASTノードへのポインタ？
   - 関数名文字列？
   - 専用の関数IDシステム？

3. **間接呼び出しメカニズム**
   - 現在: 関数名で直接検索
   - 必要: ポインタ経由の呼び出し

### ポインタ配列添字の課題
1. **構文の曖昧性**
   - `ptr[n]`: 配列アクセス vs ポインタ演算
   - 型情報による区別が必要

2. **評価順序**
   - `ptr[i++]`: iのインクリメントタイミング
   - 左辺値としての使用: `ptr[n] = value`

---

## 📚 参考実装

### C++標準
- 関数ポインタ: ISO C++11以降
- スマートポインタ: `<memory>`ヘッダー

### Go言語
- 関数型: `func(int, int) int`
- クロージャサポート

### Rust言語
- 関数ポインタ: `fn(i32) -> i32`
- 所有権システム

---

## ✅ 実装完了チェックリスト

### v0.10.0
- [ ] `ptr[n]`構文実装
- [ ] 関数ポインタ型定義
- [ ] 関数ポインタ代入・呼び出し
- [ ] 関数ポインタ配列
- [ ] テストスイート作成（50+テスト）
- [ ] ドキュメント更新

### 成功基準
- すべてのテストがパス
- パフォーマンス劣化なし（<5%）
- 後方互換性維持

---

**次回更新**: v0.10.0リリース時
