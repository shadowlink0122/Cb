# 未実装機能の実装方針（ユーザー要望）

**作成日**: 2025年10月6日  
**対象**: ユーザーから指摘された未実装機能

---

## 🎯 ユーザーからの要望

以下の機能について実装状況を確認し、未実装のものについては実装計画を立てる：

1. ✅ 関数ポインタ → **実装済み**（2025/10/06）
2. ❌ 多次元配列へのポインタ → **未実装**
3. ❌ 構造体配列メンバーの関数戻り値代入 → **未実装**
4. ❌ 多次元配列の関数戻り値からメンバー代入 → **未実装**
5. ⚠️ ポインタの配列 → **基本実装済み、検証が必要**
6. ❌ constポインタ → **未実装**
7. ❌ 多重ポインタ → **未実装**

---

## 📊 実装優先順位

### 🔴 高優先度（v0.10.0で実装）

#### 1. 多次元配列へのポインタ

**理由**: ポインタシステムの完全性のために重要

**実装範囲**:
- 配列の特定要素へのポインタ: `int* ptr = &matrix[1][2];` ✅ 動作する可能性あり
- 配列の行へのポインタ: `int[4]* row_ptr = &matrix[0];` ❌ 未サポート
- ポインタ演算: `row_ptr++`, `row_ptr + n` ❌ 未サポート

**技術的課題**:
1. 配列ポインタ型の型システムへの追加
2. ADDRESS_OF演算子の拡張
3. ポインタ演算の配列サイズ対応
4. デリファレンスの配列戻り値対応

**実装見積もり**: 2-3日

---

### 🟡 中優先度（v0.10.0または v0.11.0で実装）

#### 2. 構造体配列メンバーの関数戻り値代入

**理由**: 利便性向上

**現状の問題**:
```cb
struct Container {
    int[5] data;
};

int[5] create_array() {
    return [1, 2, 3, 4, 5];
}

void main() {
    Container c;
    c.data = create_array();  // ❌ エラー
}
```

**技術的課題**:
1. 構造体メンバー配列への配列代入処理
2. 配列のメモリコピー
3. 型チェック（サイズと型の一致）

**実装見積もり**: 1-2日

---

#### 3. 多次元配列の関数戻り値からメンバー代入

**理由**: 2の拡張として実装

**現状の問題**:
```cb
struct Matrix {
    int[2][2] data;
};

int[2][2] create_matrix() {
    return [[1, 2], [3, 4]];
}

void main() {
    Matrix m;
    m.data = create_matrix();  // ❌ エラー
}
```

**技術的課題**:
- 2と同様だが、多次元配列のメモリコピーが必要

**実装見積もり**: 1日

---

#### 4. ポインタの配列（包括的テスト）

**理由**: 既存機能の完全性確認

**現状**: 基本機能は実装済み

**必要な作業**:
- 包括的なテストケースの作成
- エッジケースの確認
- ドキュメント化

**実装見積もり**: 半日

---

### 🟢 低優先度（v0.11.0以降で実装）

#### 5. constポインタ

**理由**: 型安全性向上だが、緊急性は低い

**実装範囲**:
- `const int* ptr`: ポイント先が定数
- `int* const ptr`: ポインタ自体が定数
- `const int* const ptr`: 両方が定数

**技術的課題**:
1. const修飾子の型システムへの統合
2. const違反の検出
3. 代入時のチェック

**実装見積もり**: 2-3日

---

#### 6. 多重ポインタ

**理由**: 高度な機能だが、使用頻度は低い

**実装範囲**:
- `int** pptr`: ポインタのポインタ
- `int*** ppptr`: 3重ポインタ以上
- 多段階デリファレンス: `**pptr`

**技術的課題**:
1. 型システムのポインタ深度管理
2. 多段階デリファレンス処理
3. ADDRESS_OF演算子の拡張（ポインタのアドレス取得）

**実装見積もり**: 2-3日

---

## 📅 実装スケジュール

### v0.10.0（実装中）

**Week 1-2: 高優先度機能**
- Day 1-3: 多次元配列へのポインタ
  - 型システム拡張
  - ADDRESS_OF演算子拡張
  - ポインタ演算実装
  - テスト作成

**Week 3: 中優先度機能（パート1）**
- Day 1-2: 構造体配列メンバーの関数戻り値代入
- Day 3: 多次元配列の関数戻り値からメンバー代入

**Week 4: 中優先度機能（パート2）**
- Day 1: ポインタの配列の包括的テスト
- Day 2-3: ドキュメント更新、リリース準備

### v0.11.0（将来）

**低優先度機能**
- constポインタ
- 多重ポインタ

---

## 🔍 実装の詳細計画

### 1. 多次元配列へのポインタ

#### Phase 1: 要素へのポインタ（検証）
```cb
int[3][4] matrix = [[1,2,3,4], [5,6,7,8], [9,10,11,12]];
int* elem_ptr = &matrix[1][2];  // ← これが動作するか確認
```

**必要な作業**:
- 既存実装の動作確認
- テストケース作成

#### Phase 2: 行へのポインタ（新規実装）
```cb
int[4]* row_ptr = &matrix[0];  // ← 新規実装が必要
```

**実装箇所**:
1. `src/common/ast.h`: 配列ポインタ型の追加
   ```cpp
   struct ArrayPointerTypeInfo {
       TypeInfo element_type;
       int array_size;
   };
   ```

2. `src/frontend/recursive_parser/recursive_parser.cpp`: 型解析拡張
   - `int[4]*` のような構文を解析
   - `ArrayPointerTypeInfo` を生成

3. `src/backend/interpreter/evaluator/expression_evaluator.cpp`: ADDRESS_OF演算子拡張
   - `&matrix[i]` が行ポインタを返すように修正
   - 返り値の型を `ArrayPointerTypeInfo` に設定

4. `src/backend/interpreter/evaluator/expression_evaluator.cpp`: ポインタ演算拡張
   - 配列ポインタの `++`/`--`: `sizeof(int[4])` 分のオフセット
   - `ptr + n`: `n * sizeof(int[4])` のオフセット

5. `src/backend/interpreter/evaluator/expression_evaluator.cpp`: デリファレンス拡張
   - `*row_ptr` が配列（`int[4]`）を返す
   - `(*row_ptr)[i]` でインデックスアクセス

**テストケース**:
```cb
void test_multidim_array_pointer() {
    int[3][4] matrix = [[1,2,3,4], [5,6,7,8], [9,10,11,12]];
    
    // テスト1: 行ポインタの取得
    int[4]* row_ptr = &matrix[0];
    
    // テスト2: デリファレンス
    int value1 = (*row_ptr)[2];
    println(value1);  // 3
    
    // テスト3: ポインタ演算
    row_ptr++;
    int value2 = (*row_ptr)[1];
    println(value2);  // 6
    
    // テスト4: 複数回の演算
    row_ptr = &matrix[0];
    int[4]* ptr2 = row_ptr + 2;
    int value3 = (*ptr2)[3];
    println(value3);  // 12
}
```

---

### 2. 構造体配列メンバーの関数戻り値代入

**実装箇所**:
1. `src/backend/interpreter/executor/statement_executor.cpp`: 代入演算子の拡張
   ```cpp
   // 構造体メンバー配列への代入を検出
   if (lhs->node_type == AST_MEMBER_ACCESS && 
       member_var->type == TYPE_ARRAY &&
       rhs->node_type == AST_FUNCTION_CALL) {
       // 配列のメモリコピー処理
   }
   ```

2. `src/backend/interpreter/managers/variable_manager.cpp`: 配列コピーヘルパー
   ```cpp
   void copy_array_to_member(Variable& dest, const Variable& src) {
       // サイズと型のチェック
       if (dest.array_size != src.array_size) {
           throw std::runtime_error("Array size mismatch");
       }
       // 要素のコピー
       for (int i = 0; i < dest.array_size; i++) {
           dest.array_elements[i] = src.array_elements[i];
       }
   }
   ```

**テストケース**:
```cb
struct Container {
    int[5] data;
};

int[5] create_array() {
    return [10, 20, 30, 40, 50];
}

void test_struct_array_member_assignment() {
    Container c;
    c.data = create_array();
    
    // 確認
    for (int i = 0; i < 5; i++) {
        println(c.data[i]);
    }
    // 出力: 10, 20, 30, 40, 50
}
```

---

### 3. 多次元配列の関数戻り値からメンバー代入

**実装**: 2と同様だが、再帰的な配列コピーが必要

**テストケース**:
```cb
struct Matrix {
    int[2][2] data;
};

int[2][2] create_matrix() {
    return [[1, 2], [3, 4]];
}

void test_multidim_array_member_assignment() {
    Matrix m;
    m.data = create_matrix();
    
    // 確認
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            println(m.data[i][j]);
        }
    }
    // 出力: 1, 2, 3, 4
}
```

---

### 4. ポインタの配列（包括的テスト）

**テストケース**:
```cb
void test_pointer_array_comprehensive() {
    // テスト1: 基本宣言と代入
    int a = 10, b = 20, c = 30;
    int* ptrs[3];
    ptrs[0] = &a;
    ptrs[1] = &b;
    ptrs[2] = &c;
    
    // テスト2: ループ操作
    int[5] arr = [1, 2, 3, 4, 5];
    int* arr_ptrs[5];
    for (int i = 0; i < 5; i++) {
        arr_ptrs[i] = &arr[i];
    }
    
    // テスト3: デリファレンス
    for (int i = 0; i < 5; i++) {
        println(*arr_ptrs[i]);
    }
    
    // テスト4: 構造体メンバーとして
    struct PointerContainer {
        int* ptrs[10];
    };
    
    PointerContainer container;
    for (int i = 0; i < 5; i++) {
        container.ptrs[i] = &arr[i];
    }
}
```

---

## ✅ 完了条件

各機能の完了条件を定義：

### 1. 多次元配列へのポインタ
- [ ] 要素へのポインタが動作することを確認
- [ ] 行へのポインタ型の実装
- [ ] ポインタ演算の実装
- [ ] デリファレンスの実装
- [ ] テストケース作成（最低3パターン）
- [ ] 統合テスト成功

### 2. 構造体配列メンバーの関数戻り値代入
- [ ] 1次元配列メンバーへの代入実装
- [ ] 型チェックの実装
- [ ] エラーメッセージの改善
- [ ] テストケース作成
- [ ] 統合テスト成功

### 3. 多次元配列の関数戻り値からメンバー代入
- [ ] 2次元配列メンバーへの代入実装
- [ ] 再帰的なコピー処理
- [ ] テストケース作成
- [ ] 統合テスト成功

### 4. ポインタの配列の包括的テスト
- [ ] 基本操作のテスト
- [ ] ループ操作のテスト
- [ ] 構造体メンバーのテスト
- [ ] すべてのテストが成功

### 5. constポインタ（低優先度）
- [ ] `const T*` の実装
- [ ] `T* const` の実装
- [ ] const違反の検出
- [ ] テストケース作成

### 6. 多重ポインタ（低優先度）
- [ ] `T**` の実装
- [ ] 多段階デリファレンス
- [ ] ポインタのアドレス取得
- [ ] テストケース作成

---

## 📝 実装時の注意事項

### 型システムの拡張
- 既存の型システムとの互換性を保つ
- 型情報の文字列表現を更新
- エラーメッセージに型情報を含める

### パフォーマンス
- 配列コピーは最適化を検討
- 大きな配列のコピーは警告を出す可能性

### テスト
- 各機能ごとに独立したテストケースを作成
- エッジケースを含める
- エラーケースもテスト

---

**最終更新**: 2025年10月6日  
**次回レビュー**: 多次元配列へのポインタ実装完了時
