# コンストラクタ/デストラクタ実装計画

**作成日**: 2025年10月9日  
**対象バージョン**: v0.10.0  
**優先度**: 🔴 高

---

## 📋 概要

構造体に対するコンストラクタとデストラクタを実装し、オブジェクトのライフサイクル管理を自動化する。

**設計原則**:
- 構造体 (`struct`) はデータのみを定義
- コンストラクタ/デストラクタ/メソッドは `impl` ブロック内で定義
- 構造体と実装を分離することで、データ構造と振る舞いを明確に区別

---

## 🎯 目的

1. **リソース管理の自動化**: メモリや外部リソースの確保・解放を自動化
2. **初期化の保証**: オブジェクトが必ず適切に初期化される
3. **オブジェクト指向機能の基盤**: クラスライクな機能の第一歩

---

## 📝 基本仕様

### コンストラクタ

**定義方法**:
```cb
struct Point {
    int x;
    int y;
};

impl Point {
    // デフォルトコンストラクタ
    Point() {
        this.x = 0;
        this.y = 0;
    }
    
    // パラメータ付きコンストラクタ
    Point(int px, int py) {
        this.x = px;
        this.y = py;
    }
}
```

**呼び出しタイミング**:
1. 変数宣言時
2. 配列要素の初期化時
3. 構造体を返す関数の戻り値生成時

**使用例**:
```cb
void main() {
    Point p1;           // Point() 呼び出し → (0, 0)
    Point p2(10, 20);   // Point(int, int) 呼び出し → (10, 20)
    
    Point[3] points;    // 各要素でPoint()呼び出し
}
```

### デストラクタ

**定義方法**:
```cb
struct Resource {
    int handle;
};

impl Resource {
    Resource(int h) {
        this.handle = h;
        println("Resource acquired");
    }
    
    ~Resource() {
        println("Resource released");
        // リソース解放処理
    }
}
```

**呼び出しタイミング**:
1. ローカル変数のスコープ終了時
2. 配列要素の破棄時（逆順）
3. 関数の早期return時

**使用例**:
```cb
void main() {
    Resource r(100);
    println("Using resource");
    // スコープ終了時に自動的に ~Resource() 呼び出し
}

// 出力:
// Resource acquired
// Using resource
// Resource released
```

### thisポインタ

**仕様**:
- `this` はimpl内のコンストラクタ/デストラクタ/メソッドで使用可能な暗黙的なポインタ
- 現在の構造体インスタンスを指す
- メンバーアクセスに使用: `this.member`

**使用例**:
```cb
struct Counter {
    int count;
};

impl Counter {
    Counter(int initial) {
        this.count = initial;  // メンバーへのアクセス
    }
    
    void increment() {
        this.count = this.count + 1;
    }
}
```

---

## 🔧 実装要件

### 1. 構文拡張

**Lexer**:
- キーワード追加: `this`
- デストラクタ構文: `~識別子`

**Parser**:
- コンストラクタ認識: 構造体名と同名の関数
- デストラクタ認識: `~構造体名` の関数
- `this` キーワードの解析

### 2. AST拡張

```cpp
// 構造体定義はデータのみ
struct StructDef {
    std::string name;
    std::vector<MemberVariable> members;
    // メソッドは持たない
};

// impl定義にコンストラクタ/デストラクタを含める
struct ImplDef {
    std::string struct_name;
    std::vector<ConstructorDef> constructors;  // NEW
    std::unique_ptr<DestructorDef> destructor; // NEW
    std::vector<MethodDef> methods;            // 既存
    std::vector<StaticVariableDef> statics;    // 既存
};

struct ConstructorDef {
    std::string struct_name;
    std::vector<Parameter> parameters;
    std::unique_ptr<StatementNode> body;
};

struct DestructorDef {
    std::string struct_name;
    std::unique_ptr<StatementNode> body;
};
```

### 3. インタプリタ拡張

**コンストラクタ呼び出し**:
```cpp
// 変数宣言時
void Interpreter::declare_struct_variable(StructDeclarationNode* node) {
    Variable var;
    // ... 変数初期化 ...
    
    // impl定義からコンストラクタを検索
    auto impl_def = find_impl(node->struct_name);
    if (impl_def) {
        auto constructor = find_constructor_in_impl(impl_def, node->arguments);
        if (constructor) {
            call_constructor(var, constructor, node->arguments);
        }
    }
}
```

**デストラクタ呼び出し**:
```cpp
// スコープ管理
class ScopeGuard {
    std::vector<Variable*> variables_to_destroy;
    
public:
    ~ScopeGuard() {
        // 逆順でデストラクタ呼び出し
        for (auto it = variables_to_destroy.rbegin(); 
             it != variables_to_destroy.rend(); ++it) {
            call_destructor(*it);
        }
    }
};
```

**thisポインタ実装**:
```cpp
// コンストラクタ/メンバー関数実行時
void Interpreter::execute_constructor(Variable& instance, ConstructorDef* ctor) {
    // thisポインタを設定
    Variable* old_this = current_this;
    current_this = &instance;
    
    // コンストラクタ本体実行
    execute_statement(ctor->body.get());
    
    // this復元
    current_this = old_this;
}
```

### 4. スコープ管理

**実装方針**:
1. 各スコープで宣言された構造体変数を追跡
2. スコープ終了時に逆順でデストラクタ呼び出し
3. 早期returnでも確実にデストラクタ呼び出し

**データ構造**:
```cpp
struct Scope {
    std::map<std::string, Variable> variables;
    std::vector<std::string> destruction_order; // 破棄順序
};
```

### 5. 配列のコンストラクタ/デストラクタ

**配列要素の初期化**:
```cb
Point[3] points;  // 各要素でデフォルトコンストラクタ呼び出し
```

実装:
```cpp
void Interpreter::initialize_struct_array(Variable& array_var, int size) {
    for (int i = 0; i < size; i++) {
        call_constructor(array_var.elements[i], default_constructor);
    }
}
```

**配列要素の破棄**:
```cpp
void Interpreter::destroy_struct_array(Variable& array_var) {
    // 逆順で破棄
    for (int i = array_var.size - 1; i >= 0; i--) {
        call_destructor(array_var.elements[i]);
    }
}
```

---

## 📊 実装ステップ

### Phase 1: 基本構造（2週間）
- [ ] `this` キーワードの追加
- [ ] コンストラクタの解析
- [ ] デストラクタの解析
- [ ] AST構造の拡張

### Phase 2: コンストラクタ実装（2週間）
- [ ] デフォルトコンストラクタの自動呼び出し
- [ ] パラメータ付きコンストラクタ
- [ ] `this` ポインタの実装
- [ ] オーバーロード解決

### Phase 3: デストラクタ実装（2週間）
- [ ] スコープ管理機構
- [ ] デストラクタの自動呼び出し
- [ ] 早期return対応
- [ ] 配列要素の破棄

### Phase 4: テストと検証（1週間）
- [ ] 基本的なコンストラクタ/デストラクタテスト
- [ ] 配列のテスト
- [ ] スコープテスト
- [ ] エッジケーステスト

---

## 🧪 テストケース

### 1. 基本的なコンストラクタ
```cb
struct Counter {
    int value;
};

impl Counter {
    Counter() {
        this.value = 0;
    }
    
    Counter(int v) {
        this.value = v;
    }
}

void main() {
    Counter c1;        // value = 0
    Counter c2(42);    // value = 42
    
    println(c1.value);  // 0
    println(c2.value);  // 42
}
```

### 2. デストラクタの呼び出し順序
```cb
struct Logger {
    string name;
};

impl Logger {
    Logger(string n) {
        this.name = n;
        println("Constructed: " + n);
    }
    
    ~Logger() {
        println("Destructed: " + this.name);
    }
}

void main() {
    Logger a("First");
    Logger b("Second");
    Logger c("Third");
}

// 期待される出力:
// Constructed: First
// Constructed: Second
// Constructed: Third
// Destructed: Third
// Destructed: Second
// Destructed: First
```

### 3. 配列のコンストラクタ/デストラクタ
```cb
struct Logger {
    string name;
};

impl Logger {
    Logger(string n) {
        this.name = n;
        println("Constructed: " + n);
    }
    
    ~Logger() {
        println("Destructed: " + this.name);
    }
}

void main() {
    Logger[3] loggers = {
        {"A"},
        {"B"},
        {"C"}
    };
}

// 期待される出力:
// Constructed: A
// Constructed: B
// Constructed: C
// Destructed: C
// Destructed: B
// Destructed: A
```

### 4. 早期return
```cb
struct Logger {
    string name;
};

impl Logger {
    Logger(string n) {
        this.name = n;
        println("Constructed: " + n);
    }
    
    ~Logger() {
        println("Destructed: " + this.name);
    }
}

void test(bool early_exit) {
    Logger log("test");
    
    if (early_exit) {
        return;  // ここでもデストラクタ呼び出し
    }
    
    println("End of function");
}

void main() {
    test(true);
    test(false);
}

// 期待される出力:
// Constructed: test
// Destructed: test
// Constructed: test
// End of function
// Destructed: test
```

---

## ⚠️ 注意事項

1. **循環参照**: デストラクタで他のオブジェクトのデストラクタが呼ばれる場合の処理
2. **例外安全性**: エラー発生時のデストラクタ呼び出し保証
3. **パフォーマンス**: 大量のオブジェクト生成時のオーバーヘッド
4. **デバッグ**: コンストラクタ/デストラクタのデバッグ情報

---

## 🔄 将来の拡張

1. **コピーコンストラクタ**: `Point(const Point& other)`
2. **ムーブコンストラクタ**: `Point(Point&& other)`
3. **配置new**: メモリ確保とオブジェクト構築の分離
4. **明示的なデストラクタ呼び出し**: `obj.~StructName()`

---

## 📐 設計方針の補足

### structとimplの分離

Cb言語では、データと振る舞いを明確に分離する設計を採用します:

**構造体 (struct)**:
- データメンバーのみを定義
- 純粋なデータ構造として機能
- 単純で理解しやすい

**実装ブロック (impl)**:
- コンストラクタを定義
- デストラクタを定義
- メソッドを定義
- 振る舞いを集約

**メリット**:
1. **明確な責任分離**: データ構造と処理ロジックが分離される
2. **可読性向上**: 構造体定義が簡潔になる
3. **拡張性**: 後から実装を追加しやすい
4. **既存の設計との整合性**: 既存のimpl機能との統一感

**比較**:
```cb
// ❌ C++スタイル（Cbでは採用しない）
struct Point {
    int x, y;
    Point() { ... }        // 構造体内にメソッド
    ~Point() { ... }
};

// ✅ Cbスタイル（データと実装を分離）
struct Point {
    int x;
    int y;
};

impl Point {
    Point() { ... }        // impl内にコンストラクタ
    ~Point() { ... }       // impl内にデストラクタ
    void method() { ... }  // impl内にメソッド
}
```

---

**更新履歴**:
- 2025/10/09: 初版作成
- 2025/10/09: impl内定義に変更（構造体にはメソッドを持たせない方針）
