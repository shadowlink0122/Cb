# Cb言語 v0.11.0 ジェネリクス仕様レビュー

**日付**: 2025年10月12日  
**レビュアー**: AI Assistant  
**ステータス**: 設計完了

---

## 📝 レビューサマリー

提案されたジェネリクス構文を詳細に分析し、いくつかの矛盾と曖昧さを発見しました。以下に改善提案をまとめます。

---

## ✅ 良い点

### 1. 基本構文は明確
```cb
struct S<T> { T a; T b; }
struct S<T1, T2> { T1 a; T2 b; }
```
→ **問題なし**: C++やRustと同様の構文で直感的

### 2. 型制約の考え方
```cb
struct S<T: int | tiny | long | short> { T a; T b; }
```
→ **良い**: Rustのtrait boundsに似た構文で分かりやすい

### 3. ジェネリック関数
```cb
Type<T> func(T a, T b) {}
```
→ **問題なし**: 標準的な構文

---

## ⚠️ 矛盾点と修正提案

### 1. Interface定義の混乱

**元の提案**:
```cb
interface I<T> for S<T> {
    T func1();
}
```

**問題**: Interface定義に`for S<T>`は含まれない。Interface定義とimpl宣言を混同している。

**修正案**:
```cb
// Interface定義（for句なし）
interface I<T> {
    T func1();
    T func2(T arg);
}

// impl宣言（for句あり）
impl I<T> for S<T> {
    T func1() { /* 実装 */ }
    T func2(T arg) { /* 実装 */ }
}
```

---

### 2. 曖昧な省略規則

**元の提案**:
```cb
// 構造体にジェネリクスが設定されている場合のみ省略可能
impl I for S {
    T func1();
}
```

**問題**: どのような場合に省略できるのか不明確。

**明確化**:

#### ケース1: Interfaceがジェネリック、構造体もジェネリック
```cb
interface I<T> { ... }
struct S<T> { ... }

// 完全形（推奨）
impl I<T> for S<T> { ... }

// 省略不可: 型パラメータは明示的に一致させる必要がある
```

#### ケース2: Interfaceが非ジェネリック、構造体がジェネリック
```cb
interface I { void show(); }
struct S<T> { T value; }

// 完全形
impl I for S<T> {
    void show() { /* Tを使用可能 */ }
}

// 省略可能
impl I for S {
    void show() { /* Tは暗黙的に使用可能 */ }
}
```

#### ケース3: 部分的なインスタンス化
```cb
interface I { ... }
struct S<T: int | long | short> { ... }

// intに対してのみ実装
impl I for S<int> { ... }
```

---

### 3. 不明確な構文

**元の提案**:
```cb
// いくつかの型に対するinterfaceを実装したい場合
impl I for <T: int | ... > {
    T func()
}
```

**問題**:
1. `impl I for <T: ...>` の意味が不明確
2. どの構造体に対する実装なのか？
3. Rustには存在しない構文

**解決策**: この構文は削除し、代わりに以下のいずれかを使用

#### Option A: 構造体に対する実装（推奨）
```cb
struct S<T: int | long | short> { T value; }

impl I for S<T> {
    T func() { return self.value; }
}
```

#### Option B: 将来的な拡張（v0.12.0以降）
```cb
// すべてのint, long, shortに対してIを実装
impl<T: int | long | short> I for T {
    T func() { return self; }
}
```
※ これはRustのblanket implementationに相当し、高度な機能

---

### 4. 可変長引数の曖昧さ

**元の提案**:
```cb
interface I<T> {
    T func2(T...);
}
```

**問題**: `T...` の意味が不明確
- C++風の可変長テンプレート引数？
- 可変長関数引数？
- 配列？

**解決策**: v0.11.0では可変長引数を範囲外とし、配列を使用

```cb
interface I<T> {
    T func2(T[] args, int count);
}
```

**将来的な拡張（v0.12.0以降）**:
```cb
// 可変長ジェネリクス
interface I<T...> {
    void process(T... args);
}
```

---

### 5. コンストラクタの型パラメータ

**元の提案**:
```cb
impl I<T: type | ... > {
    self(T ...)
}
```

**問題**:
1. `type` という制約は不明確（すべての型？）
2. `T ...` の意味が不明確

**修正案**:
```cb
struct Box<T: int | long | short> {
    T value;
}

impl Box<T> {
    self(T v) {
        self.value = v;
    }
    
    T get() {
        return self.value;
    }
}
```

---

## 📊 最終的な構文仕様

### ジェネリック構造体
```cb
// 基本形
struct Box<T> {
    T value;
}

// 複数型パラメータ
struct Pair<T1, T2> {
    T1 first;
    T2 second;
}

// 型制約
struct NumericBox<T: int | long | short> {
    T value;
}
```

### ジェネリック関数
```cb
T max<T>(T a, T b) {
    if (a > b) return a;
    return b;
}

void main() {
    int i = max<int>(10, 20);  // 明示的
    // int i = max(10, 20);    // 型推論（v0.12.0以降）
}
```

### ジェネリックInterface
```cb
// Interface定義
interface Container<T> {
    void add(T item);
    T get(int index);
}

// 実装
struct List<T> {
    T[100] items;
    int count;
}

impl Container<T> for List<T> {
    void add(T item) {
        self.items[self.count] = item;
        self.count++;
    }
    
    T get(int index) {
        return self.items[index];
    }
}
```

### ジェネリックコンストラクタ
```cb
struct Box<T> {
    T value;
}

impl Box<T> {
    self(T v) {
        self.value = v;
    }
}

void main() {
    Box<int> box(42);
}
```

### 部分的なインスタンス化
```cb
interface Numeric {
    T add(T other);
}

struct Calculator<T: int | long | short> {
    T value;
}

// intに対してのみ実装
impl Numeric for Calculator<int> {
    int add(int other) {
        return self.value + other;
    }
}
```

---

## 🚀 実装計画（4週間）

### Phase 1: 基本的なジェネリクス（2週間）
- [ ] 構文解析: `<T>`, `<T1, T2>`
- [ ] 型パラメータ管理
- [ ] インスタンス化メカニズム
- [ ] キャッシュシステム
- [ ] テスト: 50個

### Phase 2: 型制約（1週間）
- [ ] Union型制約の解析
- [ ] 制約違反の検出とエラー報告
- [ ] テスト: 30個

### Phase 3: Interface統合（1週間）
- [ ] ジェネリックInterfaceの解析
- [ ] `impl I<T> for S<T>` のサポート
- [ ] 型パラメータの一致検証
- [ ] 部分的なインスタンス化
- [ ] テスト: 40個

### Phase 4: 型推論（将来的な拡張）
- 関数呼び出し時の型パラメータ自動推論
- v0.12.0以降で実装

---

## 📚 参考資料

### Rust
- **ジェネリクス**: `struct S<T> { ... }`
- **トレイト境界**: `<T: Trait>`
- **Where句**: `where T: Trait`
- **関連型**: `type Item;`

### C++
- **テンプレート**: `template<typename T>`
- **SFINAE**: 型制約の高度な手法
- **コンセプト（C++20）**: `template<Concept T>`

### TypeScript
- **ジェネリクス**: `interface I<T> { ... }`
- **型制約**: `<T extends Type>`
- **デフォルト型**: `<T = number>`

---

## 🎯 まとめ

### 修正された点
1. ✅ Interface定義とimpl宣言の分離
2. ✅ 型パラメータの省略規則の明確化
3. ✅ 曖昧な構文の削除 (`impl I for <T: ...>`)
4. ✅ 可変長引数を将来的な拡張として位置づけ
5. ✅ コンストラクタの型パラメータの明確化

### 削除された構文
- `impl I for <T: ...>` → 削除（曖昧）
- `T func2(T...)` → v0.12.0以降に延期

### 追加された明確化
- Interface定義とimplの分離
- 省略規則の3つのケース
- 部分的なインスタンス化のサポート

### 実装優先度
1. 🔴 Phase 1-2: 基本的なジェネリクスと型制約（3週間）
2. 🟡 Phase 3: Interface統合（1週間）
3. 🟢 Phase 4: 型推論（v0.12.0以降）

---

**結論**: 提案された構文は全体的に良好ですが、いくつかの矛盾と曖昧さがありました。このレビューで明確化した仕様に基づいて実装を進めることを推奨します。

---

**作成者**: shadowlink0122  
**レビュー**: AI Assistant  
**承認**: 保留中  
**日付**: 2025年10月12日
