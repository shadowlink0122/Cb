# v0.13.0: Generic Array Support

## æ¦‚è¦
ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“ã®é…åˆ—ã‚µãƒãƒ¼ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã€‚ç¾åœ¨ã€`Future<T>`ã®ã‚ˆã†ãªå‹ã¯é…åˆ—ã¨ã—ã¦å®£è¨€ã§ãã‚‹ãŒã€é…åˆ—è¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«å‹æƒ…å ±ãŒå¤±ã‚ã‚Œã‚‹å•é¡ŒãŒã‚ã‚‹ã€‚

## ç¾çŠ¶ã®å•é¡Œ

### 1. ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“é…åˆ—ã®å‹æƒ…å ±å–ªå¤±
```cb
Future<int> futures[3];
futures[0] = task_id(1);
int r0 = await futures[0];  // ã‚¨ãƒ©ãƒ¼: await expression requires Future<T> operand
```

**å•é¡Œ**: é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹å¼ï¼ˆ`futures[0]`ï¼‰ã‚’è©•ä¾¡ã™ã‚‹éš›ã€è¦ç´ ãŒæ§‹é€ ä½“å‹ã§ã‚ã‚‹ã“ã¨ãŒèªè­˜ã•ã‚Œãªã„ã€‚

### 2. æ ¹æœ¬åŸå› 
- `evaluate_typed_expression_internal`é–¢æ•°ã§`AST_ARRAY_REF`ã®æ˜ç¤ºçš„ãªå‡¦ç†ãŒãªã„
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚±ãƒ¼ã‚¹ã§`evaluate_expression`ãŒå‘¼ã°ã‚Œã€æ•°å€¤ã¨ã—ã¦è©•ä¾¡ã•ã‚Œã‚‹
- æ§‹é€ ä½“å‹æƒ…å ±ï¼ˆ`is_struct`, `struct_type_name`, `struct_members`ï¼‰ãŒå¤±ã‚ã‚Œã‚‹

## å®Ÿè£…è¨ˆç”»

### Phase 1: é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹å¼ã®å‹æƒ…å ±ä¿æŒ
**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/backend/interpreter/evaluator/core/evaluator.cpp`

`evaluate_typed_expression_internal`ã«`AST_ARRAY_REF`ã®ã‚±ãƒ¼ã‚¹ã‚’è¿½åŠ :

```cpp
case ASTNodeType::AST_ARRAY_REF: {
    // é…åˆ—åã‚’å–å¾—
    std::string array_name = extract_array_base_name(node);
    Variable* array_var = interpreter_.find_variable(array_name);
    
    if (array_var && array_var->is_array) {
        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è©•ä¾¡
        int64_t index = evaluate_expression(node->array_index.get());
        
        // é…åˆ—ã®åŸºåº•å‹ã‚’ç¢ºèª
        TypeInfo base_type = array_var->array_type_info.base_type;
        
        if (base_type == TYPE_STRUCT || array_var->is_struct) {
            // æ§‹é€ ä½“é…åˆ—ã®å ´åˆã€è¦ç´ å¤‰æ•°ã‚’å–å¾—
            std::string element_name = array_name + "[" + std::to_string(index) + "]";
            Variable* element_var = interpreter_.find_variable(element_name);
            
            if (element_var && element_var->is_struct) {
                // æ§‹é€ ä½“å‹æƒ…å ±ã‚’æŒã¤TypedValueã‚’è¿”ã™
                return TypedValue(*element_var, 
                                InferredType(TYPE_STRUCT, element_var->struct_type_name));
            }
        } else if (base_type == TYPE_STRING) {
            // æ–‡å­—åˆ—é…åˆ—ã®å ´åˆ
            if (index >= 0 && index < static_cast<int64_t>(array_var->array_strings.size())) {
                return TypedValue(array_var->array_strings[index],
                                InferredType(TYPE_STRING, "string"));
            }
        }
        // ãã®ä»–ã®å‹ã¯æ•°å€¤ã¨ã—ã¦è©•ä¾¡
    }
    
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®å‡¦ç†
    int64_t numeric_result = evaluate_expression(node);
    return consume_numeric_typed_value(node, numeric_result, inferred_type);
}
```

### Phase 2: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“é…åˆ—ã®å¤‰æ•°ç™»éŒ²
**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/backend/interpreter/managers/variables/initialization.cpp`

ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“é…åˆ—ã®è¦ç´ å¤‰æ•°ã‚’æ­£ã—ãç™»éŒ²:
- `Future<int>[3]`ã®å„è¦ç´ ã«`Future<int>`å‹æƒ…å ±ã‚’ä¿æŒ
- `struct_type_name`, `is_struct`ãƒ•ãƒ©ã‚°ã‚’è¨­å®š

### Phase 3: é…åˆ—ä»£å…¥æ™‚ã®å‹æƒ…å ±ä¿æŒ
**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/backend/interpreter/executors/assignments/simple_assignment.cpp`

```cb
futures[0] = task_id(1);
```
ã®ã‚ˆã†ãªä»£å…¥ã§ã€å³è¾ºã®æ§‹é€ ä½“å‹æƒ…å ±ã‚’é…åˆ—è¦ç´ ã«æ­£ã—ãä¿å­˜ã€‚

## ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### Test 4: Futureé…åˆ—ã®é †æ¬¡await
```cb
Future<int> futures[3];
futures[0] = task_id(1);
futures[1] = task_id(2);
futures[2] = task_id(3);

int r0 = await futures[0];
int r1 = await futures[1];
int r2 = await futures[2];
```

### Test 5: Futureé…åˆ—ã®é€†é †await
```cb
Future<int> futures2[3];
futures2[0] = task_id(1);
futures2[1] = task_id(2);
futures2[2] = task_id(3);

int r2b = await futures2[2];  // æœ€é•·ã‚’å…ˆã«await
int r1b = await futures2[1];  // æ—¢ã«å®Œäº†
int r0b = await futures2[0];  // æ—¢ã«å®Œäº†
```

### Test 6: Futureå¤‰æ•°ã®å¾Œã§await
```cb
Future<int> saved_future = compute_value(7);
await sleep(20);
int saved_result = await saved_future;
```

### Test 7: awaitã›ãšã«Futureã‚’ç ´æ£„
```cb
Future<int> discarded = compute_value(9);
// awaitã›ãšã«ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ï¼ˆãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯ï¼‰
```

## é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«
- `src/backend/interpreter/evaluator/core/evaluator.cpp`
- `src/backend/interpreter/managers/variables/initialization.cpp`
- `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
- `tests/cases/async/test_future_multiple_await.cb`

## å„ªå…ˆåº¦
Medium - åŸºæœ¬çš„ãªasync/awaitæ©Ÿèƒ½ã¯å‹•ä½œã—ã¦ã„ã‚‹ãŒã€é…åˆ—ã‚’ä½¿ã£ãŸä¸¦è¡Œå‡¦ç†ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã¯å¿…é ˆ

## é–¢é€£ã™ã‚‹åˆ¶é™äº‹é …
ç¾åœ¨ã€ä»¥ä¸‹ã®æ©Ÿèƒ½ã¯æ­£å¸¸ã«å‹•ä½œ:
- âœ… åŸºæœ¬çš„ãªFutureå¤‰æ•°ï¼ˆ`Future<T> f = async_func();`ï¼‰
- âœ… intå‹Future
- âœ… stringå‹Future
- âœ… æ§‹é€ ä½“å‹Futureï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§ãªã„æ§‹é€ ä½“ï¼‰
- âœ… åŒã˜Futureã‚’è¤‡æ•°å›await
- âŒ Futureé…åˆ—ï¼ˆ`Future<T>[]`ï¼‰
- âŒ ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“ã®é…åˆ—å…¨èˆ¬
- âŒ Vector<string>ï¼ˆv0.12.0ã§ã‚»ã‚°ãƒ•ã‚©ç™ºç”Ÿã€è©³ç´°ã¯ä¸‹è¨˜å‚ç…§ï¼‰

## å‚è€ƒ
- v0.11.0ã§ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“ã®åŸºæœ¬ã‚µãƒãƒ¼ãƒˆã‚’å®Ÿè£…æ¸ˆã¿
- v0.12.0ã§async/awaitåŸºæœ¬æ©Ÿèƒ½ã‚’å®Ÿè£…æ¸ˆã¿
- ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å‹ã®é…åˆ—ã‚µãƒãƒ¼ãƒˆã¯å…¨ä½“çš„ãªæ”¹å–„ãŒå¿…è¦

---

# v0.12.0ã§ç™ºè¦‹ã•ã‚ŒãŸå•é¡Œ

## 1. Vector<T>ã®ã‚½ãƒ¼ãƒˆå®Ÿè£…ãƒã‚°ï¼ˆv0.12.0ã§ä¿®æ­£æ¸ˆã¿ï¼‰

### å•é¡Œ
`stdlib/std/vector.cb`ã®`merge_sort_internal`é–¢æ•°ã§ã€ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚‹éš›ã«`void**`ã¸ã®ã‚­ãƒ£ã‚¹ãƒˆã‚’ä½¿ç”¨ã—ã¦ã„ãŸãŸã‚ã€å‹æƒ…å ±ãŒæ­£ã—ãæ‰±ã‚ã‚Œãšã€ã‚½ãƒ¼ãƒˆãŒå¤±æ•—ã—ã¦ã„ã¾ã—ãŸã€‚

**ã‚¨ãƒ©ãƒ¼å‡ºåŠ›**:
```
=== Vector Sort Operations ===
  âŒ smaller() sorts in ascending order
  âŒ First element after smaller() (expected: 1, got: 2)
  âŒ greater() sorts in descending order
  âŒ First element after greater() (expected: 10, got: 4)
  âŒ sort() sorts in ascending order
```

### åŸå› 
```cb
// èª¤ã£ãŸå®Ÿè£…ï¼ˆv0.12.0åˆæœŸï¼‰
void** left_data_array = left_node + data_offset;
T left_data = *left_data_array;  // void**ã‹ã‚‰Tã¸ã®ä¸æ­£ãªã‚­ãƒ£ã‚¹ãƒˆ
```

ã“ã®æ–¹æ³•ã§ã¯ã€ãƒã‚¤ãƒ³ã‚¿ã®å€¤ãã®ã‚‚ã®ã‚’èª­ã¿å–ã£ã¦ã—ã¾ã„ã€å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆintå‹ã®å€¤ï¼‰ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚

### ä¿®æ­£å†…å®¹
```cb
// æ­£ã—ã„å®Ÿè£…ï¼ˆv0.12.0ã§ä¿®æ­£ï¼‰
void* left_data_ptr = left_node + data_offset;
T left_data = array_get(left_data_ptr, 0);  // array_get<T>()ã§å‹å®‰å…¨ã«å–å¾—
```

**ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«**: `stdlib/std/vector.cb` (line 549-556)

**ä¿®æ­£ã‚³ãƒŸãƒƒãƒˆ**: v0.12.0é–‹ç™ºä¸­

### ãƒ†ã‚¹ãƒˆçµæœ
ä¿®æ­£å¾Œã€å…¨ã¦ã®ã‚½ãƒ¼ãƒˆãƒ†ã‚¹ãƒˆãŒåˆæ ¼:
```
=== Vector Sort Operations ===
  âœ… smaller() sorts in ascending order
  âœ… First element after smaller()
  âœ… greater() sorts in descending order
  âœ… First element after greater()
  âœ… sort() sorts in ascending order
  âœ… Vector: 11 tests passed
```

### æ•™è¨“
ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†éš›ã¯ã€å¸¸ã«`array_get<T>()`ã‚„`array_set<T>()`ã‚’ä½¿ç”¨ã—ã€ç›´æ¥ãƒã‚¤ãƒ³ã‚¿ã‚­ãƒ£ã‚¹ãƒˆã‚’é¿ã‘ã‚‹ã¹ãã§ã™ã€‚

---

## 2. Vector<string>ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚©ãƒ«ãƒˆï¼ˆæœªä¿®æ­£ï¼‰

### å•é¡Œ
`Vector<string>`ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚©ãƒ«ãƒˆãŒç™ºç”Ÿã—ã¾ã™ã€‚

**å†ç¾ã‚³ãƒ¼ãƒ‰**:
```cb
import stdlib.std.vector;

void test_vector_string() {
    Vector<string> vec;
    vec.push_back("Hello");
    vec.push_back("World");
    vec.push_back("Cb");
    vec.push_back("Language");
    
    println("String vector contents:");
    long i = 0;
    while (i < vec.get_length()) {
        string str = vec.at(i);  // â† ã“ã“ã§ã‚»ã‚°ãƒ•ã‚©
        println("  [{i}] = {str}");
        i = i + 1;
    }
}

void main() {
    test_vector_string();
}
```

**ã‚¨ãƒ©ãƒ¼**:
```
\n=== Vector<string> Demo ===
String vector contents:
zsh: segmentation fault  ./main sample/stdlib/vector_demo.cb
```

### åŸå› åˆ†æï¼ˆæ¨æ¸¬ï¼‰

Vector<T>ã¯åŒæ–¹å‘ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€å„ãƒãƒ¼ãƒ‰ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:

```
[prev (sizeof(void*))][next (sizeof(void*))][data (sizeof(T))]
```

å•é¡Œã¯ã€`string`å‹ã®ã‚µã‚¤ã‚ºã¨å®Ÿéš›ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã«ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¾ã™:

1. **æ–‡å­—åˆ—ã®ãƒ¡ãƒ¢ãƒªç®¡ç†**: Cbã®`string`å‹ã¯å†…éƒ¨çš„ã«ãƒã‚¤ãƒ³ã‚¿ã¨é•·ã•ã‚’æŒã¤æ§‹é€ ä½“ã§ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€å˜ç´”ãª`sizeof(T)`ã§ã¯æ­£ç¢ºãªã‚µã‚¤ã‚ºãŒå–å¾—ã§ããªã„
2. **array_get/array_setã®åˆ¶é™**: `array_get<string>()`ã‚„`array_set<string>()`ãŒæ–‡å­—åˆ—ã®æ·±ã„ã‚³ãƒ”ãƒ¼ã‚’æ­£ã—ãå‡¦ç†ã—ã¦ã„ãªã„å¯èƒ½æ€§
3. **ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å•é¡Œ**: ãƒãƒ¼ãƒ‰ã‚’`free()`ã™ã‚‹éš›ã€æ–‡å­—åˆ—ã®ãƒ¡ãƒ¢ãƒªã‚‚é©åˆ‡ã«è§£æ”¾ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§

### å›é¿ç­–
ç¾åœ¨ã¯ã€`Vector<int>`ã€`Vector<Point>`ï¼ˆæ§‹é€ ä½“ï¼‰ãªã©ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã‚„å˜ç´”ãªæ§‹é€ ä½“ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™ã€‚

**å‹•ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰**:
```cb
// âœ… å‹•ä½œã™ã‚‹
Vector<int> vec;
vec.push_back(10);
vec.push_back(20);
int val = vec.at(0);  // OK

// âœ… å‹•ä½œã™ã‚‹
struct Point {
    int x;
    int y;
}

Vector<Point> vec2;
Point p;
p.x = 10;
p.y = 20;
vec2.push_back(p);
Point retrieved = vec2.at(0);  // OK

// âŒ ã‚»ã‚°ãƒ•ã‚©
Vector<string> vec3;
vec3.push_back("Hello");  // ã¾ãŸã¯at()ã§ã‚¯ãƒ©ãƒƒã‚·ãƒ¥
```

### v0.13.0ã§ã®ä¿®æ­£è¨ˆç”»

**Phase 1: æ–‡å­—åˆ—å‹ã®ãƒ¡ãƒ¢ãƒªç®¡ç†èª¿æŸ»**
- Cbã®`string`å‹ã®å†…éƒ¨å®Ÿè£…ã‚’ç¢ºèª
- `sizeof(string)`ãŒè¿”ã™å€¤ã¨ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®æ¤œè¨¼
- æ–‡å­—åˆ—ã®ã‚³ãƒ”ãƒ¼ã¨è§£æ”¾ã®æ­£ã—ã„æ–¹æ³•ã‚’ç‰¹å®š

**Phase 2: array_get/array_setã®æ‹¡å¼µ**
- æ–‡å­—åˆ—å‹ã«å¯¾ã™ã‚‹ç‰¹åˆ¥ãªå‡¦ç†ã‚’è¿½åŠ 
- æ·±ã„ã‚³ãƒ”ãƒ¼ï¼ˆãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã®è¤‡è£½ï¼‰ã®ã‚µãƒãƒ¼ãƒˆ
- æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ã®è¿½è·¡ã¨ç®¡ç†

**Phase 3: Vectorãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ä¿®æ­£**
```cb
// ç¾åœ¨ã®å®Ÿè£…
~self() {
    int ptr_size = sizeof(void*);
    void* current = self.front;
    while (current != nullptr) {
        void** next_ptr = current + ptr_size;
        void* next_node = *next_ptr;
        free(current);  // â† ãƒãƒ¼ãƒ‰ã®ãƒ¡ãƒ¢ãƒªã®ã¿è§£æ”¾
        current = next_node;
    }
}

// ä¿®æ­£æ¡ˆ: ãƒ‡ãƒ¼ã‚¿å‹ã«å¿œã˜ãŸè§£æ”¾
~self() {
    int ptr_size = sizeof(void*);
    void* current = self.front;
    while (current != nullptr) {
        // ãƒ‡ãƒ¼ã‚¿éƒ¨åˆ†ã‚’å–å¾—
        void* data_ptr = current + ptr_size + ptr_size;
        
        // stringå‹ã®å ´åˆã¯æ–‡å­—åˆ—ãƒ¡ãƒ¢ãƒªã‚‚è§£æ”¾
        if (is_string_type<T>()) {
            free_string_memory(data_ptr);
        }
        
        void** next_ptr = current + ptr_size;
        void* next_node = *next_ptr;
        free(current);
        current = next_node;
    }
}
```

**Phase 4: ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®è¿½åŠ **
```cb
// Test 1: Vector<string>ã®åŸºæœ¬æ“ä½œ
void test_vector_string_basic() {
    Vector<string> vec;
    vec.push_back("Hello");
    vec.push_back("World");
    
    assert(vec.get_length() == 2);
    assert(vec.at(0) == "Hello");
    assert(vec.at(1) == "World");
}

// Test 2: Vector<string>ã®ã‚½ãƒ¼ãƒˆ
void test_vector_string_sort() {
    Vector<string> vec;
    vec.push_back("Zebra");
    vec.push_back("Apple");
    vec.push_back("Banana");
    
    vec.smaller();  // è¾æ›¸é †ã‚½ãƒ¼ãƒˆ
    
    assert(vec.at(0) == "Apple");
    assert(vec.at(1) == "Banana");
    assert(vec.at(2) == "Zebra");
}

// Test 3: Vector<string>ã®ãƒ¡ãƒ¢ãƒªç®¡ç†
void test_vector_string_memory() {
    {
        Vector<string> vec;
        vec.push_back("Test1");
        vec.push_back("Test2");
        vec.push_back("Test3");
        // ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹â†’ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
    }
    // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒãªã„ã“ã¨ã‚’ç¢ºèªï¼ˆvalgrindç­‰ã§ï¼‰
}
```

### å„ªå…ˆåº¦
**High** - Vector<T>ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä¸­æ ¸æ©Ÿèƒ½ã§ã‚ã‚Šã€stringå‹ã®ã‚µãƒãƒ¼ãƒˆã¯å¿…é ˆ

### é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«
- `stdlib/std/vector.cb` - Vectorå®Ÿè£…
- `src/backend/interpreter/core/builtin_types.cpp` - stringå‹ã®å†…éƒ¨å®Ÿè£…
- `src/backend/interpreter/evaluator/functions/call_impl.cpp` - array_get/array_setã®å®Ÿè£…
- `sample/stdlib/vector_demo.cb` - ãƒ‡ãƒ¢ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆtest_vector_string()ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆä¸­ï¼‰

### æš«å®šå¯¾å¿œ
`sample/stdlib/vector_demo.cb`ã§ã¯ã€`test_vector_string()`ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã€TODOã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ :

```cb
test_vector_basic();
test_vector_push_front();
test_vector_sort();
test_vector_find();
test_vector_delete_at();
// TODO: Fix Vector<string> - currently causes segfault
// test_vector_string();
test_vector_struct();
test_vector_clear();
```

---

## 3. ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®çµ‚äº†ã‚³ãƒ¼ãƒ‰å¯¾å¿œï¼ˆv0.12.0ã§ä¿®æ­£æ¸ˆã¿ï¼‰

### å•é¡Œ
ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¦ã‚‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã‚³ãƒ¼ãƒ‰0ï¼ˆæ­£å¸¸çµ‚äº†ï¼‰ã§çµ‚äº†ã—ã¦ã„ãŸãŸã‚ã€CIã§ãƒ†ã‚¹ãƒˆã®æˆå¦ã‚’æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚

**å•é¡Œã®ã‚³ãƒ¼ãƒ‰**:
```cb
void main() {
    // ... ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ ...
    
    if (total_failed == 0) {
        println("âœ… All tests passed!");
    } else {
        println("âŒ Some tests failed");
        // â† ã“ã“ã§çµ‚äº†ã‚³ãƒ¼ãƒ‰ãŒ0ã®ã¾ã¾çµ‚äº†
    }
}
```

### ä¿®æ­£å†…å®¹

**1. TestResultã«get_exit_code()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ **

`stdlib/std/test.cb`ã«çµ‚äº†ã‚³ãƒ¼ãƒ‰å–å¾—æ©Ÿèƒ½ã‚’è¿½åŠ :

```cb
export interface TestFramework {
    void assert_true(bool condition, string message);
    void assert_false(bool condition, string message);
    void assert_eq_int(int actual, int expected, string message);
    void assert_eq_long(long actual, long expected, string message);
    void assert_eq_bool(bool actual, bool expected, string message);
    void assert_eq_str(string actual, string expected, string message);
    TestResult get_result();
    void print_summary();
    void reset();
    int get_exit_code();  // â† è¿½åŠ 
};

impl TestFramework for TestResult {
    // ... æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ ...
    
    int get_exit_code() {
        if (self.failed == 0) {
            return 0;
        } else {
            return 1;
        }
    }
};
```

**2. ãƒ†ã‚¹ãƒˆå¤±æ•—æ™‚ã«assertã‚’ä½¿ç”¨**

`tests/cases/stdlib/test_stdlib_all.cb`ã§ãƒ†ã‚¹ãƒˆå¤±æ•—ã‚’é€šçŸ¥:

```cb
void main() {
    // ... ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ ...
    
    if (total_failed == 0) {
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println("â•‘  ğŸ‰ All Standard Library Tests Passed!                   â•‘");
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    } else {
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println("â•‘  âš ï¸  Some Tests Failed - Review Output Above             â•‘");
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // assertã§ãƒ†ã‚¹ãƒˆå¤±æ•—ã‚’é€šçŸ¥ã—ã€éã‚¼ãƒ­çµ‚äº†ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™
        assert(total_failed == 0);  // â† è¿½åŠ 
    }
}
```

**assertã®å‹•ä½œ**: `src/backend/interpreter/handlers/control/assertion.cpp`

```cpp
void AssertionHandler::handle_assertion(const ASTNode *node) {
    // æ¡ä»¶ã‚’è©•ä¾¡
    int64_t condition = interpreter_->evaluate(node->left.get());

    if (condition) {
        // æˆåŠŸ
    } else {
        // å¤±æ•—
        error_msg(DebugMsgId::ASSERT_FAILURE, node->location.line,
                  "Assertion failed");
        std::cerr << "Assertion failed at line " << node->location.line
                  << std::endl;
        std::exit(1);  // â† çµ‚äº†ã‚³ãƒ¼ãƒ‰1ã§çµ‚äº†
    }
}
```

### ãƒ†ã‚¹ãƒˆçµæœ

**æˆåŠŸæ™‚**:
```bash
$ ./main tests/cases/stdlib/test_stdlib_all.cb
... ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ ...
âœ… All Standard Library Tests Passed!
$ echo $?
0  # æ­£å¸¸çµ‚äº†
```

**å¤±æ•—æ™‚**:
```bash
$ ./main test_failure_check.cb
Testing assert behavior on failure...
Total failed: 5
âŒ Some tests failed
Calling assert(false) to exit with code 1...
[ASSERT_ERROR] Assertion failed at line 17: Assertion failed
Assertion failed at line 17
$ echo $?
1  # ç•°å¸¸çµ‚äº†
```

### ãƒ¡ãƒªãƒƒãƒˆ
- âœ… CIã§ãƒ†ã‚¹ãƒˆã®æˆå¦ã‚’æ­£ã—ãæ¤œå‡º
- âœ… Makefileã®ãƒ†ã‚¹ãƒˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§å¤±æ•—ã‚’æ¤œçŸ¥
- âœ… æ˜ç¤ºçš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- âœ… assertæ–‡ã®æ—¢å­˜æ©Ÿèƒ½ã‚’æ´»ç”¨ï¼ˆæ–°è¦å®Ÿè£…ä¸è¦ï¼‰

### ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«
- `stdlib/std/test.cb` - TestFrameworkã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨get_exit_code()å®Ÿè£…
- `tests/cases/stdlib/test_stdlib_all.cb` - assert()ã«ã‚ˆã‚‹ãƒ†ã‚¹ãƒˆå¤±æ•—é€šçŸ¥

### é–¢é€£ã‚³ãƒŸãƒƒãƒˆ
v0.12.0é–‹ç™ºä¸­ã«ä¿®æ­£æ¸ˆã¿

---

---

# è¿½åŠ æ©Ÿèƒ½: async/awaitã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆResultå‹çµ±åˆï¼‰

## æ¦‚è¦

v0.13.0ã§ã¯ã€async/awaitæ©Ÿèƒ½ã«Result<T, E>å‹ã‚’çµ±åˆã—ã€Rusté¢¨ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å®Ÿç¾ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€éåŒæœŸå‡¦ç†ã§ã®ã‚¨ãƒ©ãƒ¼ã‚’å‹å®‰å…¨ã«æ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

## ç¾çŠ¶

v0.12.0ã§ã¯ä»¥ä¸‹ãŒå®Ÿè£…æ¸ˆã¿:
- âœ… async/awaitæ§‹æ–‡ã®å®Œå…¨å®Ÿè£…
- âœ… Future<T>ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹åŒ–
- âœ… éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°sleep
- âœ… yieldæ©Ÿèƒ½
- âœ… SimpleEventLoop

v0.11.0ã§ã¯ä»¥ä¸‹ãŒå®Ÿè£…æ¸ˆã¿:
- âœ… Result<T, E>å‹ï¼ˆãƒ“ãƒ«ãƒˆã‚¤ãƒ³ï¼‰
- âœ… Option<T>å‹ï¼ˆãƒ“ãƒ«ãƒˆã‚¤ãƒ³ï¼‰
- âœ… matchæ–‡ã«ã‚ˆã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
- âœ… Enum with Associated Values

## æœªå®Ÿè£…ã®æ©Ÿèƒ½

### 1. asyncé–¢æ•°ã§ã®Resultå‹æˆ»ã‚Šå€¤

**ç›®çš„**: éåŒæœŸå‡¦ç†ã®ã‚¨ãƒ©ãƒ¼ã‚’å‹å®‰å…¨ã«æ‰±ã†

**æ§‹æ–‡**:
```cb
async Result<int, NetworkError> fetch_data(string url) {
    if (url == "") {
        NetworkError err;
        err.message = "URL cannot be empty";
        err.status_code = 400;
        return Err(err);
    }
    
    await sleep(100);
    
    string response = await http_get(url);
    
    if (response == "") {
        NetworkError err;
        err.message = "Empty response";
        err.status_code = 500;
        return Err(err);
    }
    
    int value = parse_int(response);
    return Ok(value);
}
```

**ä½¿ç”¨ä¾‹**:
```cb
void main() {
    Result<int, NetworkError> result = await fetch_data("https://api.example.com");
    
    match (result) {
        Ok(value) => {
            println("Success: {value}");
        },
        Err(error) => {
            println("Error: {error.message}");
            println("Status: {error.status_code}");
        }
    }
}
```

### 2. ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆã‚¨ãƒ©ãƒ¼ä¼æ’­ï¼‰

**ç›®çš„**: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å‰Šæ¸›

**æ§‹æ–‡**:
```cb
async Result<int, Error> process_data(string url) {
    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã€è‡ªå‹•çš„ã«è¿”ã™
    int data = await fetch_data(url)?;  // Errã®å ´åˆã¯ã“ã“ã§å³return
    
    int processed = data * 2;
    return Ok(processed);
}

// è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
async Result<int, Error> complex_operation() {
    int data1 = await fetch_data("url1")?;
    int data2 = await fetch_data("url2")?;
    int data3 = await fetch_data("url3")?;
    
    return Ok(data1 + data2 + data3);
}
```

**å±•é–‹å¾Œã®å‹•ä½œ**:
```cb
// ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å±•é–‹ã•ã‚Œã‚‹
int data = await fetch_data(url)?;

// â†“ å±•é–‹

Result<int, Error> temp_result = await fetch_data(url);
match (temp_result) {
    Ok(value) => {
        int data = value;  // æˆåŠŸæ™‚ã¯å€¤ã‚’å–å¾—
    },
    Err(e) => {
        return Err(e);  // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å³åº§ã«return
    }
}
```

### 3. Future<Result<T, E>>ã®çµ„ã¿åˆã‚ã›

**å†…éƒ¨è¡¨ç¾**:
```cb
// asyncé–¢æ•°ãŒResult<T, E>ã‚’è¿”ã™å ´åˆã€å†…éƒ¨çš„ã«ã¯Future<Result<T, E>>
async Result<int, Error> fetch() {
    // ...
}

// â†“ å†…éƒ¨çš„ã«ã¯

Future<Result<int, Error>> fetch() {
    // ...
}
```

**ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³**:
```cb
// ãƒ‘ã‚¿ãƒ¼ãƒ³1: ç›´æ¥await + match
Result<int, Error> result = await fetch();
match (result) {
    Ok(value) => println("{value}"),
    Err(e) => println("{e.message}")
}

// ãƒ‘ã‚¿ãƒ¼ãƒ³2: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ç°¡æ½”ã«
async Result<int, Error> caller() {
    int value = await fetch()?;  // ã‚¨ãƒ©ãƒ¼ã¯è‡ªå‹•ä¼æ’­
    return Ok(value * 2);
}
```

## å®Ÿè£…è¨ˆç”»

### Phase 1: asyncé–¢æ•°ã®Resultå‹æˆ»ã‚Šå€¤ã‚µãƒãƒ¼ãƒˆï¼ˆ2é€±é–“ï¼‰

**ã‚¿ã‚¹ã‚¯**:
1. ãƒ‘ãƒ¼ã‚µãƒ¼æ‹¡å¼µ
   - [ ] `async Result<T, E> func()` ã®æ§‹æ–‡è§£æ
   - [ ] æˆ»ã‚Šå€¤å‹ãŒ`Result<T, E>`ã®å ´åˆã®ç‰¹åˆ¥å‡¦ç†

2. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼æ‹¡å¼µ
   - [ ] asyncé–¢æ•°å†…ã§`return Ok(value)`ã®å‡¦ç†
   - [ ] asyncé–¢æ•°å†…ã§`return Err(error)`ã®å‡¦ç†
   - [ ] Future<Result<T, E>>ã®å†…éƒ¨ç®¡ç†

3. ãƒ†ã‚¹ãƒˆ
   - [ ] åŸºæœ¬çš„ãªResultå‹ã‚’è¿”ã™asyncé–¢æ•°
   - [ ] matchæ–‡ã¨ã®çµ±åˆ
   - [ ] è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼å‹

**é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«**:
- `src/frontend/parser/recursive_parser.cpp`
- `src/backend/interpreter/executors/functions/async_executor.cpp`
- `src/backend/interpreter/types/future_manager.cpp`

### Phase 2: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼å®Ÿè£…ï¼ˆ2é€±é–“ï¼‰

**ã‚¿ã‚¹ã‚¯**:
1. ãƒ‘ãƒ¼ã‚µãƒ¼æ‹¡å¼µ
   - [ ] `expr?` ã®å¾Œç½®æ¼”ç®—å­ã¨ã—ã¦ã®èªè­˜
   - [ ] awaitå¼ã¨ã®çµ„ã¿åˆã‚ã›ï¼ˆ`await expr?`ï¼‰

2. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼æ‹¡å¼µ
   - [ ] Result<T, E>å‹ã®ãƒã‚§ãƒƒã‚¯
   - [ ] Errã®å ´åˆã®æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
   - [ ] Okã®å ´åˆã®å€¤ã®æŠ½å‡º
   - [ ] é–¢æ•°ã®æˆ»ã‚Šå€¤å‹æ¤œè¨¼

3. ã‚¨ãƒ©ãƒ¼å‡¦ç†
   - [ ] å‹ä¸ä¸€è‡´ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   - [ ] æˆ»ã‚Šå€¤å‹ãŒResult<T, E>ã§ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼

4. ãƒ†ã‚¹ãƒˆ
   - [ ] åŸºæœ¬çš„ãª?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼
   - [ ] ãƒã‚¹ãƒˆã—ãŸ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼
   - [ ] awaitå¼ã¨ã®çµ„ã¿åˆã‚ã›
   - [ ] ã‚¨ãƒ©ãƒ¼ä¼æ’­ã®ãƒã‚§ãƒ¼ãƒ³

**é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«**:
- `src/frontend/parser/recursive_parser.cpp`
- `src/backend/interpreter/evaluator/operators/binary_unary.cpp`
- `src/backend/interpreter/executors/control_flow_executor.cpp`

### Phase 3: Resultå‹ãƒ¡ã‚½ãƒƒãƒ‰ã®æ‹¡å¼µï¼ˆ1é€±é–“ï¼‰

**ã‚¿ã‚¹ã‚¯**:
1. unwrapç³»ãƒ¡ã‚½ãƒƒãƒ‰
   - [ ] `unwrap()` - ãƒ‘ãƒ‹ãƒƒã‚¯
   - [ ] `expect(message)` - ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä»˜ããƒ‘ãƒ‹ãƒƒã‚¯
   - [ ] `unwrap_or(default)` - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
   - [ ] `unwrap_or_else(func)` - é…å»¶è©•ä¾¡

2. å¤‰æ›ãƒ¡ã‚½ãƒƒãƒ‰
   - [ ] `map(func)` - Okå€¤ã®å¤‰æ›
   - [ ] `and_then(func)` - Resultå‹ã‚’è¿”ã™é–¢æ•°ã®ãƒã‚§ãƒ¼ãƒ³
   - [ ] `or_else(func)` - Erræ™‚ã®ä»£æ›¿å‡¦ç†

3. åˆ¤å®šãƒ¡ã‚½ãƒƒãƒ‰
   - [ ] `is_ok()` - æˆåŠŸã‹ã©ã†ã‹
   - [ ] `is_err()` - ã‚¨ãƒ©ãƒ¼ã‹ã©ã†ã‹

**é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«**:
- `src/backend/interpreter/types/result_methods.cpp`
- `src/backend/interpreter/evaluator/member_access.cpp`

### Phase 4: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ãƒ†ã‚¹ãƒˆï¼ˆ1é€±é–“ï¼‰

**ã‚¿ã‚¹ã‚¯**:
1. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ
   - [ ] async/awaitã¨Resultå‹ã®çµ±åˆã‚¬ã‚¤ãƒ‰
   - [ ] ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ä½¿ç”¨ä¾‹
   - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

2. åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆ
   - [ ] å®Ÿç”¨çš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹
   - [ ] ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã®ã‚«ãƒãƒ¬ãƒƒã‚¸
   - [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

## ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### Test 1: åŸºæœ¬çš„ãªResultå‹ã‚’è¿”ã™asyncé–¢æ•°
```cb
struct NetworkError {
    string message;
    int status_code;
}

async Result<int, NetworkError> fetch_value(int x) {
    if (x < 0) {
        NetworkError err;
        err.message = "Negative value";
        err.status_code = 400;
        return Err(err);
    }
    
    await sleep(100);
    return Ok(x * 2);
}

void main() {
    Result<int, NetworkError> r1 = await fetch_value(5);
    match (r1) {
        Ok(v) => println("Success: {v}"),  // 10
        Err(e) => println("Error: {e.message}")
    }
    
    Result<int, NetworkError> r2 = await fetch_value(-1);
    match (r2) {
        Ok(v) => println("Success: {v}"),
        Err(e) => println("Error: {e.message}")  // "Negative value"
    }
}
```

### Test 2: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ä¼æ’­
```cb
async Result<int, NetworkError> process(int x) {
    int value = await fetch_value(x)?;  // ã‚¨ãƒ©ãƒ¼ã¯è‡ªå‹•ä¼æ’­
    return Ok(value + 10);
}

void main() {
    Result<int, NetworkError> r1 = await process(5);
    println("Result 1: {r1}");  // Ok(20)
    
    Result<int, NetworkError> r2 = await process(-1);
    println("Result 2: {r2}");  // Err(NetworkError{...})
}
```

### Test 3: è¤‡æ•°ã®asyncå‘¼ã³å‡ºã—ã¨?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼
```cb
async Result<int, NetworkError> complex_operation() {
    int a = await fetch_value(3)?;
    int b = await fetch_value(5)?;
    int c = await fetch_value(7)?;
    
    return Ok(a + b + c);
}

void main() {
    Result<int, NetworkError> result = await complex_operation();
    match (result) {
        Ok(sum) => println("Sum: {sum}"),  // 30
        Err(e) => println("Error: {e.message}")
    }
}
```

### Test 4: unwrap_orã«ã‚ˆã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
```cb
async Result<int, NetworkError> maybe_fetch(int x) {
    if (x == 0) {
        NetworkError err;
        err.message = "Zero not allowed";
        err.status_code = 400;
        return Err(err);
    }
    return Ok(x * 10);
}

void main() {
    Result<int, NetworkError> r1 = await maybe_fetch(5);
    int value1 = r1.unwrap_or(999);  // 50
    
    Result<int, NetworkError> r2 = await maybe_fetch(0);
    int value2 = r2.unwrap_or(999);  // 999 (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)
    
    println("Value1: {value1}, Value2: {value2}");
}
```

## æŠ€è¡“è©³ç´°

### Resultå‹ã®ãƒ¡ãƒ¢ãƒªç®¡ç†

**æ§‹é€ **:
```cpp
struct ResultValue {
    enum class Variant { OK, ERR } variant;
    Variable ok_value;   // Ok(T)ã®å€¤
    Variable err_value;  // Err(E)ã®å€¤
};
```

### ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ

**å…¥åŠ›**:
```cb
int data = await fetch_data(url)?;
```

**ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆæ¦‚å¿µï¼‰**:
```cpp
// 1. awaitå¼ã‚’è©•ä¾¡
auto temp_future = fetch_data(url);
auto temp_result = await_expression(temp_future);

// 2. Resultå‹ã®ãƒã‚§ãƒƒã‚¯
if (temp_result.variant == ERR) {
    // ç¾åœ¨ã®é–¢æ•°ã®æˆ»ã‚Šå€¤å‹ã‚‚Result<T, E>ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
    return create_err(temp_result.err_value);
}

// 3. Okå€¤ã‚’å–ã‚Šå‡ºã™
int data = temp_result.ok_value;
```

## å„ªå…ˆåº¦

**High** - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯éåŒæœŸå‡¦ç†ã®å®Ÿç”¨æ€§ã«ä¸å¯æ¬ 

## ä¾å­˜é–¢ä¿‚

- âœ… Result<T, E>å‹ï¼ˆv0.11.0ã§å®Ÿè£…æ¸ˆã¿ï¼‰
- âœ… matchæ–‡ï¼ˆv0.11.0ã§å®Ÿè£…æ¸ˆã¿ï¼‰
- âœ… async/awaitæ§‹æ–‡ï¼ˆv0.12.0ã§å®Ÿè£…æ¸ˆã¿ï¼‰
- âœ… Future<T>å‹ï¼ˆv0.12.0ã§å®Ÿè£…æ¸ˆã¿ï¼‰

## æœŸå¾…ã•ã‚Œã‚‹åˆ©ç‚¹

1. **å‹å®‰å…¨æ€§**: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¼ã‚Œã‚’æ¤œå‡º
2. **æ˜ç¤ºæ€§**: ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¹ãŒæ˜ç¢º
3. **ç°¡æ½”æ€§**: ?ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã‚‹ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆå‰Šæ¸›
4. **ä¸€è²«æ€§**: Rusté¢¨ã®æ…£ç”¨çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³
5. **çµ„ã¿åˆã‚ã›å¯èƒ½**: Future<T>ã¨Result<T, E>ã®è‡ªç„¶ãªçµ±åˆ

## å‚è€ƒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- `docs/archive/todo/v0.12.0_async_await/v0.12.0_async_await_design.md` - Resultå‹ã¨ã®çµ±åˆè¨­è¨ˆ
- `docs/archive/features/v0.11.0_implemented/pattern_matching.md` - matchæ–‡ã®å®Ÿè£…
- `docs/archive/features/v0.11.0_implemented/builtin_types_option_result.md` - Resultå‹ã®åŸºæœ¬å®Ÿè£…
