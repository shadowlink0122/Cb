# v0.13.0: Generic Array Support

## 概要
ジェネリクス構造体の配列サポートを実装する。現在、`Future<T>`のような型は配列として宣言できるが、配列要素へのアクセス時に型情報が失われる問題がある。

## 現状の問題

### 1. ジェネリクス構造体配列の型情報喪失
```cb
Future<int> futures[3];
futures[0] = task_id(1);
int r0 = await futures[0];  // エラー: await expression requires Future<T> operand
```

**問題**: 配列アクセス式（`futures[0]`）を評価する際、要素が構造体型であることが認識されない。

### 2. 根本原因
- `evaluate_typed_expression_internal`関数で`AST_ARRAY_REF`の明示的な処理がない
- デフォルトケースで`evaluate_expression`が呼ばれ、数値として評価される
- 構造体型情報（`is_struct`, `struct_type_name`, `struct_members`）が失われる

## 実装計画

### Phase 1: 配列アクセス式の型情報保持
**ファイル**: `src/backend/interpreter/evaluator/core/evaluator.cpp`

`evaluate_typed_expression_internal`に`AST_ARRAY_REF`のケースを追加:

```cpp
case ASTNodeType::AST_ARRAY_REF: {
    // 配列名を取得
    std::string array_name = extract_array_base_name(node);
    Variable* array_var = interpreter_.find_variable(array_name);
    
    if (array_var && array_var->is_array) {
        // インデックスを評価
        int64_t index = evaluate_expression(node->array_index.get());
        
        // 配列の基底型を確認
        TypeInfo base_type = array_var->array_type_info.base_type;
        
        if (base_type == TYPE_STRUCT || array_var->is_struct) {
            // 構造体配列の場合、要素変数を取得
            std::string element_name = array_name + "[" + std::to_string(index) + "]";
            Variable* element_var = interpreter_.find_variable(element_name);
            
            if (element_var && element_var->is_struct) {
                // 構造体型情報を持つTypedValueを返す
                return TypedValue(*element_var, 
                                InferredType(TYPE_STRUCT, element_var->struct_type_name));
            }
        } else if (base_type == TYPE_STRING) {
            // 文字列配列の場合
            if (index >= 0 && index < static_cast<int64_t>(array_var->array_strings.size())) {
                return TypedValue(array_var->array_strings[index],
                                InferredType(TYPE_STRING, "string"));
            }
        }
        // その他の型は数値として評価
    }
    
    // フォールバック: 従来の処理
    int64_t numeric_result = evaluate_expression(node);
    return consume_numeric_typed_value(node, numeric_result, inferred_type);
}
```

### Phase 2: ジェネリクス構造体配列の変数登録
**ファイル**: `src/backend/interpreter/managers/variables/initialization.cpp`

ジェネリクス構造体配列の要素変数を正しく登録:
- `Future<int>[3]`の各要素に`Future<int>`型情報を保持
- `struct_type_name`, `is_struct`フラグを設定

### Phase 3: 配列代入時の型情報保持
**ファイル**: `src/backend/interpreter/executors/assignments/simple_assignment.cpp`

```cb
futures[0] = task_id(1);
```
のような代入で、右辺の構造体型情報を配列要素に正しく保存。

## テストケース

### Test 4: Future配列の順次await
```cb
Future<int> futures[3];
futures[0] = task_id(1);
futures[1] = task_id(2);
futures[2] = task_id(3);

int r0 = await futures[0];
int r1 = await futures[1];
int r2 = await futures[2];
```

### Test 5: Future配列の逆順await
```cb
Future<int> futures2[3];
futures2[0] = task_id(1);
futures2[1] = task_id(2);
futures2[2] = task_id(3);

int r2b = await futures2[2];  // 最長を先にawait
int r1b = await futures2[1];  // 既に完了
int r0b = await futures2[0];  // 既に完了
```

### Test 6: Future変数の後でawait
```cb
Future<int> saved_future = compute_value(7);
await sleep(20);
int saved_result = await saved_future;
```

### Test 7: awaitせずにFutureを破棄
```cb
Future<int> discarded = compute_value(9);
// awaitせずにスコープを抜ける（メモリリークチェック）
```

## 関連ファイル
- `src/backend/interpreter/evaluator/core/evaluator.cpp`
- `src/backend/interpreter/managers/variables/initialization.cpp`
- `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
- `tests/cases/async/test_future_multiple_await.cb`

## 優先度
Medium - 基本的なasync/await機能は動作しているが、配列を使った並行処理パターンには必須

## 関連する制限事項
現在、以下の機能は正常に動作:
- ✅ 基本的なFuture変数（`Future<T> f = async_func();`）
- ✅ int型Future
- ✅ string型Future
- ✅ 構造体型Future（ジェネリクスでない構造体）
- ✅ 同じFutureを複数回await
- ❌ Future配列（`Future<T>[]`）
- ❌ ジェネリクス構造体の配列全般

## 参考
- v0.11.0でジェネリクス構造体の基本サポートを実装済み
- v0.12.0でasync/await基本機能を実装済み
- ジェネリクス型の配列サポートは全体的な改善が必要
