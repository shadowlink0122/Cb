# v0.13.0: Generic Array Support

## 概要
ジェネリクス構造体の配列サポートを実装する。現在、`Future<T>`のような型は配列として宣言できるが、配列要素へのアクセス時に型情報が失われる問題がある。

## 現状の問題

### 1. ジェネリクス構造体配列の型情報喪失
```cb
Future<int> futures[3];
futures[0] = task_id(1);
int r0 = await futures[0];  // エラー: await expression requires Future<T> operand
```

**問題**: 配列アクセス式（`futures[0]`）を評価する際、要素が構造体型であることが認識されない。

### 2. 根本原因
- `evaluate_typed_expression_internal`関数で`AST_ARRAY_REF`の明示的な処理がない
- デフォルトケースで`evaluate_expression`が呼ばれ、数値として評価される
- 構造体型情報（`is_struct`, `struct_type_name`, `struct_members`）が失われる

## 実装計画

### Phase 1: 配列アクセス式の型情報保持
**ファイル**: `src/backend/interpreter/evaluator/core/evaluator.cpp`

`evaluate_typed_expression_internal`に`AST_ARRAY_REF`のケースを追加:

```cpp
case ASTNodeType::AST_ARRAY_REF: {
    // 配列名を取得
    std::string array_name = extract_array_base_name(node);
    Variable* array_var = interpreter_.find_variable(array_name);
    
    if (array_var && array_var->is_array) {
        // インデックスを評価
        int64_t index = evaluate_expression(node->array_index.get());
        
        // 配列の基底型を確認
        TypeInfo base_type = array_var->array_type_info.base_type;
        
        if (base_type == TYPE_STRUCT || array_var->is_struct) {
            // 構造体配列の場合、要素変数を取得
            std::string element_name = array_name + "[" + std::to_string(index) + "]";
            Variable* element_var = interpreter_.find_variable(element_name);
            
            if (element_var && element_var->is_struct) {
                // 構造体型情報を持つTypedValueを返す
                return TypedValue(*element_var, 
                                InferredType(TYPE_STRUCT, element_var->struct_type_name));
            }
        } else if (base_type == TYPE_STRING) {
            // 文字列配列の場合
            if (index >= 0 && index < static_cast<int64_t>(array_var->array_strings.size())) {
                return TypedValue(array_var->array_strings[index],
                                InferredType(TYPE_STRING, "string"));
            }
        }
        // その他の型は数値として評価
    }
    
    // フォールバック: 従来の処理
    int64_t numeric_result = evaluate_expression(node);
    return consume_numeric_typed_value(node, numeric_result, inferred_type);
}
```

### Phase 2: ジェネリクス構造体配列の変数登録
**ファイル**: `src/backend/interpreter/managers/variables/initialization.cpp`

ジェネリクス構造体配列の要素変数を正しく登録:
- `Future<int>[3]`の各要素に`Future<int>`型情報を保持
- `struct_type_name`, `is_struct`フラグを設定

### Phase 3: 配列代入時の型情報保持
**ファイル**: `src/backend/interpreter/executors/assignments/simple_assignment.cpp`

```cb
futures[0] = task_id(1);
```
のような代入で、右辺の構造体型情報を配列要素に正しく保存。

## テストケース

### Test 4: Future配列の順次await
```cb
Future<int> futures[3];
futures[0] = task_id(1);
futures[1] = task_id(2);
futures[2] = task_id(3);

int r0 = await futures[0];
int r1 = await futures[1];
int r2 = await futures[2];
```

### Test 5: Future配列の逆順await
```cb
Future<int> futures2[3];
futures2[0] = task_id(1);
futures2[1] = task_id(2);
futures2[2] = task_id(3);

int r2b = await futures2[2];  // 最長を先にawait
int r1b = await futures2[1];  // 既に完了
int r0b = await futures2[0];  // 既に完了
```

### Test 6: Future変数の後でawait
```cb
Future<int> saved_future = compute_value(7);
await sleep(20);
int saved_result = await saved_future;
```

### Test 7: awaitせずにFutureを破棄
```cb
Future<int> discarded = compute_value(9);
// awaitせずにスコープを抜ける（メモリリークチェック）
```

## 関連ファイル
- `src/backend/interpreter/evaluator/core/evaluator.cpp`
- `src/backend/interpreter/managers/variables/initialization.cpp`
- `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
- `tests/cases/async/test_future_multiple_await.cb`

## 優先度
Medium - 基本的なasync/await機能は動作しているが、配列を使った並行処理パターンには必須

## 関連する制限事項
現在、以下の機能は正常に動作:
- ✅ 基本的なFuture変数（`Future<T> f = async_func();`）
- ✅ int型Future
- ✅ string型Future
- ✅ 構造体型Future（ジェネリクスでない構造体）
- ✅ 同じFutureを複数回await
- ❌ Future配列（`Future<T>[]`）
- ❌ ジェネリクス構造体の配列全般

## 参考
- v0.11.0でジェネリクス構造体の基本サポートを実装済み
- v0.12.0でasync/await基本機能を実装済み
- ジェネリクス型の配列サポートは全体的な改善が必要

---

# 追加機能: async/awaitのエラーハンドリング（Result型統合）

## 概要

v0.13.0では、async/await機能にResult<T, E>型を統合し、Rust風のエラーハンドリングを実現します。これにより、非同期処理でのエラーを型安全に扱えるようになります。

## 現状

v0.12.0では以下が実装済み:
- ✅ async/await構文の完全実装
- ✅ Future<T>のビルトイン型化
- ✅ 非ブロッキングsleep
- ✅ yield機能
- ✅ SimpleEventLoop

v0.11.0では以下が実装済み:
- ✅ Result<T, E>型（ビルトイン）
- ✅ Option<T>型（ビルトイン）
- ✅ match文によるパターンマッチング
- ✅ Enum with Associated Values

## 未実装の機能

### 1. async関数でのResult型戻り値

**目的**: 非同期処理のエラーを型安全に扱う

**構文**:
```cb
async Result<int, NetworkError> fetch_data(string url) {
    if (url == "") {
        NetworkError err;
        err.message = "URL cannot be empty";
        err.status_code = 400;
        return Err(err);
    }
    
    await sleep(100);
    
    string response = await http_get(url);
    
    if (response == "") {
        NetworkError err;
        err.message = "Empty response";
        err.status_code = 500;
        return Err(err);
    }
    
    int value = parse_int(response);
    return Ok(value);
}
```

**使用例**:
```cb
void main() {
    Result<int, NetworkError> result = await fetch_data("https://api.example.com");
    
    match (result) {
        Ok(value) => {
            println("Success: {value}");
        },
        Err(error) => {
            println("Error: {error.message}");
            println("Status: {error.status_code}");
        }
    }
}
```

### 2. ?オペレーター（エラー伝播）

**目的**: エラーハンドリングのボイラープレートを削減

**構文**:
```cb
async Result<int, Error> process_data(string url) {
    // エラーが発生した場合、自動的に返す
    int data = await fetch_data(url)?;  // Errの場合はここで即return
    
    int processed = data * 2;
    return Ok(processed);
}

// 複数のエラーチェック
async Result<int, Error> complex_operation() {
    int data1 = await fetch_data("url1")?;
    int data2 = await fetch_data("url2")?;
    int data3 = await fetch_data("url3")?;
    
    return Ok(data1 + data2 + data3);
}
```

**展開後の動作**:
```cb
// ?オペレーターは以下のように展開される
int data = await fetch_data(url)?;

// ↓ 展開

Result<int, Error> temp_result = await fetch_data(url);
match (temp_result) {
    Ok(value) => {
        int data = value;  // 成功時は値を取得
    },
    Err(e) => {
        return Err(e);  // エラー時は即座にreturn
    }
}
```

### 3. Future<Result<T, E>>の組み合わせ

**内部表現**:
```cb
// async関数がResult<T, E>を返す場合、内部的にはFuture<Result<T, E>>
async Result<int, Error> fetch() {
    // ...
}

// ↓ 内部的には

Future<Result<int, Error>> fetch() {
    // ...
}
```

**使用パターン**:
```cb
// パターン1: 直接await + match
Result<int, Error> result = await fetch();
match (result) {
    Ok(value) => println("{value}"),
    Err(e) => println("{e.message}")
}

// パターン2: ?オペレーターで簡潔に
async Result<int, Error> caller() {
    int value = await fetch()?;  // エラーは自動伝播
    return Ok(value * 2);
}
```

## 実装計画

### Phase 1: async関数のResult型戻り値サポート（2週間）

**タスク**:
1. パーサー拡張
   - [ ] `async Result<T, E> func()` の構文解析
   - [ ] 戻り値型が`Result<T, E>`の場合の特別処理

2. インタープリター拡張
   - [ ] async関数内で`return Ok(value)`の処理
   - [ ] async関数内で`return Err(error)`の処理
   - [ ] Future<Result<T, E>>の内部管理

3. テスト
   - [ ] 基本的なResult型を返すasync関数
   - [ ] match文との統合
   - [ ] 複数のエラー型

**関連ファイル**:
- `src/frontend/parser/recursive_parser.cpp`
- `src/backend/interpreter/executors/functions/async_executor.cpp`
- `src/backend/interpreter/types/future_manager.cpp`

### Phase 2: ?オペレーター実装（2週間）

**タスク**:
1. パーサー拡張
   - [ ] `expr?` の後置演算子としての認識
   - [ ] await式との組み合わせ（`await expr?`）

2. インタープリター拡張
   - [ ] Result<T, E>型のチェック
   - [ ] Errの場合の早期リターン
   - [ ] Okの場合の値の抽出
   - [ ] 関数の戻り値型検証

3. エラー処理
   - [ ] 型不一致のエラーメッセージ
   - [ ] 戻り値型がResult<T, E>でない場合のエラー

4. テスト
   - [ ] 基本的な?オペレーター
   - [ ] ネストした?オペレーター
   - [ ] await式との組み合わせ
   - [ ] エラー伝播のチェーン

**関連ファイル**:
- `src/frontend/parser/recursive_parser.cpp`
- `src/backend/interpreter/evaluator/operators/binary_unary.cpp`
- `src/backend/interpreter/executors/control_flow_executor.cpp`

### Phase 3: Result型メソッドの拡張（1週間）

**タスク**:
1. unwrap系メソッド
   - [ ] `unwrap()` - パニック
   - [ ] `expect(message)` - カスタムメッセージ付きパニック
   - [ ] `unwrap_or(default)` - デフォルト値
   - [ ] `unwrap_or_else(func)` - 遅延評価

2. 変換メソッド
   - [ ] `map(func)` - Ok値の変換
   - [ ] `and_then(func)` - Result型を返す関数のチェーン
   - [ ] `or_else(func)` - Err時の代替処理

3. 判定メソッド
   - [ ] `is_ok()` - 成功かどうか
   - [ ] `is_err()` - エラーかどうか

**関連ファイル**:
- `src/backend/interpreter/types/result_methods.cpp`
- `src/backend/interpreter/evaluator/member_access.cpp`

### Phase 4: ドキュメントとテスト（1週間）

**タスク**:
1. ドキュメント作成
   - [ ] async/awaitとResult型の統合ガイド
   - [ ] ?オペレーターの使用例
   - [ ] エラーハンドリングのベストプラクティス

2. 包括的テスト
   - [ ] 実用的なユースケース
   - [ ] エッジケースのカバレッジ
   - [ ] パフォーマンステスト

## テストケース

### Test 1: 基本的なResult型を返すasync関数
```cb
struct NetworkError {
    string message;
    int status_code;
}

async Result<int, NetworkError> fetch_value(int x) {
    if (x < 0) {
        NetworkError err;
        err.message = "Negative value";
        err.status_code = 400;
        return Err(err);
    }
    
    await sleep(100);
    return Ok(x * 2);
}

void main() {
    Result<int, NetworkError> r1 = await fetch_value(5);
    match (r1) {
        Ok(v) => println("Success: {v}"),  // 10
        Err(e) => println("Error: {e.message}")
    }
    
    Result<int, NetworkError> r2 = await fetch_value(-1);
    match (r2) {
        Ok(v) => println("Success: {v}"),
        Err(e) => println("Error: {e.message}")  // "Negative value"
    }
}
```

### Test 2: ?オペレーターによるエラー伝播
```cb
async Result<int, NetworkError> process(int x) {
    int value = await fetch_value(x)?;  // エラーは自動伝播
    return Ok(value + 10);
}

void main() {
    Result<int, NetworkError> r1 = await process(5);
    println("Result 1: {r1}");  // Ok(20)
    
    Result<int, NetworkError> r2 = await process(-1);
    println("Result 2: {r2}");  // Err(NetworkError{...})
}
```

### Test 3: 複数のasync呼び出しと?オペレーター
```cb
async Result<int, NetworkError> complex_operation() {
    int a = await fetch_value(3)?;
    int b = await fetch_value(5)?;
    int c = await fetch_value(7)?;
    
    return Ok(a + b + c);
}

void main() {
    Result<int, NetworkError> result = await complex_operation();
    match (result) {
        Ok(sum) => println("Sum: {sum}"),  // 30
        Err(e) => println("Error: {e.message}")
    }
}
```

### Test 4: unwrap_orによるデフォルト値
```cb
async Result<int, NetworkError> maybe_fetch(int x) {
    if (x == 0) {
        NetworkError err;
        err.message = "Zero not allowed";
        err.status_code = 400;
        return Err(err);
    }
    return Ok(x * 10);
}

void main() {
    Result<int, NetworkError> r1 = await maybe_fetch(5);
    int value1 = r1.unwrap_or(999);  // 50
    
    Result<int, NetworkError> r2 = await maybe_fetch(0);
    int value2 = r2.unwrap_or(999);  // 999 (デフォルト値)
    
    println("Value1: {value1}, Value2: {value2}");
}
```

## 技術詳細

### Result型のメモリ管理

**構造**:
```cpp
struct ResultValue {
    enum class Variant { OK, ERR } variant;
    Variable ok_value;   // Ok(T)の値
    Variable err_value;  // Err(E)の値
};
```

### ?オペレーターのコード生成

**入力**:
```cb
int data = await fetch_data(url)?;
```

**生成されるコード（概念）**:
```cpp
// 1. await式を評価
auto temp_future = fetch_data(url);
auto temp_result = await_expression(temp_future);

// 2. Result型のチェック
if (temp_result.variant == ERR) {
    // 現在の関数の戻り値型もResult<T, E>であることを確認
    return create_err(temp_result.err_value);
}

// 3. Ok値を取り出す
int data = temp_result.ok_value;
```

## 優先度

**High** - エラーハンドリングは非同期処理の実用性に不可欠

## 依存関係

- ✅ Result<T, E>型（v0.11.0で実装済み）
- ✅ match文（v0.11.0で実装済み）
- ✅ async/await構文（v0.12.0で実装済み）
- ✅ Future<T>型（v0.12.0で実装済み）

## 期待される利点

1. **型安全性**: コンパイル時にエラーハンドリングの漏れを検出
2. **明示性**: エラーパスが明確
3. **簡潔性**: ?オペレーターによるボイラープレート削減
4. **一貫性**: Rust風の慣用的なパターン
5. **組み合わせ可能**: Future<T>とResult<T, E>の自然な統合

## 参考ドキュメント

- `docs/archive/todo/v0.12.0_async_await/v0.12.0_async_await_design.md` - Result型との統合設計
- `docs/archive/features/v0.11.0_implemented/pattern_matching.md` - match文の実装
- `docs/archive/features/v0.11.0_implemented/builtin_types_option_result.md` - Result型の基本実装
