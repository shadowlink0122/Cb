# Cbè¨€èªä»•æ§˜æ›¸

## æ¦‚è¦

ãƒ¢ãƒ€ãƒ³ãªC++ã®ã‚ˆã†ãªã‚¤ãƒ¡ãƒ¼ã‚¸ã€‚æ§‹æ–‡ã¯C++ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ã€‚

### å½±éŸ¿ã•ã‚Œã¦ã„ã‚‹è¨€èªã¨ãã®éƒ¨åˆ†
- **C/C++**
    - å¤‰æ•°å®£è¨€ã€é–¢æ•°å®£è¨€
    - RAIIï¼ˆResource Acquisition Is Initializationï¼‰ã«ã‚ˆã‚‹ãƒ¡ãƒ¢ãƒªç®¡ç†
- **TypeScript**
    - å‹å®£è¨€, typedef
    - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    - ãƒ©ãƒ ãƒ€å¼ã€ä»®æƒ³é–¢æ•°
- **Go**
    - é…åˆ—ãƒ»ã‚¹ãƒ©ã‚¤ã‚¹
    - éåŒæœŸå‡¦ç†ï¼ˆgoroutineã€channelï¼‰
- **Rust**
    - interface, traitï¼ˆâœ… Interface/Implã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦å®Ÿè£…æ¸ˆã¿ï¼‰
    - ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å…¥ã‚Œãªã„ï¼‰
    - Resultå‹ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ï¼ˆä¾‹å¤–å‡¦ç†æ©Ÿæ§‹ã¯å…¥ã‚Œãªã„ï¼‰

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™
- Ruby, Pythonã‚ˆã‚Šé«˜é€Ÿ
- GCã‚’ä½¿ã‚ãªã„ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–
- C++ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ©ã‚¤ã‚¯ãªRAIIè‡ªå‹•ãƒ¡ãƒ¢ãƒªç®¡ç†

### ã‚¨ãƒ©ãƒ¼å‡¦ç†æˆ¦ç•¥
ç”¨é€”ã«å¿œã˜ã¦ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼š

1. **Resultå‹ãƒ¢ãƒ¼ãƒ‰**ï¼ˆæ¨å¥¨ãƒ»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
   - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã€ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨é€”
   - `Result<T, E>` å‹ã«ã‚ˆã‚‹æ˜ç¤ºçš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
   - ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã«ã‚ˆã‚‹å®‰å…¨ãªã‚¨ãƒ©ãƒ¼å‡¦ç†

2. **ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰**
   - è»½é‡ãƒ»é«˜é€ŸãŒè¦æ±‚ã•ã‚Œã‚‹ç”¨é€”ï¼ˆçµ„ã¿è¾¼ã¿ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç­‰ï¼‰
   - ç¾åœ¨ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼å®Ÿè£…ã§ä½¿ç”¨
   - å¾“æ¥ã®Cè¨€èªçš„ãªæˆ»ã‚Šå€¤ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†

3. **ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ãƒ¢ãƒ¼ãƒ‰**
   - ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤: Resultå‹
   - ã‚·ã‚¹ãƒ†ãƒ å±¤: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
   - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒ•ãƒ©ã‚°ã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½

### ãƒ¡ãƒ¢ãƒªç®¡ç†æˆ¦ç•¥
**RAII + ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹è‡ªå‹•ç®¡ç†**
- `unique_ptr<T>`ï¼šæ’ä»–çš„æ‰€æœ‰æ¨©
- `shared_ptr<T>`ï¼šå…±æœ‰æ‰€æœ‰æ¨©  
- `weak_ptr<T>`ï¼šå¼±å‚ç…§
- ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ä½¿ç”¨ã—ãªã„ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ï¼‰
- C++17/20ã®`std::optional`ã€`std::variant`æ´»ç”¨

### å°†æ¥çš„ã«ã§ãã‚‹ã“ã¨
- ãƒ“ãƒ«ãƒ‰ã—ã€ãƒã‚¤ãƒŠãƒªã‚’ç”Ÿæˆã§ãã‚‹ã‚ˆã†ã«ã§ãã‚‹
    - IRç”Ÿæˆ
    - æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
    - å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
- OSãŒæ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚‹
    - ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼é ˜åŸŸã§ã¯ Go ã‚ˆã‚Šä¾¿åˆ©ã«ãªã‚Œã°å¬‰ã—ã„
- ã‚¦ã‚§ãƒ–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’æä¾›ã§ãã‚‹
    - Railsã‚ˆã‚Šæ˜ç¤ºçš„ã«æ›¸ã‘ã‚‹ã“ã¨
    - React, Ginãªã©ã®ã‚ˆã†ã« REST API ãªã©ãŒä½¿ãˆã‚‹
- ãƒ•ãƒ­ãƒ³ãƒˆãŒæ›¸ã‘ã‚‹
    - JavaScript, TypeScript ã«ç½®ãæ›ã‚ã‚‹ã‚‚ã®ã«ãªã‚‹
    - ç‰¹ã« TypeScriptã«è¿‘ã„ã‚‚ã®ãŒã§ãã‚Œã°è‰¯ã„

## å®Ÿè£…çŠ¶æ³

### Phase 1: åŸºæœ¬æ©Ÿèƒ½ âœ…ï¼ˆå®Œæˆï¼‰
- âœ… **å‹ã‚·ã‚¹ãƒ†ãƒ **ï¼ˆãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ï¼štiny, short, int, long, string, char, boolï¼‰
- âœ… **å¤‰æ•°å®£è¨€ãƒ»åˆæœŸåŒ–**ï¼ˆè¤‡æ•°å¤‰æ•°åŒæ™‚å®£è¨€å¯¾å¿œï¼‰
- âœ… **é…åˆ—ã‚·ã‚¹ãƒ†ãƒ **ï¼ˆé™çš„é…åˆ—ãƒ»å¤šæ¬¡å…ƒé…åˆ—ãƒ»é…åˆ—ãƒªãƒ†ãƒ©ãƒ«å®Œå…¨å¯¾å¿œï¼‰
- âœ… **é–¢æ•°å®šç¾©ãƒ»å‘¼ã³å‡ºã—**ï¼ˆé–¢æ•°æˆ»ã‚Šå€¤å‹ãƒã‚§ãƒƒã‚¯ã€é…åˆ—æˆ»ã‚Šå€¤å¯¾å¿œï¼‰
- âœ… **åˆ¶å¾¡æ§‹é€ **ï¼ˆif/else, for, while, break, continue, returnï¼‰
- âœ… **æ¼”ç®—å­å®Œå…¨å®Ÿè£…**
  - âœ… **10ç¨®é¡ã®è¤‡åˆä»£å…¥æ¼”ç®—å­**: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
  - âœ… **å‰ç½®ãƒ»å¾Œç½®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ**: `++var`, `--var`, `var++`, `var--`
  - âœ… **é…åˆ—è¦ç´ è¤‡åˆä»£å…¥**: `arr[index] += value`ã€`arr[i*2+1] *= (x+y)`
  - âœ… **è‡ªå·±ä»£å…¥æ©Ÿèƒ½**: åŸºæœ¬çš„ãªè‡ªå·±ä»£å…¥ã€é…åˆ—è‡ªå·±ä»£å…¥ã€ãƒ“ãƒƒãƒˆæ¼”ç®—è‡ªå·±ä»£å…¥
- âœ… **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä¿®é£¾å­**ï¼ˆconst, staticï¼‰
- âœ… **æ¨™æº–å‡ºåŠ›**ï¼ˆprint, printfé¢¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­ï¼‰
- âœ… **Unionå‹ã‚·ã‚¹ãƒ†ãƒ **ï¼ˆTypeScripté¢¨å®Œå…¨å®Ÿè£…ï¼‰
  - âœ… **å…¨ç¨®é¡ã®Unionå¯¾å¿œ**: ãƒªãƒ†ãƒ©ãƒ«å€¤ã€åŸºæœ¬å‹ã€ã‚«ã‚¹ã‚¿ãƒ å‹ã€æ§‹é€ ä½“ã€é…åˆ—Union
  - âœ… **æ··åˆUnion**: `typedef Mixed = 42 | int | string;`
  - âœ… **æ–‡å­—åˆ—å‡¦ç†ãƒ»è¤‡åˆä»£å…¥**: å®Œå…¨å¯¾å¿œ
  - âœ… **å‹å®‰å…¨æ€§**: å³å¯†ãªå‹æ¤œè¨¼ã¨ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  - âœ… **åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: 15ç¨®é¡ã®ç•°å¸¸ç³»ãƒ†ã‚¹ãƒˆå®Œå…¨å¯¾å¿œ
- âœ… **å¤šæ¬¡å…ƒé…åˆ—æˆ»ã‚Šå€¤å‡¦ç†**: typedefé…åˆ—é–¢æ•°ã®å®Œå…¨å¯¾å¿œ
- âœ… **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**ï¼ˆçµ±åˆãƒ†ã‚¹ãƒˆ1386å€‹ã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ26å€‹ã€100%æˆåŠŸç‡ï¼‰
- âœ… **å†å¸°ä¸‹é™ãƒ‘ãƒ¼ã‚µãƒ¼**ã«ã‚ˆã‚‹é«˜åŠ¹ç‡æ§‹æ–‡è§£æ

### Phase 2: é«˜åº¦æ©Ÿèƒ½ âœ…ï¼ˆå®Œæˆï¼‰
- âœ… **struct ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨å®Ÿè£…**
  - âœ… **åŸºæœ¬æ§‹é€ ä½“æ©Ÿèƒ½**: å®šç¾©ãƒ»å®£è¨€ãƒ»ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹ãƒ»ãƒªãƒ†ãƒ©ãƒ«åˆæœŸåŒ–
  - âœ… **æ§‹é€ ä½“é…åˆ—**: æ§‹é€ ä½“é…åˆ—ãƒ»é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼ãƒ»ãƒã‚¹ãƒˆã‚¢ã‚¯ã‚»ã‚¹
  - âœ… **printf/printlnçµ±åˆ**: æ§‹é€ ä½“ãƒ¡ãƒ³ãƒãƒ¼å®Œå…¨å¯¾å¿œ
  - âœ… **å‹å®‰å…¨æ€§**: æ§‹é€ ä½“å‹ãƒã‚§ãƒƒã‚¯ãƒ»å¢ƒç•Œæ¤œè¨¼
  - âœ… **é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼åŒæœŸ**: å€‹åˆ¥ä»£å…¥ã¨printfè©•ä¾¡ã®åŒæœŸæ©Ÿèƒ½å®Œå…¨ä¿®æ­£
- âœ… **Unionå‹ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨å®Ÿè£…**ï¼ˆTypeScripté¢¨ï¼‰
  - âœ… **å…¨ç¨®é¡Unionå¯¾å¿œ**: ãƒªãƒ†ãƒ©ãƒ«å€¤ãƒ»åŸºæœ¬å‹ãƒ»ã‚«ã‚¹ã‚¿ãƒ å‹ãƒ»æ§‹é€ ä½“ãƒ»é…åˆ—ãƒ»æ··åˆUnion
  - âœ… **å‹å®‰å…¨æ€§**: å³å¯†ãªå‹æ¤œè¨¼ãƒ»å†å¸°çš„typedefå¯¾å¿œãƒ»åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  - âœ… **å®Ÿè¡Œæ™‚å‹å¤‰æ›**: å‹•çš„å‹å¤‰æ›ãƒ»è¤‡åˆä»£å…¥æ¼”ç®—å­å®Œå…¨å¯¾å¿œ
- âœ… **typedef ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨å®Ÿè£…**
  - âœ… **åŸºæœ¬typedef**: å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ãƒ»å†å¸°çš„typedefå¯¾å¿œ
  - âœ… **Union typedef**: TypeScripté¢¨Unionå‹å®šç¾©
  - âœ… **é…åˆ—typedef**: å¤šæ¬¡å…ƒé…åˆ—typedefãƒ»æˆ»ã‚Šå€¤å¯¾å¿œ
- âœ… **Interface/Implã‚·ã‚¹ãƒ†ãƒ å®Œå…¨å®Ÿè£…**
  - âœ… **ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹å®Ÿè£…**: int, string, boolç­‰ã¸ã®ç›´æ¥impl
  - âœ… **æ§‹é€ ä½“å‹å®Ÿè£…**: structå‹ã¸ã®ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ãƒ»selfå‚ç…§å¯¾å¿œ
  - âœ… **é…åˆ—å‹å®Ÿè£…**: 1æ¬¡å…ƒãƒ»å¤šæ¬¡å…ƒé…åˆ—å‹ã¸ã®å®Ÿè£…
  - âœ… **Typedefå‹å®Ÿè£…**: typedefå‹ã¸ã®ç‹¬ç«‹implå®Ÿè£…
  - âœ… **å†å¸°çš„Typedefç‹¬ç«‹æ€§**: å„typedeféšå±¤ã§ã®ç‹¬ç«‹interfaceå®Ÿè£…
  - âœ… **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å¤‰æ•°**: å‹æŠ½è±¡åŒ–ã¨ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 
  - âœ… **åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼æ¤œå‡º**: æœªå®šç¾©interfaceã€é‡è¤‡å®Ÿè£…ã€ç½²åä¸ä¸€è‡´
  - âœ… **ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—**: selfå‚ç…§å¯¾å¿œã®å®‰å…¨ãªãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè¡Œ
  - âœ… **ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰**: implå†…ã§ã®è©³ç´°åˆ¶å¾¡
- âœ… **enumå®šç¾©**ï¼ˆåŸºæœ¬å®Ÿè£…ãƒ»Interfaceé€£æºå®Œå…¨å¯¾å¿œï¼‰
- âœ… **æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåŸºç›¤**ï¼ˆmath.cb, stdio.cbï¼‰

#### æ§‹é€ ä½“æ©Ÿèƒ½å®Œå…¨å®Ÿè£…çŠ¶æ³ âœ…
ç¾åœ¨ã®Cbè¨€èªã®æ§‹é€ ä½“ã‚·ã‚¹ãƒ†ãƒ ã¯å®Œå…¨ã«å®Ÿè£…ã•ã‚Œã€å®Ÿç”¨ãƒ¬ãƒ™ãƒ«ã«é”ã—ã¦ã„ã¾ã™ï¼š

**âœ… å®Œå…¨å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½**:
- **åŸºæœ¬æ§‹é€ ä½“å®šç¾©ãƒ»ä½¿ç”¨**: å®Œå…¨å®Ÿè£… 
- **æ§‹é€ ä½“ãƒªãƒ†ãƒ©ãƒ«åˆæœŸåŒ–**: åå‰ä»˜ããƒ»ä½ç½®æŒ‡å®šä¸¡å¯¾å¿œãƒ»æœ«å°¾ã‚«ãƒ³ãƒå¯¾å¿œ 
- **æ§‹é€ ä½“é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼**: 1æ¬¡å…ƒãƒ»å¤šæ¬¡å…ƒé…åˆ—ãƒ¡ãƒ³ãƒãƒ¼ãƒ»å€‹åˆ¥ä»£å…¥ãƒ»é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ä»£å…¥ä¸¡å¯¾å¿œ 
- **æ§‹é€ ä½“ã®é…åˆ—**: æ§‹é€ ä½“é…åˆ—ãƒªãƒ†ãƒ©ãƒ«åˆæœŸåŒ–å¯¾å¿œ 
- **printf/printlnçµ±åˆ**: æ§‹é€ ä½“ãƒ¡ãƒ³ãƒãƒ¼ãƒ»é…åˆ—è¦ç´ å®Œå…¨å¯¾å¿œ 
- **é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼åŒæœŸ**: å€‹åˆ¥ä»£å…¥ã¨printfè©•ä¾¡ã®åŒæœŸæ©Ÿèƒ½å®Œå…¨ä¿®æ­£
- **å¤šæ¬¡å…ƒé…åˆ—æˆ»ã‚Šå€¤**: typedefé…åˆ—é–¢æ•°ã®å®Œå…¨å¯¾å¿œ
- **çµ±åˆãƒ†ã‚¹ãƒˆ**: å®Œå…¨ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ï¼ˆ100%æˆåŠŸç‡ï¼‰

**ğŸš§ å°†æ¥å®Ÿè£…äºˆå®šæ©Ÿèƒ½**:
- **ãƒã‚¹ãƒˆã—ãŸæ§‹é€ ä½“**: `obj.member.submember` ã‚’ãƒã‚¤ãƒ³ã‚¿çµŒç”±ã§è§£æ±ºï¼ˆå€¤ãƒ¡ãƒ³ãƒã§ã®å†å¸°ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼‰
- **æ§‹é€ ä½“é–¢æ•°å¼•æ•°ãƒ»æˆ»ã‚Šå€¤**: å€¤æ¸¡ã—ãƒ»æ§‹é€ ä½“æˆ»ã‚Šå€¤å®Œå…¨å¯¾å¿œ
- **æ§‹é€ ä½“ç¶™æ‰¿**: æœªå®Ÿè£…ï¼ˆinterface/implã‚·ã‚¹ãƒ†ãƒ ã§ä»£æ›¿å¯èƒ½ï¼‰

### Phase 3: å°†æ¥å®Ÿè£…äºˆå®š âŒ/ğŸš§
- ğŸš§ **ãƒã‚¤ãƒ³ã‚¿ã‚·ã‚¹ãƒ†ãƒ **ï¼ˆå®Ÿè£…ä¸­ï¼‰
    - `T*` / `T**` ãªã©ã®ãƒã‚¤ãƒ³ã‚¿å‹ã¨ `nullptr` ãƒªãƒ†ãƒ©ãƒ«
    - `new` / `delete` æ–‡ã«ã‚ˆã‚‹å‹•çš„ãƒ¡ãƒ¢ãƒªç¢ºä¿ã¨è§£æ”¾
    - æ§‹é€ ä½“ãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã™ã‚‹ `.` ã‚¢ã‚¯ã‚»ã‚¹ã®æš—é»™ãƒ‡ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹
    - æ§‹é€ ä½“ã®è‡ªå·±å†å¸°ãƒ»ç›¸äº’å†å¸°ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¡ãƒ³ãƒçµŒç”±ã®ã¿è¨±å¯
- âŒ **Resultå‹ã‚¨ãƒ©ãƒ¼å‡¦ç†**ï¼ˆGo/Rusté¢¨ã®æ˜ç¤ºçš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼‰
- âŒ **ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿**ï¼ˆunique_ptr, shared_ptr, weak_ptrï¼‰
- âŒ **ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ **ï¼ˆTypeScripté¢¨ï¼‰
- âŒ **ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹**ï¼ˆå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ»åˆ¶ç´„ï¼‰
- âŒ **éåŒæœŸå‡¦ç†**ï¼ˆgoroutine/channelï¼‰
- âŒ **ãƒ©ãƒ ãƒ€å¼**ï¼ˆã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ï¼‰
- âŒ **ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆ**ï¼ˆRusté¢¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼‰
- ğŸš§ **æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ‹¡å……**ï¼ˆç¾åœ¨ math.cb, stdio.cb åŸºç›¤å®Ÿè£…æ¸ˆã¿ï¼‰

## æ§‹æ–‡å®šç¾©ï¼ˆBNFè¨˜æ³•ï¼‰

### åŸºæœ¬æ§‹æ–‡
```bnf
program         ::= declaration_list

declaration_list ::= declaration
                  | declaration_list declaration

declaration     ::= variable_declaration
                  | function_declaration
                  | struct_declaration
                  | typedef_declaration
                  | union_typedef_declaration
                  | enum_declaration

type_specifier  ::= "void" | "tiny" | "short" | "int" | "long" 
                  | "string" | "char" | "bool" | identifier
                  | type_specifier "[" constant_expression "]"
                  | type_specifier "*"

storage_class   ::= "const" | "static" | "extern"
```

### å¤‰æ•°å®£è¨€
```bnf  
variable_declaration ::= storage_class* type_specifier declarator_list ";"

declarator_list ::= declarator
                  | declarator_list "," declarator

declarator      ::= identifier
                  | identifier "=" initializer
                  | identifier "[" constant_expression "]"  
                  | identifier "[" constant_expression "]" "=" array_initializer

initializer     ::= assignment_expression
                  | array_initializer

array_initializer ::= "[" initializer_list "]"
                    | "[" initializer_list "," "]"

initializer_list ::= initializer
                   | initializer_list "," initializer
```

### å‹å®£è¨€ãƒ»Unionå‹
```bnf
typedef_declaration ::= "typedef" type_specifier identifier ";"
                      | union_typedef_declaration

union_typedef_declaration ::= "typedef" identifier "=" union_type_list ";"

union_type_list ::= union_type
                  | union_type_list "|" union_type

union_type ::= literal_value
             | type_specifier
             | identifier
             | array_type_specifier

literal_value ::= integer_constant
                | string_literal
                | character_literal
                | boolean_constant

array_type_specifier ::= type_specifier "[" constant_expression "]"
```

### Interface/Implå®£è¨€ ğŸ†•
```bnf
interface_declaration ::= "interface" identifier "{" method_signature_list "}"

method_signature_list ::= method_signature
                        | method_signature_list method_signature

method_signature ::= type_specifier identifier "(" parameter_list ")" ";"

impl_declaration ::= "impl" identifier "for" type_specifier "{" method_definition_list "}"

method_definition_list ::= method_definition
                         | method_definition_list method_definition

method_definition ::= type_specifier identifier "(" parameter_list ")" compound_statement

interface_variable_declaration ::= identifier identifier "=" assignment_expression ";"

interface_method_call ::= identifier "." identifier "(" argument_list ")"
```

function_declaration ::= storage_class* type_specifier identifier 
                        "(" parameter_list ")" compound_statement

parameter_list  ::= "void"
                  | parameter_declaration_list

parameter_declaration_list ::= parameter_declaration  
                             | parameter_declaration_list "," parameter_declaration

parameter_declaration ::= type_specifier identifier
```

### æ–‡ï¼ˆStatementï¼‰
```bnf
statement       ::= expression_statement
                  | compound_statement
                  | selection_statement
                  | iteration_statement  
                  | jump_statement
                  | delete_statement
                  | print_statement

compound_statement ::= "{" statement_list "}"

statement_list  ::= statement
                  | statement_list statement

expression_statement ::= expression ";"

selection_statement ::= "if" "(" expression ")" statement
                      | "if" "(" expression ")" statement "else" statement

iteration_statement ::= "while" "(" expression ")" statement
                      | "for" "(" expression ";" expression ";" expression ")" statement
                      | "for" "(" variable_declaration expression ";" expression ")" statement

jump_statement  ::= "break" ";"
                  | "continue" ";"
                  | "return" ";"  
                  | "return" expression ";"

print_statement ::= "print" "(" argument_list ")" ";"

delete_statement ::= "delete" expression ";"
```

### å¼ï¼ˆExpressionï¼‰
```bnf
expression      ::= assignment_expression
                  | expression "," assignment_expression

assignment_expression ::= logical_or_expression
                        | unary_expression assignment_operator assignment_expression

assignment_operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" 
                      | "&=" | "|=" | "^=" | "<<=" | ">>="

logical_or_expression ::= logical_and_expression
                        | logical_or_expression "||" logical_and_expression

logical_and_expression ::= equality_expression
                         | logical_and_expression "&&" equality_expression

equality_expression ::= relational_expression  
                      | equality_expression "==" relational_expression
                      | equality_expression "!=" relational_expression

relational_expression ::= additive_expression
                        | relational_expression "<" additive_expression
                        | relational_expression ">" additive_expression  
                        | relational_expression "<=" additive_expression
                        | relational_expression ">=" additive_expression

additive_expression ::= multiplicative_expression
                      | additive_expression "+" multiplicative_expression
                      | additive_expression "-" multiplicative_expression

multiplicative_expression ::= unary_expression
                            | multiplicative_expression "*" unary_expression
                            | multiplicative_expression "/" unary_expression
                            | multiplicative_expression "%" unary_expression

unary_expression ::= postfix_expression
                   | "++" unary_expression
                   | "--" unary_expression  
                   | "!" unary_expression
                   | "+" unary_expression
                   | "-" unary_expression
                   | "*" unary_expression
                   | "&" unary_expression

postfix_expression ::= primary_expression
                     | postfix_expression "[" expression "]"
                     | postfix_expression "(" argument_list ")"
                     | postfix_expression "++"
                     | postfix_expression "--"

primary_expression ::= identifier
                     | constant
                     | string_literal
                     | character_literal
                     | array_literal
                     | "nullptr"
                     | "new" type_specifier
                     | "new" type_specifier "(" ")"
                     | "new" type_specifier "(" argument_list ")"
                     | "(" expression ")"

constant        ::= integer_constant | character_constant | boolean_constant | "nullptr"

character_literal ::= "'" character "'"
                    | "'" escape_sequence "'"

array_literal   ::= "[" argument_list "]"
                  | "[" "]"

escape_sequence ::= "\n" | "\t" | "\\" | "\'" | "\0" | "\"" | "\r"

argument_list   ::= assignment_expression
                  | argument_list "," assignment_expression
```

## è¨€èªæ©Ÿèƒ½è©³ç´°

### å¤‰æ•°

#### ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ï¼ˆTYPEï¼‰âœ…
- `void`: æˆ»ã‚Šå€¤ãªã—å‹ï¼ˆå¤‰æ•°å®£è¨€ä¸å¯ï¼‰
- `tiny`: 8bitç¬¦å·ä»˜ãæ•´æ•° (-128ã€œ127)
- `short`: 16bitç¬¦å·ä»˜ãæ•´æ•° (-32768ã€œ32767)  
- `int`: 32bitç¬¦å·ä»˜ãæ•´æ•° (-2^31ã€œ2^31-1)
- `long`: 64bitç¬¦å·ä»˜ãæ•´æ•° (-2^63ã€œ2^63-1)
    - æ•´æ•°å‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: 0
- `char`: 8bitæ–‡å­—å‹ (0ã€œ255)
    - æ–‡å­—ãƒªãƒ†ãƒ©ãƒ«: 'A', '\n', '\t', '\\', '\'', '\0' ç­‰ã‚’ã‚µãƒãƒ¼ãƒˆ
    - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: '\0'
- `string`: UTF-8æ–‡å­—åˆ—
    - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: ""ï¼ˆç©ºæ–‡å­—åˆ—ï¼‰
    - ç¾åœ¨ã¯ std::string ã®ãƒ©ãƒƒãƒ‘ãƒ¼
    - å°†æ¥: ãƒ™ã‚¢ãƒ¡ã‚¿ãƒ«ç’°å¢ƒå¯¾å¿œï¼ˆãƒã‚¤ãƒ³ã‚¿éš è”½ï¼‰
- `bool`: çœŸå½å€¤å‹
    - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: false

##### unsignedä¿®é£¾å­ âœ…
- `tiny` / `short` / `int` / `long` ãªã©ã®æ•´æ•°å‹ã« `unsigned` ã‚’ä»˜ä¸å¯èƒ½ï¼ˆå°†æ¥çš„ã« `float` ç³»ã‚‚å¯¾è±¡ï¼‰
- ãƒ‘ãƒ¼ã‚µã¯ `unsigned TYPE` / `unsigned TYPE*` / `unsigned TYPE[SIZE]` ã‚’å—ç†ã—ã€ASTã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
- å®Ÿè¡Œæ™‚ã¯åˆæœŸåŒ–å€¤ãƒ»å†ä»£å…¥ãƒ»é–¢æ•°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å—ã‘æ¸¡ã—ã®ã„ãšã‚Œã§ã‚‚è² ã®å€¤ã‚’æ¤œå‡ºã™ã‚‹ã¨è­¦å‘Šã‚’å‡ºã—ã¤ã¤ `0` ã«ã‚¯ãƒ©ãƒ³ãƒ—
- ã‚¯ãƒ©ãƒ³ãƒ—å¾Œã‚‚æ—¢å­˜ã®å‹ç¯„å›²ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã€å®‰å…¨æ€§ã‚’ç¶­æŒ
- `tests/cases/unsigned/runtime_clamp.cb` ã¨ `tests/integration/unsigned/test_unsigned.hpp` ã§å‹•ä½œã‚’æ¤œè¨¼

#### é…åˆ—å‹ã‚·ã‚¹ãƒ†ãƒ  âœ…/ğŸš§
##### é™çš„é…åˆ—ï¼ˆç¾åœ¨å®Ÿè£…æ¸ˆã¿ï¼‰
- `TYPE[SIZE]`: å›ºå®šã‚µã‚¤ã‚ºé…åˆ—
- å¤šæ¬¡å…ƒé…åˆ—å¯¾å¿œ: `int[10][20]`, `string[5][3][2]`
- **å‹å®‰å…¨æ€§**: 
  - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚µã‚¤ã‚ºæ¤œè¨¼: `int[2] arr = [1, 2, 3];` â†’ ã‚¨ãƒ©ãƒ¼
  - é–¢æ•°æˆ»ã‚Šå€¤ã‚µã‚¤ã‚ºæ¤œè¨¼: `int[5] arr = returnThreeElements();` â†’ ã‚¨ãƒ©ãƒ¼
  - æ˜ç¢ºãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æä¾›
- **å¤šæ¬¡å…ƒé…åˆ—æˆ»ã‚Šå€¤å‡¦ç†**ï¼ˆæ–°æ©Ÿèƒ½ï¼‰:
  - typedefé…åˆ—é–¢æ•°ã®å®Œå…¨å¯¾å¿œ: `Matrix2D create_matrix()`ç­‰
  - Variable Manageræ”¹å–„: é…åˆ—æˆ»ã‚Šå€¤ã§å…¨è¦ç´ å±•é–‹ãƒ»æ¬¡å…ƒæƒ…å ±è¨­å®š
  - å¢ƒç•Œãƒã‚§ãƒƒã‚¯å¼·åŒ–: multidim_array_valuesé…åˆ—ã®å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹
  - å‹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯: typedefåã¨é…åˆ—æ§‹é€ ã‹ã‚‰å¤šæ¬¡å…ƒé…åˆ—ã‚’æ­£ç¢ºã«è­˜åˆ¥

##### å‹•çš„é…åˆ—ï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰ğŸš§
- `TYPE[]`: å¯å¤‰ã‚µã‚¤ã‚ºé…åˆ—ï¼ˆGoã®sliceãƒ©ã‚¤ã‚¯ï¼‰
- **å…±é€šãƒ¡ã‚½ãƒƒãƒ‰**ï¼ˆInterface/Implã‚·ã‚¹ãƒ†ãƒ ã§å®Ÿè£…å¯èƒ½ï¼‰:
  - `.size()`: è¦ç´ æ•°å–å¾—
  - `.len()`: è¦ç´ æ•°å–å¾—ï¼ˆ.size()ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼‰
  - `.capacity()`: å®¹é‡å–å¾—
  - `.empty()`: ç©ºé…åˆ—åˆ¤å®š
- **å‹•çš„é…åˆ—å°‚ç”¨ãƒ¡ã‚½ãƒƒãƒ‰**:
  - `.push(value)`: æœ«å°¾ã«è¦ç´ è¿½åŠ 
  - `.pop()`: æœ«å°¾è¦ç´ å‰Šé™¤ãƒ»å–å¾—
  - `.clear()`: å…¨è¦ç´ å‰Šé™¤
  - `.reserve(size)`: å®¹é‡äºˆç´„
  - `.resize(size)`: ã‚µã‚¤ã‚ºå¤‰æ›´
- **å¢ƒç•Œãƒã‚§ãƒƒã‚¯**:
  - é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã®è‡ªå‹•å¢ƒç•Œæ¤œè¨¼
  - ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã®è©³ç´°ã‚¨ãƒ©ãƒ¼æƒ…å ±

#### ãƒã‚¤ãƒ³ã‚¿å‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®Ÿè£…ä¸­ï¼‰ ğŸš§
- å‹å®£è¨€: `T*`, `T**` ã®ã‚ˆã†ã« `*` ã‚’é‡ã­ã¦è¡¨è¨˜ã€‚æ—¢å­˜ã® `type_specifier` ã« `*` ã‚’ä»˜ä¸ã™ã‚‹ã ã‘ã§è¤‡æ•°æ®µãƒã‚¤ãƒ³ã‚¿ã‚’è¡¨ç¾ã§ãã‚‹ã€‚
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ `nullptr`ã€‚æœªåˆæœŸåŒ–ãƒã‚¤ãƒ³ã‚¿ã«ã¯è‡ªå‹•çš„ã« `nullptr` ãŒä»£å…¥ã•ã‚Œã‚‹ã€‚
- `new T` ã¯ `T*` ã‚’è¿”ã™å¼ã€`new T()` / `new T(args...)` ã§åˆæœŸåŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ‹¡å¼µã€‚
- `delete expr;` ã§è§£æ”¾ã€‚`nullptr` ã«å¯¾ã—ã¦ã¯å®‰å…¨ã€‚è§£æ”¾æˆåŠŸå¾Œã¯æš—é»™ã« `nullptr` ã‚’ä»£å…¥ã™ã‚‹ã€‚
- æ§‹é€ ä½“ãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã™ã‚‹ `.` ã‚¢ã‚¯ã‚»ã‚¹ã¯ 1 æ®µã®æš—é»™ãƒ‡ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚’è¡Œã†ï¼ˆ`ptr.member` â†’ `(*ptr).member`ï¼‰ã€‚å¿…è¦ã«å¿œã˜ã¦ `*ptr` ã‚’æ˜ç¤ºã—ã¦å¤šæ®µãƒ‡ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã™ã‚‹ã€‚
- `&expr` ã¨ `*expr` ã‚’å˜é …æ¼”ç®—å­ã¨ã—ã¦ã‚µãƒãƒ¼ãƒˆã€‚`sizeof(T)` ã¯å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º2ã§å¯¾å¿œã€‚
- æ§‹é€ ä½“ã®è‡ªå·±å†å¸°ãƒ»ç›¸äº’å†å¸°ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¡ãƒ³ãƒçµŒç”±ã®ã¿ã«é™å®šã—ã€å€¤ãƒ¡ãƒ³ãƒã§ã®ç„¡é™å†å¸°ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«æ¤œå‡ºã—ã¦ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹ã€‚
- **ãƒ¡ãƒ¢ãƒªç®¡ç†**:
  - RAIIåŸå‰‡ã«ã‚ˆã‚‹è‡ªå‹•ãƒ¡ãƒ¢ãƒªç®¡ç†
  - åŠ¹ç‡çš„ãªå†å‰²ã‚Šå½“ã¦æˆ¦ç•¥ï¼ˆcapacity doublingç­‰ï¼‰

##### é…åˆ—å‹å®‰å…¨æ€§ã®å°†æ¥å¼·åŒ– ğŸš§
- **å‹ãƒ¬ãƒ™ãƒ«ã§ã®ã‚µã‚¤ã‚ºæ¤œè¨¼**:
  ```cb
  int[3] a = [1, 2, 3];
  int[5] b = [1, 2, 3, 4, 5];
  a = b;  // ã‚¨ãƒ©ãƒ¼: ã‚µã‚¤ã‚ºãŒç•°ãªã‚‹é™çš„é…åˆ—é–“ã®ä»£å…¥ã¯ä¸å¯
  ```
- **é–¢æ•°å¼•æ•°ã§ã®å‹ãƒã‚§ãƒƒã‚¯**:
  ```cb
  void func(int[5] arr);  // 5è¦ç´ ã®é…åˆ—ã®ã¿å—ã‘å…¥ã‚Œ
  int[3] small_array = [1, 2, 3];
  func(small_array);  // ã‚¨ãƒ©ãƒ¼: ã‚µã‚¤ã‚ºä¸ä¸€è‡´
  ```
- **é…åˆ—ã‚¹ãƒ©ã‚¤ã‚¹æ“ä½œ**ï¼ˆå‹•çš„é…åˆ—ï¼‰:
  ```cb
  int[] arr = [1, 2, 3, 4, 5];
  int[] slice = arr[1:4];  // [2, 3, 4]ã‚’å–å¾—
  ```

#### å‹å®£è¨€æ–¹æ³• âœ…
```cb
TYPE å¤‰æ•°;                     // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§åˆæœŸåŒ–
TYPE å¤‰æ•° = å€¤;                // æ˜ç¤ºçš„åˆæœŸåŒ–
TYPE[SIZE] å¤‰æ•°;               // é…åˆ—å®£è¨€
TYPE[SIZE] å¤‰æ•° = {å€¤1, å€¤2, ...}; // é…åˆ—åˆæœŸåŒ–
TYPE[SIZE1][SIZE2] å¤‰æ•°;       // å¤šæ¬¡å…ƒé…åˆ—å®£è¨€
```

#### ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä¿®é£¾å­ âœ…
C/C++ã¨åŒç­‰ã®æ©Ÿèƒ½ã‚’æä¾›:
- `const`: å®šæ•°ã€å¤‰æ›´ä¸å¯ï¼ˆRustã®mutã®é€†ï¼‰
- `static`: é™çš„ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æœŸé–“
- `extern`: å¤–éƒ¨ãƒªãƒ³ã‚±ãƒ¼ã‚¸ï¼ˆå°†æ¥ã®moduleã‚·ã‚¹ãƒ†ãƒ ã¨é€£æºï¼‰

### é–¢æ•° âœ…
```cb
// voidé–¢æ•°ï¼ˆæˆ»ã‚Šå€¤ãªã—ï¼‰
void FUNC_NAME() { 
    // æ–‡;
}

// å€¤ã‚’è¿”ã™é–¢æ•°
TYPE FUNC_NAME(void) { 
    // æ–‡;
    return VALUE; 
}

// å¼•æ•°ã‚’å–ã‚‹é–¢æ•°
TYPE FUNC_NAME(TYPE ARG1, TYPE ARG2, ...) { 
    // æ–‡; 
    return VALUE; 
}
```
- VALUE ã®å‹ã¯ TYPE ã¨ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
- å¼•æ•°ã‚‚æˆ»ã‚Šå€¤ã‚‚é…åˆ—å‹ã«å¯¾å¿œ

### å‹å®£è¨€ãƒ»ä½œæˆ âœ…
```cb
// åŸºæœ¬å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
typedef æ—¢å­˜å‹ æ–°ã—ã„å‹å;

// Unionå‹å®£è¨€ï¼ˆTypeScripté¢¨ï¼‰
typedef Unionå‹å = å‹1 | å‹2 | å‹3 | ...;

// ä¾‹
typedef UserId = int;
typedef UserName = string;

// ãƒªãƒ†ãƒ©ãƒ«å€¤Union
typedef HttpStatus = 200 | 404 | 500;
typedef Direction = "up" | "down" | "left" | "right";

// åŸºæœ¬å‹Union
typedef NumericValue = int | long | string;

// ã‚«ã‚¹ã‚¿ãƒ å‹Union
typedef ID = UserId | ProductId;

// æ§‹é€ ä½“Union
typedef Entity = User | Product;

// é…åˆ—Union
typedef ArrayUnion = int[5] | string[3];

// æ··åˆUnionï¼ˆãƒªãƒ†ãƒ©ãƒ«å€¤ã¨å‹ã®çµ„ã¿åˆã‚ã›ï¼‰
typedef MixedUnion = 42 | int | string;
```

### Unionå‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®Œå…¨å®Ÿè£…ï¼‰ âœ…

#### TypeScripté¢¨Unionå‹æ§‹æ–‡
```cb
// ãƒªãƒ†ãƒ©ãƒ«å€¤Union - ç‰¹å®šã®å€¤ã®ã¿è¨±å¯
typedef HttpStatus = 200 | 404 | 500;
typedef Direction = "up" | "down" | "left" | "right";
typedef Priority = 1 | 2 | 3;

// åŸºæœ¬å‹Union - è¤‡æ•°ã®åŸºæœ¬å‹ã‚’çµ„ã¿åˆã‚ã›
typedef NumericValue = int | long | string;
typedef BoolOrString = bool | string;
typedef AnyBasic = int | string | bool;

// ã‚«ã‚¹ã‚¿ãƒ å‹Union - å®šç¾©ã—ãŸtypedefã‚’çµ„ã¿åˆã‚ã›
typedef UserID = int;
typedef ProductID = string;
typedef ID = UserID | ProductID;  // å†å¸°çš„typedefå¯¾å¿œ

// æ§‹é€ ä½“Union - ç•°ãªã‚‹æ§‹é€ ä½“å‹ã‚’çµ„ã¿åˆã‚ã›
struct User {
    int id;
    string name;
}

struct Product {
    string code;
    int price;
}

typedef Entity = User | Product;

// é…åˆ—Union - ç•°ãªã‚‹é…åˆ—å‹ã‚’çµ„ã¿åˆã‚ã›
typedef ArrayUnion = int[5] | string[3] | bool[2];
typedef MultiDimArrayUnion = int[3][3] | string[2][4];

// æ··åˆUnion - ãƒªãƒ†ãƒ©ãƒ«å€¤ã¨å‹ã‚’çµ„ã¿åˆã‚ã›
typedef MixedUnion = 42 | int | string;
typedef ComplexMixed = 200 | "success" | int | bool;
```

#### Unionå‹ã®å‹æ¤œè¨¼ã‚·ã‚¹ãƒ†ãƒ 
```cb
int main() {
    // ãƒªãƒ†ãƒ©ãƒ«å€¤Unionã®å³å¯†ãªæ¤œè¨¼
    HttpStatus status = 200;  // OK: è¨±å¯ã•ã‚ŒãŸãƒªãƒ†ãƒ©ãƒ«å€¤
    // HttpStatus invalid = 301;  // ã‚¨ãƒ©ãƒ¼: è¨±å¯ã•ã‚Œã¦ã„ãªã„å€¤
    
    // åŸºæœ¬å‹Unionã®ä½¿ç”¨
    NumericValue value1 = 42;        // intå€¤ -> OK
    NumericValue value2 = "hello";   // stringå€¤ -> OK
    // NumericValue invalid = true;  // boolå‹ -> ã‚¨ãƒ©ãƒ¼
    
    // ã‚«ã‚¹ã‚¿ãƒ å‹Unionã®å†å¸°çš„å‹æ¤œè¨¼
    UserID user_id = 12345;
    ID general_id = user_id;         // UserID -> ID: äº’æ›æ€§OK
    
    // æ§‹é€ ä½“Unionã®å‹äº’æ›æ€§
    User alice = {id: 1, name: "Alice"};
    Entity entity = alice;           // User -> Entity: OK
    
    // æ··åˆUnionã§ã®å‹æ¤œè¨¼
    MixedUnion mixed1 = 42;          // ãƒªãƒ†ãƒ©ãƒ«42 -> OK
    MixedUnion mixed2 = 100;         // intå‹ -> OK
    MixedUnion mixed3 = "test";      // stringå‹ -> OK
    // MixedUnion invalid = true;    // boolå‹ -> ã‚¨ãƒ©ãƒ¼
    
    return 0;
}
```

#### Unionå‹ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
Unionå‹ã‚·ã‚¹ãƒ†ãƒ ã¯13ç¨®é¡ã®åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼æ¤œè¨¼ã‚’æä¾›ï¼š

1. **ç„¡åŠ¹ãªãƒªãƒ†ãƒ©ãƒ«å€¤ã‚¨ãƒ©ãƒ¼**
```cb
typedef LimitedValues = 1 | 2 | 3;
LimitedValues val = 5;  // ã‚¨ãƒ©ãƒ¼: 5ã¯è¨±å¯ã•ã‚Œã¦ã„ãªã„
```

2. **å‹ä¸ä¸€è‡´ã‚¨ãƒ©ãƒ¼**
```cb
typedef IntOrString = int | string;
bool flag = true;
IntOrString val = flag;  // ã‚¨ãƒ©ãƒ¼: boolå‹ã¯è¨±å¯ã•ã‚Œã¦ã„ãªã„
```

3. **æœªå®šç¾©å‹ã‚¨ãƒ©ãƒ¼**
```cb
typedef BadUnion = int | UndefinedType;  // ã‚¨ãƒ©ãƒ¼: UndefinedTypeã¯å­˜åœ¨ã—ãªã„
```

4. **ã‚«ã‚¹ã‚¿ãƒ å‹äº’æ›æ€§ã‚¨ãƒ©ãƒ¼**
```cb
typedef UserID = int;
typedef ProductID = string;
typedef RestrictedID = UserID;  // ProductIDã¯è¨±å¯ã•ã‚Œãªã„

ProductID pid = "P123";
RestrictedID rid = pid;  // ã‚¨ãƒ©ãƒ¼: ProductID -> UserIDã®å¤‰æ›ã¯ä¸å¯
```

5. **æ§‹é€ ä½“å‹ã‚¨ãƒ©ãƒ¼**
```cb
struct User { int id; }
struct Product { string code; }
typedef UserOnly = User;

Product prod = {"P123"};
UserOnly user_val = prod;  // ã‚¨ãƒ©ãƒ¼: Product -> Userã®å¤‰æ›ã¯ä¸å¯
```

6. **é…åˆ—å‹ä¸ä¸€è‡´ã‚¨ãƒ©ãƒ¼**
```cb
typedef IntArrayUnion = int[3];
string[3] str_arr = ["a", "b", "c"];
IntArrayUnion arr = str_arr;  // ã‚¨ãƒ©ãƒ¼: string[3] -> int[3]ã¯ä¸å¯
```

**ç‰¹å¾´**:
- **TypeScripté¢¨ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹**: ç›´æ„Ÿçš„ãªUnionå‹æ§‹æ–‡
- **å³å¯†ãªå‹æ¤œè¨¼**: ãƒªãƒ†ãƒ©ãƒ«å€¤ã¨æ˜ç¤ºçš„å‹ã®æ˜ç¢ºãªåŒºåˆ¥
- **å†å¸°çš„typedefå¯¾å¿œ**: UserID -> ID -> int ã®ã‚ˆã†ãªç¶™æ‰¿ãƒã‚§ãƒ¼ãƒ³
- **åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼å‡¦ç†**: 13ç¨®é¡ã®ç•°å¸¸ç³»ã‚’å®Œå…¨ã«ã‚«ãƒãƒ¼
- **å®Ÿè¡Œæ™‚å‹å®‰å…¨æ€§**: ä¸æ­£ãªå‹ä»£å…¥ã‚’å®Ÿè¡Œæ™‚ã«æ¤œå‡º
- **æ··åˆUnionå¯¾å¿œ**: ãƒªãƒ†ãƒ©ãƒ«å€¤ã¨å‹ã‚’è‡ªç”±ã«çµ„ã¿åˆã‚ã›å¯èƒ½

#### åŸºæœ¬æ§‹é€ ä½“ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰âœ…
```cb
struct æ§‹é€ ä½“å { 
    TYPE ãƒ¡ãƒ³ãƒ1; 
    TYPE ãƒ¡ãƒ³ãƒ2;
    TYPE[SIZE] é…åˆ—ãƒ¡ãƒ³ãƒ;
    // ...
}

// ä½¿ç”¨ä¾‹
struct Person {
    string name;
    int age;
    int grades[5];
    bool is_active;
}

int main() {
    Person p;
    p.name = "Alice";
    p.age = 25;
    p.is_active = true;
    
    // é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼ã®å€‹åˆ¥ä»£å…¥
    p.grades[0] = 85;
    p.grades[1] = 92;
    
    // é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ä»£å…¥
    p.grades = [85, 92, 78, 90, 88];
    
    return 0;
}
```

#### æ§‹é€ ä½“ãƒªãƒ†ãƒ©ãƒ«åˆæœŸåŒ–ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰âœ…
```cb
struct Point {
    int x;
    int y;
    string label;
}

int main() {
    // åå‰ä»˜ãåˆæœŸåŒ–
    Point p1 = {x: 10, y: 20, label: "Origin"};
    
    // æœ«å°¾ã‚«ãƒ³ãƒå¯¾å¿œ
    Point p2 = {x: 5, y: 15, };
    
    // ä½ç½®æŒ‡å®šåˆæœŸåŒ–
    Point p3 = {30, 40, "Target"};
    
    // æ§‹é€ ä½“é…åˆ—åˆæœŸåŒ–
    Point[3] points = [
        {x: 0, y: 0, label: "Start"},
        {10, 10, "Middle"},
        {x: 20, y: 20, label: "End"}
    ];
    
    return 0;
}
```

#### æ§‹é€ ä½“é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰âœ…
```cb
struct Matrix {
    string name;
    int data[6];  // 1æ¬¡å…ƒé…åˆ—ã¨ã—ã¦ä½¿ç”¨
    int rows;
    int cols;
}

struct Matrix3D {
    string name;
    int[3][3] data;  // çœŸã®å¤šæ¬¡å…ƒé…åˆ—ãƒ¡ãƒ³ãƒãƒ¼
    int size;
}

int main() {
    // 1æ¬¡å…ƒé…åˆ—ãƒ¡ãƒ³ãƒãƒ¼
    Matrix m;
    m.name = "Sample Matrix";
    m.rows = 2;
    m.cols = 3;
    
    // é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ä»£å…¥
    m.data = [1, 2, 3, 4, 5, 6];
    
    // å€‹åˆ¥è¦ç´ ä»£å…¥
    m.data[0] = 10;
    m.data[5] = 60;
    
    // å¤šæ¬¡å…ƒé…åˆ—ãƒ¡ãƒ³ãƒãƒ¼
    Matrix3D mat3d;
    mat3d.name = "3D Matrix";
    mat3d.size = 3;
    
    // å¤šæ¬¡å…ƒé…åˆ—ãƒªãƒ†ãƒ©ãƒ«ä»£å…¥
    mat3d.data = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    // å€‹åˆ¥è¦ç´ ã‚¢ã‚¯ã‚»ã‚¹
    mat3d.data[0][0] = 100;
    mat3d.data[2][2] = 900;
    
    // printfçµ±åˆ
    print("Matrix %s: [%d, %d, %d]", m.name, m.data[0], m.data[1], m.data[2]);
    print("3D Matrix %s [0][0]: %d", mat3d.name, mat3d.data[0][0]);
    
    return 0;
}
```

#### æ§‹é€ ä½“ã®é…åˆ—ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰âœ…
```cb
struct Employee {
    string name;
    int salary;
    int department_id;
}

int main() {
    Employee team[3];
    
    // æ§‹é€ ä½“é…åˆ—ãƒªãƒ†ãƒ©ãƒ«åˆæœŸåŒ–
    team[0] = {name: "Alice", salary: 50000, department_id: 0};
    team[1] = {name: "Bob", salary: 55000, department_id: 2};
    team[2] = {name: "Charlie", salary: 60000, department_id: 1};
    
    // é…åˆ—è¦ç´ ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹
    print("Employee: %s, Salary: $%d", team[0].name, team[0].salary);
    
    return 0;
}
```

#### æœªå®Ÿè£…æ©Ÿèƒ½ ğŸš§/âŒ

##### ãƒã‚¹ãƒˆã—ãŸæ§‹é€ ä½“ï¼ˆæœªå®Ÿè£…ï¼‰âŒ
```cb
struct Address {
    string street;
    string city;
    int zipcode;
}

struct Company {
    string name;
    Address address;  // âŒ ãƒã‚¹ãƒˆã—ãŸæ§‹é€ ä½“æœªã‚µãƒãƒ¼ãƒˆ
    int employee_count;
}

int main() {
    Company tech_corp;
    tech_corp.name = "Tech Corp";
    
    // âŒ ã‚¨ãƒ©ãƒ¼: ãƒã‚¹ãƒˆã—ãŸãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹æœªã‚µãƒãƒ¼ãƒˆ
    tech_corp.address.street = "123 Main St";
    
    return 0;
}
```

##### æ§‹é€ ä½“ã®é–¢æ•°å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰âœ…
```cb
struct Rectangle {
    int width;
    int height;
}

struct Point {
    int x;
    int y;
}

// âœ… æ§‹é€ ä½“å¼•æ•°ï¼ˆå€¤æ¸¡ã—ï¼‰
int calculate_area(Rectangle rect) {
    return rect.width * rect.height;
}

// âœ… æ§‹é€ ä½“æˆ»ã‚Šå€¤
Rectangle create_rectangle(int w, int h) {
    Rectangle r = {width: w, height: h};
    return r;
}

// âœ… è¤‡æ•°æ§‹é€ ä½“å¼•æ•°
Point add_points(Point a, Point b) {
    Point result;
    result.x = a.x + b.x;
    result.y = a.y + b.y;
    return result;
}

int main() {
    Rectangle rect = create_rectangle(10, 5);
    int area = calculate_area(rect);
    
    Point p1 = {x: 3, y: 4};
    Point p2 = {x: 1, y: 2};
    Point sum = add_points(p1, p2);
    
    print("Area: %d, Sum: (%d, %d)", area, sum.x, sum.y);
    return 0;
}
```

##### æ§‹é€ ä½“ç¶™æ‰¿ï¼ˆæœªå®Ÿè£…ï¼‰âŒ
```cb
// ç¶™æ‰¿ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
struct æ´¾ç”Ÿæ§‹é€ ä½“å extends åŸºåº•æ§‹é€ ä½“å { 
    TYPE è¿½åŠ ãƒ¡ãƒ³ãƒ;
    // ...
}
```

##### è¤‡é›‘ãªãƒã‚¹ãƒˆã—ãŸé…åˆ—ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆæœªå®Ÿè£…ï¼‰âŒ
```cb
struct Student {
    string name;
    int grades[3];
}

struct Course {
    Student students[2];
}

int main() {
    Course math_course;
    
    // âŒ ã‚¨ãƒ©ãƒ¼: æ§‹é€ ä½“é…åˆ—ã®æ§‹é€ ä½“ãƒ¡ãƒ³ãƒãƒ¼é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹
    math_course.students[0].grades[0] = 85;
    
    return 0;
}
```

**ç¾åœ¨ã®åˆ¶é™äº‹é …**:
- ãƒã‚¹ãƒˆã—ãŸæ§‹é€ ä½“ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹ (`obj.member.submember`) ã¯æœªã‚µãƒãƒ¼ãƒˆ
- è¤‡é›‘ãªãƒã‚¹ãƒˆã—ãŸé…åˆ—ã‚¢ã‚¯ã‚»ã‚¹ (`obj.array[i].member[j]`) ã¯æœªã‚µãƒãƒ¼ãƒˆ
- æ§‹é€ ä½“ç¶™æ‰¿ã¯æœªå®Ÿè£…

**å›é¿ç­–**:
- ãƒ•ãƒ©ãƒƒãƒˆæ§‹é€ ä½“ã‚’ä½¿ç”¨ã—ã¦ãƒã‚¹ãƒˆã‚’é¿ã‘ã‚‹
- æ§‹é€ ä½“ãƒ¡ãƒ³ãƒãƒ¼ã¯é–¢æ•°å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã¨ã—ã¦å®Œå…¨å¯¾å¿œæ¸ˆã¿

### åˆ—æŒ™å‹ ğŸš§
Cã€TypeScriptãƒ©ã‚¤ã‚¯ãªåˆ—æŒ™å‹:
```cb  
enum Color {
    RED,
    GREEN, 
    BLUE
}

enum Status {
    SUCCESS = 0,
    ERROR = 1,
    PENDING = 2
}
```

### ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾© âœ…
é–¢æ•°ã‚·ã‚°ãƒãƒãƒ£ã‚’ã¾ã¨ã‚ã¦å®šç¾©:
```cb
interface Drawable {
    void draw();
    void move(int x, int y);
    int getArea();
}

// æ³¨æ„: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ç¶™æ‰¿ï¼ˆextendsï¼‰ã¯æœªå®Ÿè£…
// è¤‡æ•°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…ã¯ã‚µãƒãƒ¼ãƒˆæ¸ˆã¿
```

### ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£… âœ…
```cb
impl Drawable for Rectangle {
    void draw() {
        // å®Ÿè£…
    }
    
    void move(int x, int y) {
        self.x = x;
        self.y = y;
    }
    
    int getArea() {
        return self.width * self.height;
    }
}
```

### ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆ âŒ
Rustãƒ©ã‚¤ã‚¯ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰:
```cb
#[no_std]           // æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ãªã„
#[derive(Debug)]    // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ã®è‡ªå‹•å®Ÿè£…
#[derive(Copy)]     // ã‚³ãƒ”ãƒ¼ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®è‡ªå‹•å®Ÿè£…
#[derive(Eq)]       // ç­‰ä¾¡æ¯”è¼ƒã®è‡ªå‹•å®Ÿè£…
struct Point {
    int x;
    int y;
}
```

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ  âŒ
Rustã®module + TypeScriptã®import/export:

#### ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
```cb
export TYPE;                    // å‹ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export å¤‰æ•°;                    // å¤‰æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ  
export é–¢æ•°å®£è¨€;                // é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export é–¢æ•° { /* å®Ÿè£… */ };     // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³é–¢æ•°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export interface ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å; // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰
export { å®£è¨€1, å®£è¨€2, ... };   // è¤‡æ•°ã¾ã¨ã‚ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ  
export default å®£è¨€;            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
```

#### ã‚¤ãƒ³ãƒãƒ¼ãƒˆ  
```cb
import file;                              // å…¨ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import folder.file;                       // ãƒ‘ã‚¹æŒ‡å®šã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import folder.file.specific_item;         // å€‹åˆ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import folder.file.{ item1, item2, ... }; // è¤‡æ•°å€‹åˆ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
```

#### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®£è¨€
```cb
mod module_name {
    // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…å®¹
}
```

### ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ  ğŸš§

#### Resultå‹ï¼ˆæ¨å¥¨ï¼‰
```cb
// Resultå‹ã®å®šç¾©ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
enum Result<T, E> {
    Ok(T),
    Err(E)
}

// ä½¿ç”¨ä¾‹
Result<int, string> divide(int a, int b) {
    if (b == 0) {
        return Err("Division by zero");
    }
    return Ok(a / b);
}

// ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†
int main() {
    Result<int, string> result = divide(10, 2);
    match result {
        Ok(value) => print("Result: %d", value),
        Err(error) => print("Error: %s", error)
    }
    return 0;
}
```

#### ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ï¼ˆè»½é‡ãƒ¢ãƒ¼ãƒ‰ï¼‰
```cb
// ç¾åœ¨ã®å®Ÿè£…ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
int divide(int a, int b, int* result) {
    if (b == 0) {
        return -1; // ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
    }
    *result = a / b;
    return 0; // æˆåŠŸ
}
```

### ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªç®¡ç† ğŸš§
```cb
// unique_ptr - æ’ä»–çš„æ‰€æœ‰æ¨©ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
unique_ptr<MyStruct> ptr = make_unique<MyStruct>();
ptr->member = 42;
// è‡ªå‹•çš„ã«ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ã€ãƒ¡ãƒ¢ãƒªè§£æ”¾

// shared_ptr - å…±æœ‰æ‰€æœ‰æ¨©ï¼ˆå°†æ¥å®Ÿè£…ï¼‰  
shared_ptr<MyStruct> ptr1 = make_shared<MyStruct>();
shared_ptr<MyStruct> ptr2 = ptr1; // å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ+1
// æœ€å¾Œã®å‚ç…§ãŒæ¶ˆãˆãŸæ™‚ã«è‡ªå‹•ãƒ¡ãƒ¢ãƒªè§£æ”¾

// weak_ptr - å¼±å‚ç…§ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
weak_ptr<MyStruct> weak = ptr1;
if (auto locked = weak.lock()) {
    // æœ‰åŠ¹ãªå ´åˆã®ã¿ã‚¢ã‚¯ã‚»ã‚¹
}
```

## æ¨™æº–æ©Ÿèƒ½

### æ¨™æº–å‡ºåŠ› âœ…
Cã®printfãƒ©ã‚¤ã‚¯ãªé–¢æ•°ã‚’æä¾›:

#### printé–¢æ•°
```cb
// åŸºæœ¬çš„ãªå€¤å‡ºåŠ›ï¼ˆæ”¹è¡Œãªã—ï¼‰
print(42);              // "42"
print("Hello");         // "Hello"
print(variable);        // å¤‰æ•°ã®å€¤

// printfé¢¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­å¯¾å¿œï¼ˆæ¨å¥¨ï¼‰
print("%d", 42);        // "42"
print("%s", "Hello");   // "Hello"  
print("%c", 'A');       // "A"
print("%d + %d = %d", 10, 20, 30);  // "10 + 20 = 30"
```

#### ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­
- `%d`: æ•´æ•°ï¼ˆtiny, short, intï¼‰
- `%lld`: é•·æ•´æ•°ï¼ˆlongï¼‰
- `%s`: æ–‡å­—åˆ—ï¼ˆstringï¼‰
- `%c`: æ–‡å­—ï¼ˆcharï¼‰
- `%%`: ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆè¨˜å·ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—

#### æ³¨æ„äº‹é …
- ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯å¿…ãšå¼•æ•°ã‚’æŒ‡å®š
- å¼•æ•°ãªã—ã®å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šå­ã¯ç„¡è¦–ã•ã‚Œã‚‹

### åˆ¶å¾¡æ§‹é€  âœ…

#### ãƒ«ãƒ¼ãƒ—
```cb
// foræ–‡
for (int i = 0; i < 10; i++) {
    print(i);
}

// whileæ–‡
while (condition) {
    if (break_condition) break;
}
```

#### æ¡ä»¶åˆ†å²
```cb
// if-elseæ–‡
if (condition) {
    // thenç¯€
} else if (other_condition) {
    // else ifç¯€
} else {
    // elseç¯€
}
```

## é«˜åº¦ãªæ©Ÿèƒ½ï¼ˆé•·æœŸè¨ˆç”»ï¼‰

### ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° âŒ
Goãƒ©ã‚¤ã‚¯ãªgoroutine + channel:
```cb
// goroutineï¼ˆè»½é‡ã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰
go my_function(args);

// channelï¼ˆé€šä¿¡ãƒãƒ£ãƒãƒ«ï¼‰
chan<int> ch = make_chan<int>();
```

### ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ âŒ
```cb
// ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°
T max<T>(T a, T b) where T: Comparable {
    return (a > b) ? a : b;
}
```

## ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ»å®Ÿè¡Œã‚ªãƒ—ã‚·ãƒ§ãƒ³

### ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ¢ãƒ¼ãƒ‰é¸æŠ
```bash
# Resultå‹ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
cb-compile --error-handling=result program.cb

# ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ï¼ˆè»½é‡ï¼‰  
cb-compile --error-handling=codes program.cb
```

### ãƒ¡ãƒ¢ãƒªç®¡ç†è¨­å®š
```bash
# RAII + ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
cb-compile --memory=smart program.cb

# æ‰‹å‹•ç®¡ç†ï¼ˆçµ„ã¿è¾¼ã¿å‘ã‘ï¼‰
cb-compile --memory=manual program.cb
```

## å®Ÿè£…ä¾‹ãƒ»ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«

### Hello World
```cb
int main() {
    print("Hello, World!");
    return 0;
}
```

### è¤‡åˆä»£å…¥æ¼”ç®—å­ã¨ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ âœ…
```cb
int main() {
    // ç®—è¡“è¤‡åˆä»£å…¥æ¼”ç®—å­
    int a = 10;
    a += 5;     // a = a + 5 â†’ 15
    a -= 3;     // a = a - 3 â†’ 12  
    a *= 2;     // a = a * 2 â†’ 24
    a /= 4;     // a = a / 4 â†’ 6
    a %= 5;     // a = a % 5 â†’ 1
    
    // ãƒ“ãƒƒãƒˆæ¼”ç®—è¤‡åˆä»£å…¥æ¼”ç®—å­
    int b = 12; // 1100 (binary)
    b &= 10;    // b = b & 10 â†’ 8 (1000)
    b |= 3;     // b = b | 3 â†’ 11 (1011)
    b ^= 5;     // b = b ^ 5 â†’ 14 (1110)
    
    // ã‚·ãƒ•ãƒˆæ¼”ç®—è¤‡åˆä»£å…¥æ¼”ç®—å­
    int c = 4;
    c <<= 2;    // c = c << 2 â†’ 16
    c >>= 3;    // c = c >> 3 â†’ 2
    
    // é…åˆ—è¦ç´ ã¸ã®è¤‡åˆä»£å…¥ï¼ˆé«˜åº¦ãªä½¿ç”¨æ³•ï¼‰
    int[5] arr = [1, 2, 3, 4, 5];
    arr[0] += 10;           // åŸºæœ¬çš„ãªé…åˆ—è¦ç´ è¤‡åˆä»£å…¥
    arr[1] *= arr[2];       // é…åˆ—è¦ç´ åŒå£«ã®è¨ˆç®—
    arr[i*2+1] += (x+y);    // è¤‡é›‘ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ã¨åˆæœŸåŒ–å¼
    
    // å‰ç½®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    int x = 5;
    ++x;        // x = 6 (å€¤ã‚’å¤‰æ›´ã—ã¦ã‹ã‚‰ä½¿ç”¨)
    --x;        // x = 5 (å€¤ã‚’å¤‰æ›´ã—ã¦ã‹ã‚‰ä½¿ç”¨)
    
    // å¾Œç½®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼ˆæ–‡ã¨ã—ã¦ï¼‰
    x++;        // x = 6 (ä½¿ç”¨ã—ã¦ã‹ã‚‰å€¤ã‚’å¤‰æ›´)
    x--;        // x = 5 (ä½¿ç”¨ã—ã¦ã‹ã‚‰å€¤ã‚’å¤‰æ›´)
    
    // è‡ªå·±ä»£å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³
    x = x;         // å®Œå…¨ãªè‡ªå·±ä»£å…¥
    x = x + 10;    // è‡ªå·±å‚ç…§ã«ã‚ˆã‚‹è¨ˆç®—
    x = x << 1;    // ãƒ“ãƒƒãƒˆæ¼”ç®—ã«ã‚ˆã‚‹è‡ªå·±ä»£å…¥
    // x = x & 0xFF;  // TODO: ãƒ“ãƒƒãƒˆãƒã‚¹ã‚¯ã«ã‚ˆã‚‹è‡ªå·±ä»£å…¥
    
    // ã™ã¹ã¦ã®è¤‡åˆä»£å…¥æ¼”ç®—å­ã¯å³ã‹ã‚‰å·¦ã¸ã®çµåˆï¼ˆå³çµåˆï¼‰
    // a += b += c; ã¯ a += (b += c); ã¨è§£é‡ˆã•ã‚Œã‚‹
    
    return 0;
}
```

### Interface/Impl ã‚·ã‚¹ãƒ†ãƒ  âœ…
```cb
// Interface declaration with method signatures
interface Drawable {
    void draw();
    void clear();
}

// Primitive type implementation
impl Drawable for int {
    void draw() {
        println("Drawing number: %d", self);
    }
    
    void clear() {
        println("Clearing number display");
    }
}

// Struct implementation
struct Circle {
    int x, y;
    int radius;
}

impl Drawable for Circle {
    void draw() {
        println("Drawing circle at (%d, %d) with radius %d", 
                self.x, self.y, self.radius);
    }
    
    void clear() {
        println("Clearing circle");
    }
}

// Array implementation
impl Drawable for int[] {
    void draw() {
        print("Drawing array: [");
        for (int i = 0; i < len(self); i++) {
            if (i > 0) print(", ");
            print("%d", self[i]);
        }
        println("]");
    }
    
    void clear() {
        println("Clearing array display");
    }
}

// Recursive typedef with interface implementation
typedef TreeNode {
    int value;
    TreeNode* left;
    TreeNode* right;
}

impl Drawable for TreeNode {
    void draw() {
        println("Drawing tree node with value: %d", self.value);
        if (self.left != null) {
            println("  Left child exists");
        }
        if (self.right != null) {
            println("  Right child exists");
        }
    }
    
    void clear() {
        println("Clearing tree node");
    }
}

int main() {
    // Primitive type usage
    int number = 42;
    number.draw();      // "Drawing number: 42"
    number.clear();     // "Clearing number display"
    
    // Struct usage
    Circle circle;
    circle.x = 10;
    circle.y = 20;
    circle.radius = 5;
    circle.draw();      // "Drawing circle at (10, 20) with radius 5"
    circle.clear();     // "Clearing circle"
    
    // Array usage
    int[3] numbers = [1, 2, 3];
    numbers.draw();     // "Drawing array: [1, 2, 3]"
    numbers.clear();    // "Clearing array display"
    
    // Recursive typedef usage
    TreeNode root;
    root.value = 100;
    root.left = null;
    root.right = null;
    root.draw();        // "Drawing tree node with value: 100"
    root.clear();       // "Clearing tree node"
    
    return 0;
}
```

### Interface/Impl ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° âœ…
```cb
// ã‚¨ãƒ©ãƒ¼æ¤œå‡ºä¾‹ï¼šæœªå®Ÿè£…ãƒ¡ã‚½ãƒƒãƒ‰
interface Calculator {
    int add(int a, int b);
    int multiply(int a, int b);
}

impl Calculator for int {
    int add(int a, int b) {
        return a + b;
    }
    // multiply ãƒ¡ã‚½ãƒƒãƒ‰ãŒæœªå®Ÿè£… â†’ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
}

// ã‚¨ãƒ©ãƒ¼æ¤œå‡ºä¾‹ï¼šå‹ãƒŸã‚¹ãƒãƒƒãƒ
interface Formatter {
    void format();
}

impl Formatter for int {
    int format() {  // æˆ»ã‚Šå€¤å‹ãŒ void ã§ãªã„ â†’ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
        return 0;
    }
}

// ã‚¨ãƒ©ãƒ¼æ¤œå‡ºä¾‹ï¼šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒŸã‚¹ãƒãƒƒãƒ
interface Processor {
    void process(int value);
}

impl Processor for int {
    void process(double value) {  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ãŒä¸€è‡´ã—ãªã„ â†’ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
        println("Processing: %f", value);
    }
}
```

### è‡ªå·±ä»£å…¥æ©Ÿèƒ½ã®åŒ…æ‹¬å®Ÿè£… âœ…
```cb
int main() {
    // åŸºæœ¬çš„ãªè‡ªå·±ä»£å…¥
    int value = 5;
    value = value;              // å®Œå…¨ãªè‡ªå·±ä»£å…¥
    value = value + 5;          // è‡ªå·±å‚ç…§åŠ ç®— â†’ 10
    value = value * 3;          // è‡ªå·±å‚ç…§ä¹—ç®— â†’ 30
    
    println("Basic self-assignment: %d", value);
    
    // é…åˆ—è¦ç´ ã®è‡ªå·±ä»£å…¥
    int[3] numbers;
    numbers[0] = 2;
    numbers[1] = 4; 
    numbers[2] = 6;
    
    // é…åˆ—è¦ç´ åŒå£«ã®è‡ªå·±ä»£å…¥
    numbers[0] = numbers[0] * 2;        // 2 * 2 = 4
    numbers[1] = numbers[1] + numbers[0]; // 4 + 4 = 8
    numbers[2] = numbers[2] - numbers[1]; // 6 - 8 = -2
    
    for (int i = 0; i < 3; i++) {
        println("numbers[%d] = %d", i, numbers[i]);
    }
    
    // ãƒ“ãƒƒãƒˆæ¼”ç®—ã«ã‚ˆã‚‹è‡ªå·±ä»£å…¥
    int bits = 12;  // 1100 in binary
    bits = bits & 5;    // 12 & 5 = 1100 & 0101 = 0100 = 4
    bits = bits | 8;    // 4 | 8 = 0100 | 1000 = 1100 = 12
    bits = bits ^ 3;    // 12 ^ 3 = 1100 ^ 0011 = 1111 = 15
    bits = bits << 1;   // 15 << 1 = 1111 << 1 = 11110 = 30
    bits = bits >> 2;   // 30 >> 2 = 11110 >> 2 = 0111 = 7
    
    println("Bitwise self-assignment result: %d", bits);
    
    // è¤‡åˆä»£å…¥æ¼”ç®—å­ï¼ˆè‡ªå·±ä»£å…¥ã®çœç•¥å½¢ï¼‰
    int compound = 10;
    compound += compound;    // compound = compound + compound = 20
    compound *= 2;          // compound = compound * 2 = 40  
    compound >>= 1;         // compound = compound >> 1 = 20
    compound &= 15;         // compound = compound & 15 = 4
    
    println("Compound self-assignment result: %d", compound);
    
    return 0;
}
```

**ã‚µãƒãƒ¼ãƒˆã™ã‚‹è¤‡åˆä»£å…¥æ¼”ç®—å­ï¼ˆ10ç¨®é¡ï¼‰**:
1. `+=` - åŠ ç®—ä»£å…¥
2. `-=` - æ¸›ç®—ä»£å…¥  
3. `*=` - ä¹—ç®—ä»£å…¥
4. `/=` - é™¤ç®—ä»£å…¥
5. `%=` - å‰°ä½™ä»£å…¥
6. `&=` - ãƒ“ãƒƒãƒˆè«–ç†ç©ä»£å…¥
7. `|=` - ãƒ“ãƒƒãƒˆè«–ç†å’Œä»£å…¥
8. `^=` - ãƒ“ãƒƒãƒˆæ’ä»–çš„è«–ç†å’Œä»£å…¥
9. `<<=` - å·¦ã‚·ãƒ•ãƒˆä»£å…¥
10. `>>=` - å³ã‚·ãƒ•ãƒˆä»£å…¥

**ç‰¹å¾´**:
- ã™ã¹ã¦ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ï¼ˆtiny, short, int, longï¼‰ã«å¯¾å¿œ
- é…åˆ—è¦ç´ ã¸ã®è¤‡åˆä»£å…¥ã‚µãƒãƒ¼ãƒˆ
- è¤‡é›‘ãªå¼ã§ã®è¤‡åˆä»£å…¥ã‚µãƒãƒ¼ãƒˆ
- å‹å®‰å…¨æ€§ã‚’ä¿ã£ãŸè‡ªå‹•å‹å¤‰æ›

### å‹ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬
```cb
int main() {
    // æ•´æ•°å‹
    tiny small_num = 42;        // -128ã€œ127
    short medium_num = 1000;    // -32768ã€œ32767
    int large_num = 100000;     // -2^31ã€œ2^31-1
    long huge_num = 1000000000; // -2^63ã€œ2^63-1
    
    // æ–‡å­—å‹
    char letter = 'A';
    char newline = '\n';
    char tab = '\t';
    
    // æ–‡å­—åˆ—å‹
    string message = "Cbè¨€èª";
    
    // è«–ç†å‹
    bool flag = true;
    
    // å‹åˆ¥ã®å‡ºåŠ›
    print("tiny: %d", small_num);
    print("short: %d", medium_num);
    print("int: %d", large_num);
    print("long: %lld", huge_num);
    print("char: %c", letter);
    print("string: %s", message);
    
    return 0;
}
```

### é…åˆ—ã®åŸºæœ¬æ“ä½œ
```cb
int main() {
    // é…åˆ—å®£è¨€ã¨åˆæœŸåŒ–
    int[5] numbers = [10, 20, 30, 40, 50];
    string[3] names = ["Alice", "Bob", "Charlie"];
    char[4] chars = ['A', 'B', 'C', 'D'];
    
    // é…åˆ—è¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
    print("numbers[0] = %d", numbers[0]);
    print("names[1] = %s", names[1]);
    print("chars[2] = %c", chars[2]);
    
    // é…åˆ—è¦ç´ ã®å¤‰æ›´ï¼ˆè¤‡åˆä»£å…¥æ¼”ç®—å­ä½¿ç”¨ï¼‰
    numbers[0] += 90;        // numbers[0] = 100
    names[1] = "Bobby";      // æ–‡å­—åˆ—ä»£å…¥
    chars[2] = 'Z';          // æ–‡å­—ä»£å…¥
    
    // é…åˆ—ã®è¤‡åˆä»£å…¥æ¼”ç®—å­ã®æ´»ç”¨
    for (int i = 0; i < 5; i++) {
        numbers[i] *= 2;     // å„è¦ç´ ã‚’2å€
        print("numbers[%d] = %d", i, numbers[i]);
    }
    
    return 0;
}
```

### é–¢æ•°ã®å®šç¾©ã¨å‘¼ã³å‡ºã—
```cb
// å€¤ã‚’è¿”ã•ãªã„é–¢æ•°
void print_separator() {
    print("===================");
}

// å€¤ã‚’è¿”ã™é–¢æ•°
int add(int a, int b) {
    return a + b;
}

// é…åˆ—ã‚’å¼•æ•°ã«å–ã‚‹é–¢æ•°ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
int sum_array(int[] arr, int size) {
    int total = 0;
    for (int i = 0; i < size; i++) {
        total += arr[i];  // è¤‡åˆä»£å…¥æ¼”ç®—å­ã‚’ä½¿ç”¨
    }
    return total;
}

// æ–‡å­—åˆ—ã‚’æ‰±ã†é–¢æ•°
string greet(string name) {
    return "Hello, " + name + "!"; // æ–‡å­—åˆ—é€£çµã¯å°†æ¥å®Ÿè£…
}

int main() {
    print_separator();
    
    int result = add(10, 20);
    print("10 + 20 = %d", result);
    
    print_separator();
    
    return 0;
}
```

### åˆ¶å¾¡æ§‹é€ ã®æ´»ç”¨
```cb
int main() {
    // if-elseæ–‡
    int score = 85;
    char grade;
    
    if (score >= 90) {
        grade = 'A';
    } else if (score >= 80) {
        grade = 'B';
    } else if (score >= 70) {
        grade = 'C';
    } else {
        grade = 'F';
    }
    
    print("ã‚¹ã‚³ã‚¢: %d, ã‚°ãƒ¬ãƒ¼ãƒ‰: %c", score, grade);
    
    // whileæ–‡ï¼ˆå¾Œç½®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆä½¿ç”¨ï¼‰
    int count = 0;
    while (count < 5) {
        print("ã‚«ã‚¦ãƒ³ãƒˆ: %d", count);
        count++;  // å¾Œç½®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    }
    
    // foræ–‡ï¼ˆè¤‡åˆä»£å…¥æ¼”ç®—å­ä½¿ç”¨ï¼‰
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            print("%d ã¯å¶æ•°", i);
        } else {
            print("%d ã¯å¥‡æ•°", i);
        }
    }
    
    // è¤‡åˆä»£å…¥æ¼”ç®—å­ã‚’ä½¿ã£ãŸè¨ˆç®—
    int sum = 0;
    for (int j = 1; j <= 100; j++) {
        sum += j;  // sum = sum + j ã¨åŒç­‰
    }
    print("1ã‹ã‚‰100ã¾ã§ã®åˆè¨ˆ: %d", sum);
    
    return 0;
}
```

### constä¿®é£¾å­ã®ä½¿ç”¨
```cb
int main() {
    // å®šæ•°ã®å®£è¨€
    const int MAX_USERS = 100;
    const string SYSTEM_NAME = "Cb System";
    const char SEPARATOR = '-';
    
    // é…åˆ—ã‚µã‚¤ã‚ºã«constå€¤ã‚’ä½¿ç”¨
    int[MAX_USERS] user_ids;
    
    // consté…åˆ—
    const int[3] PRIME_NUMBERS = [2, 3, 5];
    
    print("ã‚·ã‚¹ãƒ†ãƒ å: %s", SYSTEM_NAME);
    print("æœ€å¤§ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°: %d", MAX_USERS);
    print("åŒºåˆ‡ã‚Šæ–‡å­—: %c", SEPARATOR);
    
    for (int i = 0; i < 3; i++) {
        print("ç´ æ•°[%d] = %d", i, PRIME_NUMBERS[i]);
    }
    
    return 0;
}
```

### å¤šæ¬¡å…ƒé…åˆ—æˆ»ã‚Šå€¤å‡¦ç†ï¼ˆæ–°æ©Ÿèƒ½ï¼‰ âœ…
```cb
// typedefé…åˆ—ã®å¤šæ¬¡å…ƒé…åˆ—é–¢æ•°æˆ»ã‚Šå€¤
typedef Matrix2D = int[2][2];
typedef Matrix3D = int[2][2][2];

// 2æ¬¡å…ƒé…åˆ—ã‚’è¿”ã™é–¢æ•°
Matrix2D create_identity_matrix() {
    Matrix2D result;
    result[0][0] = 1; result[0][1] = 0;
    result[1][0] = 0; result[1][1] = 1;
    return result;
}

// 2æ¬¡å…ƒé…åˆ—ã‚’å—ã‘å–ã£ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
void print_matrix(Matrix2D matrix) {
    println("Matrix (2x2):");
    for (int i = 0; i < 2; i++) {
        printf("Row %d : [ ", i);
        for (int j = 0; j < 2; j++) {
            printf("%d", matrix[i][j]);  // ä¿®æ­£æ¸ˆã¿: å¢ƒç•Œã‚¨ãƒ©ãƒ¼è§£æ¶ˆ
            if (j < 1) printf(", ");
        }
        println(" ]");
    }
}

// 3æ¬¡å…ƒé…åˆ—ã‚’è¿”ã™é–¢æ•°
Matrix3D create_3d_matrix() {
    Matrix3D cube;
    int value = 1;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 2; k++) {
                cube[i][j][k] = value++;
            }
        }
    }
    return cube;
}

int main() {
    // 2æ¬¡å…ƒé…åˆ—æˆ»ã‚Šå€¤ã®å‡¦ç†
    Matrix2D identity = create_identity_matrix();
    print_matrix(identity);
    
    // å€‹åˆ¥è¦ç´ ã‚¢ã‚¯ã‚»ã‚¹
    println("identity[0][0] = %d", identity[0][0]);
    println("identity[1][1] = %d", identity[1][1]);
    
    // 3æ¬¡å…ƒé…åˆ—æˆ»ã‚Šå€¤ã®å‡¦ç†
    Matrix3D cube = create_3d_matrix();
    
    println("\n3D Matrix:");
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            printf("[");
            for (int k = 0; k < 2; k++) {
                printf("%d", cube[i][j][k]);
                if (k < 1) printf(", ");
            }
            printf("] ");
        }
        println("");
    }
    
    // å‡ºåŠ›:
    // Matrix (2x2):
    // Row 0 : [ 1, 0 ]
    // Row 1 : [ 0, 1 ]
    // identity[0][0] = 1
    // identity[1][1] = 1
    // 
    // 3D Matrix:
    // [1, 2] [3, 4] 
    // [5, 6] [7, 8]
    
    return 0;
}
```

**æŠ€è¡“çš„æ”¹å–„ç‚¹**:
- **Variable Manager**: `ret.int_array_3d[0][0]`ã®ã¿ã‚’å‡¦ç†ã—ã¦ã„ãŸåˆ¶é™ã‚’è§£æ¶ˆ
- **å…¨è¦ç´ å±•é–‹**: å¤šæ¬¡å…ƒé…åˆ—ã®å…¨è¦ç´ ã‚’`multidim_array_values`ã«æ­£ç¢ºã«å±•é–‹
- **æ¬¡å…ƒæƒ…å ±è¨­å®š**: `array_dimensions`é…åˆ—ã§è¡Œæ•°ãƒ»åˆ—æ•°ç­‰ã®æ¬¡å…ƒæƒ…å ±ã‚’ä¿æŒ
- **å¢ƒç•Œãƒã‚§ãƒƒã‚¯å¼·åŒ–**: é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã®å¢ƒç•Œé•åã‚’äº‹å‰ã«æ¤œå‡ºãƒ»é˜²æ­¢
- **å‹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯**: typedefåã¨`int_array_3d`æ§‹é€ ã‹ã‚‰å¤šæ¬¡å…ƒé…åˆ—ã‚’è‡ªå‹•è­˜åˆ¥
// å­¦ç”Ÿç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ä¾‹
struct Student {
    string name;
    int student_id;
    int grades[5];  // 5ç§‘ç›®ã®æˆç¸¾
    bool is_enrolled;
    char grade_letter;
}

struct Course {
    string course_name;
    string instructor;
    int max_students;
    int enrolled_count;
}

int main() {
    // å€‹åˆ¥å­¦ç”Ÿã®ä½œæˆ
    Student alice;
    alice.name = "Alice Johnson";
    alice.student_id = 1001;
    alice.is_enrolled = true;
    alice.grade_letter = 'A';
    
    // é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ä»£å…¥
    alice.grades = [95, 87, 92, 89, 94];
    
    // æ§‹é€ ä½“é…åˆ—ã«ã‚ˆã‚‹è¤‡æ•°å­¦ç”Ÿç®¡ç†
    Student[3] class_roster = [
        {name: "Bob Smith", student_id: 1002, is_enrolled: true, 
         grade_letter: 'B', grades: [82, 78, 85, 80, 79]},
        {name: "Charlie Brown", student_id: 1003, is_enrolled: true,
         grade_letter: 'A', grades: [91, 93, 89, 95, 92]},
        {name: "Diana Wilson", student_id: 1004, is_enrolled: false,
         grade_letter: 'C', grades: [73, 75, 72, 78, 76]}
    ];
    
    // ã‚³ãƒ¼ã‚¹æƒ…å ±
    Course math_course = {
        course_name: "Advanced Mathematics",
        instructor: "Dr. Einstein",
        max_students: 30,
        enrolled_count: 3
    };
    
    // å­¦ç”Ÿæƒ…å ±ã®å‡ºåŠ›
    print("=== %s ===", math_course.course_name);
    print("æ‹…å½“: %s", math_course.instructor);
    print("ç™»éŒ²å­¦ç”Ÿæ•°: %d/%d", math_course.enrolled_count, math_course.max_students);
    print("");
    
    // å€‹åˆ¥å­¦ç”Ÿæƒ…å ±å‡ºåŠ›
    print("å­¦ç”Ÿ: %s (ID: %d)", alice.name, alice.student_id);
    print("åœ¨ç±çŠ¶æ³: %s", alice.is_enrolled ? "åœ¨ç±ä¸­" : "é€€å­¦");
    print("ç·åˆè©•ä¾¡: %c", alice.grade_letter);
    print("æˆç¸¾: [%d, %d, %d, %d, %d]", 
          alice.grades[0], alice.grades[1], alice.grades[2], 
          alice.grades[3], alice.grades[4]);
    
    // ã‚¯ãƒ©ã‚¹å…¨ä½“ã®æˆç¸¾å‡¦ç†
    print("\n=== ã‚¯ãƒ©ã‚¹åç°¿ ===");
    for (int i = 0; i < 3; i++) {
        if (class_roster[i].is_enrolled) {
            int total = 0;
            for (int j = 0; j < 5; j++) {
                total += class_roster[i].grades[j];
            }
            int average = total / 5;
            
            print("%d. %s (ID: %d) - å¹³å‡: %dç‚¹ (è©•ä¾¡: %c)", 
                  i + 1, class_roster[i].name, class_roster[i].student_id,
                  average, class_roster[i].grade_letter);
        }
    }
    
    return 0;
}
```

### ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…ä¾‹ âœ…
```cb
// ã‚¨ãƒƒã‚¸ï¼ˆè¾ºï¼‰ã‚’è¡¨ã™æ§‹é€ ä½“
struct Edge {
    int to;     // æ¥ç¶šå…ˆã®ãƒãƒ¼ãƒ‰
    int weight; // ã‚¨ãƒƒã‚¸ã®é‡ã¿ï¼ˆè·é›¢ãƒ»ã‚³ã‚¹ãƒˆï¼‰
};

// ç„¡é™å¤§ã‚’è¡¨ã™å®šæ•°
const int INF = 999999;
const int MAX_NODES = 6;
const int MAX_EDGES = 20;

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã§ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†
int node_count = 6;
int[6] distances;         // å„ãƒãƒ¼ãƒ‰ã¸ã®æœ€çŸ­è·é›¢
bool[6] visited;          // è¨ªå•æ¸ˆã¿ãƒ•ãƒ©ã‚°
Edge[20] edges;           // ã‚¨ãƒƒã‚¸é…åˆ—
int edge_count = 0;
int[36] adjacency_matrix; // 6x6ã®éš£æ¥è¡Œåˆ—

// ã‚°ãƒ©ãƒ•ã®åˆæœŸåŒ–
void init_graph() {
    for (int i = 0; i < MAX_NODES; i++) {
        distances[i] = INF;
        visited[i] = false;
    }
    
    // éš£æ¥è¡Œåˆ—ã‚’åˆæœŸåŒ–ï¼ˆINFã§åŸ‹ã‚ã‚‹ï¼‰
    for (int i = 0; i < 36; i++) {
        adjacency_matrix[i] = INF;
    }
    
    // å¯¾è§’ç·šè¦ç´ ã¯0ï¼ˆè‡ªåˆ†è‡ªèº«ã¸ã®è·é›¢ï¼‰
    for (int i = 0; i < MAX_NODES; i++) {
        adjacency_matrix[i * MAX_NODES + i] = 0;
    }
    
    edge_count = 0;
}

// ã‚¨ãƒƒã‚¸ã®è¿½åŠ 
void add_edge(int from, int to, int weight) {
    // éš£æ¥è¡Œåˆ—ã«é‡ã¿ã‚’è¨­å®š
    adjacency_matrix[from * MAX_NODES + to] = weight;
    
    // ã‚¨ãƒƒã‚¸é…åˆ—ã«ã‚‚è¨˜éŒ²
    edges[edge_count].to = to;
    edges[edge_count].weight = weight;
    edge_count++;
}

// æœ€å°è·é›¢ã®ãƒãƒ¼ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹
int find_min_distance_node() {
    int min_distance = INF;
    int min_node = -1;
    
    for (int i = 0; i < node_count; i++) {
        if (!visited[i] && distances[i] < min_distance) {
            min_distance = distances[i];
            min_node = i;
        }
    }
    
    return min_node;
}

// ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã®å®Ÿè¡Œ
void dijkstra(int start) {
    // é–‹å§‹ãƒãƒ¼ãƒ‰ã®è·é›¢ã‚’0ã«è¨­å®š
    distances[start] = 0;
    
    println("Starting Dijkstra from node %d", start);
    
    // ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†ã™ã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—
    for (int count = 0; count < node_count; count++) {
        // æœ€å°è·é›¢ã®æœªè¨ªå•ãƒãƒ¼ãƒ‰ã‚’é¸æŠ
        int current = find_min_distance_node();
        
        if (current == -1) break; // ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†å®Œäº†
        
        visited[current] = true;
        
        println("Processing node %d (distance: %d)", current, distances[current]);
        
        // éš£æ¥ãƒãƒ¼ãƒ‰ã®è·é›¢ã‚’æ›´æ–°
        for (int neighbor = 0; neighbor < node_count; neighbor++) {
            int weight = adjacency_matrix[current * MAX_NODES + neighbor];
            
            if (!visited[neighbor] && weight != INF) {
                int new_distance = distances[current] + weight;
                if (new_distance < distances[neighbor]) {
                    distances[neighbor] = new_distance;
                    println("  Updated node %d: distance = %d", neighbor, new_distance);
                }
            }
        }
    }
}

int main() {
    println("=== Dijkstra's Shortest Path Algorithm ===");
    println("Using struct and array-based graph representation\n");
    
    // ã‚°ãƒ©ãƒ•ã®åˆæœŸåŒ–
    init_graph();
    
    // ã‚¨ãƒƒã‚¸ã®è¿½åŠ ï¼ˆã‚µãƒ³ãƒ—ãƒ«ã‚°ãƒ©ãƒ•ï¼‰
    add_edge(0, 1, 2);   // 0 -> 1: cost 2
    add_edge(0, 3, 1);   // 0 -> 3: cost 1
    add_edge(0, 4, 5);   // 0 -> 4: cost 5
    add_edge(1, 2, 3);   // 1 -> 2: cost 3
    add_edge(2, 5, 1);   // 2 -> 5: cost 1
    add_edge(3, 4, 2);   // 3 -> 4: cost 2
    add_edge(4, 5, 1);   // 4 -> 5: cost 1
    
    println("Graph created with %d nodes and %d edges", node_count, edge_count);
    
    // ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã®å®Ÿè¡Œ
    int start_node = 0;
    dijkstra(start_node);
    
    // çµæœã®è¡¨ç¤º
    println("\n=== Results ===");
    println("Shortest distances from node %d:", start_node);
    for (int i = 0; i < node_count; i++) {
        if (distances[i] == INF) {
            println("Node %d: UNREACHABLE", i);
        } else {
            println("Node %d: %d", i, distances[i]);
        }
    }
    
    return 0;
}
```

**å®Ÿè¡Œçµæœ**:
```
=== Dijkstra's Shortest Path Algorithm ===
Using struct and array-based graph representation

Graph created with 6 nodes and 7 edges
Starting Dijkstra from node 0
Processing node 0 (distance: 0)
  Updated node 1: distance = 2
  Updated node 3: distance = 1
  Updated node 4: distance = 5
Processing node 3 (distance: 1)
  Updated node 4: distance = 3
Processing node 1 (distance: 2)
  Updated node 2: distance = 5
Processing node 4 (distance: 3)
  Updated node 5: distance = 4
Processing node 5 (distance: 4)
Processing node 2 (distance: 5)

=== Results ===
Shortest distances from node 0:
Node 0: 0
Node 1: 2
Node 2: 5
Node 3: 1
Node 4: 3
Node 5: 4
```

### æ§‹é€ ä½“ã¨é…åˆ—ã®é«˜åº¦ãªçµ„ã¿åˆã‚ã› âœ…
```cb
// è¡Œåˆ—æ¼”ç®—ã‚·ã‚¹ãƒ†ãƒ ã®ä¾‹
struct Matrix {
    string name;
    int rows;
    int cols;
    int data[9];  // 3x3è¡Œåˆ—ã¨ã—ã¦ä½¿ç”¨
}

// ãƒ™ã‚¯ãƒˆãƒ«æ§‹é€ ä½“
struct Vector3D {
    int x;
    int y; 
    int z;
    string label;
}

int main() {
    // 3x3å˜ä½è¡Œåˆ—ã®ä½œæˆ
    Matrix identity = {
        name: "Identity Matrix",
        rows: 3,
        cols: 3,
        data: [1, 0, 0,   // ç¬¬1è¡Œ
               0, 1, 0,   // ç¬¬2è¡Œ  
               0, 0, 1]   // ç¬¬3è¡Œ
    };
    
    // å¤‰æ›è¡Œåˆ—
    Matrix transform;
    transform.name = "Transform Matrix";
    transform.rows = 3;
    transform.cols = 3;
    
    // é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ä»£å…¥
    transform.data = [2, 0, 0,
                      0, 2, 0,
                      0, 0, 1];
    
    // ãƒ™ã‚¯ãƒˆãƒ«é…åˆ—
    Vector3D[4] vertices = [
        {x: 1, y: 1, z: 0, label: "Top-Right"},
        {x: -1, y: 1, z: 0, label: "Top-Left"},
        {x: -1, y: -1, z: 0, label: "Bottom-Left"}, 
        {x: 1, y: -1, z: 0, label: "Bottom-Right"}
    ];
    
    // è¡Œåˆ—æƒ…å ±å‡ºåŠ›
    print("=== %s ===", identity.name);
    print("ã‚µã‚¤ã‚º: %dx%d", identity.rows, identity.cols);
    for (int i = 0; i < 3; i++) {
        print("[%d %d %d]", 
              identity.data[i*3], identity.data[i*3+1], identity.data[i*3+2]);
    }
    
    print("\n=== %s ===", transform.name);
    for (int i = 0; i < 3; i++) {
        print("[%d %d %d]", 
              transform.data[i*3], transform.data[i*3+1], transform.data[i*3+2]);
    }
    
    // ãƒ™ã‚¯ãƒˆãƒ«æƒ…å ±å‡ºåŠ›
    print("\n=== é ‚ç‚¹åº§æ¨™ ===");
    for (int i = 0; i < 4; i++) {
        print("%s: (%d, %d, %d)", 
              vertices[i].label, vertices[i].x, vertices[i].y, vertices[i].z);
    }
    
    // ç°¡å˜ãªè¡Œåˆ—-ãƒ™ã‚¯ãƒˆãƒ«ç©æ¼”ç®—ï¼ˆæœ€åˆã®é ‚ç‚¹ã®ã¿ï¼‰
    Vector3D result;
    result.label = "Transformed";
    result.x = transform.data[0] * vertices[0].x + 
               transform.data[1] * vertices[0].y + 
               transform.data[2] * vertices[0].z;
    result.y = transform.data[3] * vertices[0].x + 
               transform.data[4] * vertices[0].y + 
               transform.data[5] * vertices[0].z;
    result.z = transform.data[6] * vertices[0].x + 
               transform.data[7] * vertices[0].y + 
               transform.data[8] * vertices[0].z;
    
    print("\n=== å¤‰æ›çµæœ ===");
    print("å…ƒåº§æ¨™: (%d, %d, %d)", vertices[0].x, vertices[0].y, vertices[0].z);
    print("å¤‰æ›å¾Œ: (%d, %d, %d)", result.x, result.y, result.z);
    
    return 0;
}
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆç¾åœ¨ã®å®Ÿè£…ï¼‰
```cb
int divide_safe(int a, int b) {
    // ç¾åœ¨ã¯å‹ç¯„å›²ãƒã‚§ãƒƒã‚¯ãŒè‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹
    // ã‚¼ãƒ­é™¤ç®—ã¯å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹
    return a / b;
}

int main() {
    int result;
    
    // æ­£å¸¸ãªè¨ˆç®—ï¼ˆè¤‡åˆä»£å…¥æ¼”ç®—å­ä½¿ç”¨ï¼‰
    result = divide_safe(10, 2);
    result *= 3;  // result = result * 3
    print("(10 / 2) * 3 = %d", result);
    
    // å‹ç¯„å›²å¤–ã®å€¤ã¯è‡ªå‹•çš„ã«æ¤œå‡ºã•ã‚Œã‚‹
    tiny small = 200; // ã‚¨ãƒ©ãƒ¼: tinyå‹ã¯127ã¾ã§
    
    return 0;
}
```

### å¿…è¦ãªç’°å¢ƒ
- **C++17å¯¾å¿œã‚³ãƒ³ãƒ‘ã‚¤ãƒ©**: g++, clang++
- **flex**: å­—å¥è§£æå™¨ç”Ÿæˆãƒ„ãƒ¼ãƒ«
- **bison**: æ§‹æ–‡è§£æå™¨ç”Ÿæˆãƒ„ãƒ¼ãƒ«
- **make**: ãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ‰‹é †

#### Ubuntu/Debian
```bash
sudo apt-get update
sudo apt-get install build-essential flex bison
```

#### macOS
```bash
brew install flex bison
```

#### CentOS/RHEL
```bash
sudo yum install gcc-c++ flex bison make
```

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ“ãƒ«ãƒ‰
```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/username/Cb.git
cd Cb

# ãƒ“ãƒ«ãƒ‰
make clean
make all

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
make test
```

### ãƒ‡ãƒãƒƒã‚°ã‚ªãƒ—ã‚·ãƒ§ãƒ³
```bash
# è‹±èªã§ã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±
./main --debug sample/test.cb

# æ—¥æœ¬èªã§ã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±
./main --debug-ja sample/test.cb

# ç’°å¢ƒå¤‰æ•°ã§ã®ãƒ‡ãƒãƒƒã‚°æœ‰åŠ¹åŒ–
./main sample/test.cb
```

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã¨å¯¾å‡¦æ³•

#### å‹ç¯„å›²å¤–ã‚¨ãƒ©ãƒ¼
```
Error: Type range exceeded for tiny: 200 (valid range: -128 to 127)
```
**å¯¾å‡¦æ³•**: ã‚ˆã‚Šå¤§ããªå‹ï¼ˆshort, int, longï¼‰ã‚’ä½¿ç”¨ã™ã‚‹

#### é…åˆ—å¢ƒç•Œå¤–ã‚¢ã‚¯ã‚»ã‚¹
```
Error: Array index out of bounds: index 5 for array of size 3
```
**å¯¾å‡¦æ³•**: é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒ0ã‹ã‚‰size-1ã®ç¯„å›²å†…ã«ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª

#### æ–‡å­—ãƒªãƒ†ãƒ©ãƒ«ã‚¨ãƒ©ãƒ¼
```
Error: Invalid character literal: 'ã‚'
```
**å¯¾å‡¦æ³•**: charå‹ã¯ASCIIæ–‡å­—ï¼ˆ0-255ï¼‰ã®ã¿ã‚µãƒãƒ¼ãƒˆã€‚Unicodeæ–‡å­—ã«ã¯stringå‹ã‚’ä½¿ç”¨

#### ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
```
flex: command not found
```
```
**å¯¾å‡¦æ³•**: flexã¨bisonã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯

### ç›®æ¨™æ€§èƒ½
- **Ruby/Pythonæ¯”**: 10-50å€é«˜é€Ÿ
- **JavaScriptæ¯”**: 2-5å€é«˜é€Ÿ  
- **C++æ¯”**: 80-95%ã®æ€§èƒ½ï¼ˆRAIIç­‰ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰è¾¼ã¿ï¼‰

### ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
- **ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä¸ä½¿ç”¨**: äºˆæ¸¬å¯èƒ½ãªãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
- **RAII**: è‡ªå‹•ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã«ã‚ˆã‚‹ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢
- **ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–**: å®Ÿè¡Œæ™‚ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã®æœ€å°åŒ–

## ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—ãƒ»å°†æ¥è¨ˆç”»

### Phase 2: ä¸­ç´šæ©Ÿèƒ½ï¼ˆå®Ÿè£…äºˆå®šï¼‰
- **structå®šç¾©**: ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿å‹
- **enumå®šç¾©**: åˆ—æŒ™å‹ã®ã‚µãƒãƒ¼ãƒˆ
- **typedef**: å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
- **æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ‹¡å……**: math, string, io ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
- **æµ®å‹•å°æ•°ç‚¹æ•°**: float, double å‹
- **å‹•çš„é…åˆ—**: å¯å¤‰é•·é…åˆ—ã®ã‚µãƒãƒ¼ãƒˆ

### Phase 3: ä¸Šç´šæ©Ÿèƒ½ï¼ˆé•·æœŸè¨ˆç”»ï¼‰  
- **interface/trait**: Rustãƒ©ã‚¤ã‚¯ãªæŠ½è±¡åŒ–
- **ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹**: å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–
- **ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ **: import/export
- **Resultå‹**: å®‰å…¨ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- **ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿**: unique_ptr, shared_ptr
- **ä¸¦è¡Œå‡¦ç†**: goroutine/channelãƒ©ã‚¤ã‚¯ãªæ©Ÿèƒ½

### Phase 4: ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå°†æ¥æ§‹æƒ³ï¼‰
- **ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£**: cb-pkg
- **LSPå¯¾å¿œ**: ã‚¨ãƒ‡ã‚£ã‚¿ã‚µãƒãƒ¼ãƒˆ  
- **WebAssembly**: ãƒ–ãƒ©ã‚¦ã‚¶å®Ÿè¡Œ
- **ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«**: ãƒãƒ«ãƒãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ
- **FFI**: C/C++ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé€£æº

## ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ»ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

### è²¢çŒ®æ–¹æ³•
1. **Issueå ±å‘Š**: ãƒã‚°å ±å‘Šãƒ»æ©Ÿèƒ½ææ¡ˆ
2. **Pull Request**: ã‚³ãƒ¼ãƒ‰æ”¹å–„ãƒ»æ–°æ©Ÿèƒ½å®Ÿè£…  
3. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: ä»•æ§˜æ›¸ãƒ»ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã®æ”¹å–„
4. **ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹**: ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®å‘ä¸Š

### é–‹ç™ºè€…å‘ã‘ãƒªã‚½ãƒ¼ã‚¹
- **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: src/å†…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆ
- **ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: tests/å†…ã®çµ±åˆãƒ†ã‚¹ãƒˆãƒ»å˜ä½“ãƒ†ã‚¹ãƒˆ
- **ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„**: C++17 modern style
- **ãƒ‡ãƒãƒƒã‚°æ‰‹æ³•**: --debug, --debug-jaã‚ªãƒ—ã‚·ãƒ§ãƒ³

### ãƒ©ã‚¤ã‚»ãƒ³ã‚¹
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚
è©³ç´°ã¯[LICENSE](../LICENSE)ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

*Cbè¨€èªã¯å®Ÿç”¨çš„ã§é«˜æ€§èƒ½ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’ç›®æŒ‡ã—ã¦é–‹ç™ºã‚’ç¶šã‘ã¦ã„ã¾ã™ã€‚*
*ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®çš†æ§˜ã‹ã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ãŠå¾…ã¡ã—ã¦ãŠã‚Šã¾ã™ã€‚*
