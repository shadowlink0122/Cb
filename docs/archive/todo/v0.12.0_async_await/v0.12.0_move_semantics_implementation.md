# v0.12.0 ãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹å®Ÿè£…è¨ˆç”»

**æ›´æ–°æ—¥**: 2025å¹´11æœˆ7æ—¥  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.12.0

## ğŸ“‹ æ¦‚è¦

C++ã¨åŒã˜ä»•æ§˜ã§å³è¾ºå€¤å‚ç…§ï¼ˆ`T&&`ï¼‰ã«ã‚ˆã‚‹æ‰€æœ‰æ¨©ç§»å‹•ã‚’å®Ÿè£…ã™ã‚‹ã€‚

**å‰æ**: v0.11.0ã§ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨RAIIãŒå®Œäº†

## ğŸ¯ å®Ÿè£…æ–¹é‡

### ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æ±‚
1. **é€šå¸¸ã®å¤‰æ•°ã§ã‚‚ãƒ ãƒ¼ãƒ–ï¼ˆæ‰€æœ‰æ¨©ã®ç§»å‹•ï¼‰ã‚’å®Ÿè£…**
2. **`T&&` ã§å®Œå…¨ã«æ‰€æœ‰æ¨©ã‚’æ¸¡ã™**
3. **ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚åŒæ§˜**
4. **C++ã¨åŒã˜ä»•æ§˜**
5. **å³è¾ºå€¤ã®ãƒ ãƒ¼ãƒ–ã¯ç¦æ­¢**

### C++ã¨ã®æ•´åˆæ€§

```cpp
// C++ã®ä»•æ§˜
struct Buffer {
    int* data;
    
    // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆå·¦è¾ºå€¤å‚ç…§ + constï¼‰
    Buffer(const Buffer& other);
    
    // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆå³è¾ºå€¤å‚ç…§ï¼‰
    Buffer(Buffer&& other) noexcept;
};

Buffer b1;
Buffer b2 = b1;         // ã‚³ãƒ”ãƒ¼
Buffer b3 = std::move(b1);  // ãƒ ãƒ¼ãƒ–ï¼ˆb1ã¯ç„¡åŠ¹åŒ–ï¼‰
// Buffer b4 = std::move(123);  // ã‚¨ãƒ©ãƒ¼: å³è¾ºå€¤ã¯ãƒ ãƒ¼ãƒ–ä¸å¯
```

## ğŸ”§ å®Ÿè£…ã‚¿ã‚¹ã‚¯

### Phase 1: æ§‹æ–‡è§£æï¼ˆParserï¼‰

#### 1.1 å³è¾ºå€¤å‚ç…§ã®æ§‹æ–‡ã‚µãƒãƒ¼ãƒˆ

**å ´æ‰€**: `src/frontend/recursive_parser/`

**å¿…è¦ãªå¤‰æ›´**:
```cpp
// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®è§£ææ‹¡å¼µ
enum ReferenceType {
    NO_REFERENCE,
    LVALUE_REFERENCE,   // T&
    RVALUE_REFERENCE    // T&&
};

struct Parameter {
    std::string type;
    std::string name;
    bool is_const;
    ReferenceType ref_type;  // NEW
};
```

**æ§‹æ–‡ä¾‹**:
```cb
// å·¦è¾ºå€¤å‚ç…§ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰
self(const Point& other) { }

// å³è¾ºå€¤å‚ç…§ï¼ˆãƒ ãƒ¼ãƒ–ï¼‰
self(Point&& other) { }
```

#### 1.2 move() é–¢æ•°ã®èªè­˜

**å ´æ‰€**: `src/common/ast.h`

**ASTæ‹¡å¼µ**:
```cpp
struct MoveExpressionNode : public ASTNode {
    std::unique_ptr<ASTNode> expression;
    std::string var_name;
};
```

**æ§‹æ–‡ä¾‹**:
```cb
Buffer b1(100);
Buffer b2 = move(b1);  // move()å‘¼ã³å‡ºã—ã‚’èªè­˜
```

---

### Phase 2: å‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆType Managerï¼‰

#### 2.1 å³è¾ºå€¤å‚ç…§ã®å‹ç®¡ç†

**å ´æ‰€**: `src/common/type_utils.h`, `src/common/type_utils.cpp`

**è¿½åŠ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰**:
```cpp
struct TypeInfo {
    VariableType type;
    bool is_const;
    bool is_pointer;
    bool is_reference;
    bool is_rvalue_reference;  // NEW: T&& ã®åˆ¤å®š
    std::string type_alias;
};
```

#### 2.2 å€¤ã‚«ãƒ†ã‚´ãƒªã®åˆ¤å®š

**æ–°è¦é–¢æ•°**:
```cpp
enum ValueCategory {
    LVALUE,   // å·¦è¾ºå€¤ï¼ˆåå‰ä»˜ãå¤‰æ•°ï¼‰
    RVALUE    // å³è¾ºå€¤ï¼ˆä¸€æ™‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãƒªãƒ†ãƒ©ãƒ«ï¼‰
};

ValueCategory determine_value_category(const ASTNode* node);
```

**åˆ¤å®šãƒ«ãƒ¼ãƒ«**:
- å¤‰æ•°å â†’ LVALUE
- ãƒªãƒ†ãƒ©ãƒ« â†’ RVALUE
- `move(x)` â†’ RVALUEï¼ˆæ˜ç¤ºçš„ãªå³è¾ºå€¤åŒ–ï¼‰
- é–¢æ•°ã®æˆ»ã‚Šå€¤ â†’ RVALUEï¼ˆæœ€é©åŒ–å¯èƒ½ï¼‰

---

### Phase 3: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ï¼ˆInterpreterï¼‰

#### 3.1 ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®æ¤œå‡º

**å ´æ‰€**: `src/backend/interpreter/core/interpreter.cpp`

**æ–°è¦é–¢æ•°**:
```cpp
void Interpreter::call_move_constructor(
    const std::string& dest_var_name,
    const std::string& struct_type_name,
    const std::string& source_var_name
);
```

**æ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯**:
```cpp
// ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’æ¢ã™
// æ¡ä»¶: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒ1ã¤ã§ã€T&& å‹ï¼ˆå³è¾ºå€¤å‚ç…§ï¼‰
const ASTNode* find_move_constructor(const std::string& struct_type) {
    auto it = struct_constructors_.find(struct_type);
    if (it == struct_constructors_.end()) return nullptr;
    
    for (const auto* ctor : it->second) {
        if (ctor->parameters.size() == 1) {
            const auto& param = ctor->parameters[0];
            // T&& ã‹ã¤éconst
            if (param->is_rvalue_reference && !param->is_const) {
                return ctor;
            }
        }
    }
    return nullptr;
}
```

#### 3.2 move() é–¢æ•°ã®å®Ÿè£…

**å ´æ‰€**: `src/backend/interpreter/handlers/expressions/`

**å®Ÿè£…**:
```cpp
Variable Interpreter::execute_move_expression(const ASTNode* node) {
    // move(x) ã®å¼•æ•°ã‚’å–å¾—
    const std::string& var_name = node->var_name;
    
    // å·¦è¾ºå€¤ï¼ˆå¤‰æ•°ï¼‰ã§ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼
    Variable* var = find_variable(var_name);
    if (!var) {
        throw std::runtime_error("move() requires an lvalue (variable)");
    }
    
    // å³è¾ºå€¤ã¸ã®å¤‰æ›ï¼ˆå€¤ã‚«ãƒ†ã‚´ãƒªã®å¤‰æ›´ã®ã¿ï¼‰
    Variable result = *var;
    result.value_category = RVALUE;
    result.is_moved_from = false;  // ã¾ã ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã„ãªã„
    
    return result;
}
```

#### 3.3 æ‰€æœ‰æ¨©ç§»å‹•ã®å®Ÿè£…

**å ´æ‰€**: `src/backend/interpreter/core/interpreter.cpp`

**ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—**:
```cpp
void Interpreter::call_move_constructor(
    const std::string& dest_var_name,
    const std::string& struct_type_name,
    const std::string& source_var_name
) {
    const ASTNode* move_ctor = find_move_constructor(struct_type_name);
    
    if (!move_ctor) {
        // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒãªã„å ´åˆã€ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ç”¨
        call_copy_constructor(dest_var_name, struct_type_name, source_var_name);
        return;
    }
    
    Variable* dest_var = find_variable(dest_var_name);
    Variable* source_var = find_variable(source_var_name);
    
    if (!dest_var || !source_var) {
        throw std::runtime_error("Variable not found in move constructor");
    }
    
    // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ç”¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’ä½œæˆ
    push_scope();
    
    // self ã‚’ dest_var ã¨ã—ã¦è¨­å®š
    current_scope().variables["self"] = *dest_var;
    
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚½ãƒ¼ã‚¹å¤‰æ•°ã¸ã®å³è¾ºå€¤å‚ç…§ï¼‰ã‚’è¨­å®š
    const auto& param = move_ctor->parameters[0];
    current_scope().variables[param->name] = *source_var;
    
    // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿æœ¬ä½“ã‚’å®Ÿè¡Œ
    if (move_ctor->body) {
        execute_statement(move_ctor->body.get());
    }
    
    // selfã¸ã®å¤‰æ›´ã‚’ dest_var ã«åæ˜ 
    Variable* self = find_variable("self");
    if (self) {
        dest_var->struct_members = self->struct_members;
        
        // ãƒ¡ãƒ³ãƒãƒ¼å¤‰æ•°ã‚‚æ›´æ–°
        for (const auto& [member_name, member_value] : self->struct_members) {
            std::string member_path = dest_var_name + "." + member_name;
            Variable* dest_member = find_variable(member_path);
            if (dest_member) {
                *dest_member = member_value;
            }
        }
    }
    
    pop_scope();
    
    // âš ï¸ é‡è¦: ã‚½ãƒ¼ã‚¹å¤‰æ•°ã‚’ã€Œãƒ ãƒ¼ãƒ–æ¸ˆã¿ã€çŠ¶æ…‹ã«ãƒãƒ¼ã‚¯
    source_var->is_moved_from = true;
    
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å‰Šé™¤ï¼ˆãƒ ãƒ¼ãƒ–æ¸ˆã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ä¸è¦ï¼‰
    remove_from_destructor_stack(source_var_name);
    
    if (debug_mode) {
        debug_print("Move constructor called: %s -> %s (source invalidated)\n",
                    source_var_name.c_str(), dest_var_name.c_str());
    }
}
```

#### 3.4 ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ã®å‰Šé™¤

**æ–°è¦é–¢æ•°**:
```cpp
void Interpreter::remove_from_destructor_stack(const std::string& var_name) {
    if (destructor_stacks_.empty()) return;
    
    auto& current_stack = destructor_stacks_.back();
    
    // var_name ã«ä¸€è‡´ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
    current_stack.erase(
        std::remove_if(current_stack.begin(), current_stack.end(),
            [&var_name](const auto& entry) {
                return entry.first == var_name;
            }),
        current_stack.end()
    );
    
    if (debug_mode) {
        debug_print("Removed %s from destructor stack (moved from)\n",
                    var_name.c_str());
    }
}
```

---

### Phase 4: å¤‰æ•°å®£è¨€ã§ã®è‡ªå‹•åˆ¤å®š

#### 4.1 åˆæœŸåŒ–ã§ã®åˆ¤å®š

**å ´æ‰€**: `src/backend/interpreter/handlers/variables/declaration.cpp`

**ãƒ­ã‚¸ãƒƒã‚¯**:
```cpp
void Interpreter::execute_variable_declaration(const ASTNode* node) {
    // ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...
    
    // åˆæœŸåŒ–å¼ãŒã‚ã‚‹å ´åˆ
    if (node->initializer) {
        // åˆæœŸåŒ–å¼ã®å€¤ã‚«ãƒ†ã‚´ãƒªã‚’åˆ¤å®š
        ValueCategory category = determine_value_category(node->initializer.get());
        
        if (node->type == TYPE_STRUCT) {
            std::string struct_type = resolve_typedef(node->type_alias);
            
            if (category == RVALUE) {
                // å³è¾ºå€¤ â†’ ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
                call_move_constructor(var_name, struct_type, source_var_name);
            } else {
                // å·¦è¾ºå€¤ â†’ ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
                call_copy_constructor(var_name, struct_type, source_var_name);
            }
        }
    }
}
```

---

### Phase 5: å³è¾ºå€¤ã®ãƒ ãƒ¼ãƒ–ç¦æ­¢

#### 5.1 move() ã®å¼•æ•°ãƒã‚§ãƒƒã‚¯

**å ´æ‰€**: `src/backend/interpreter/handlers/expressions/move.cpp`

**æ¤œè¨¼**:
```cpp
Variable Interpreter::execute_move_expression(const ASTNode* node) {
    const std::string& var_name = node->var_name;
    
    // å³è¾ºå€¤ãƒã‚§ãƒƒã‚¯
    if (is_rvalue_expression(node->expression.get())) {
        throw std::runtime_error(
            "Cannot move from rvalue (literals, temporary objects). "
            "move() requires a variable (lvalue)."
        );
    }
    
    // å·¦è¾ºå€¤ï¼ˆå¤‰æ•°ï¼‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
    Variable* var = find_variable(var_name);
    if (!var) {
        throw std::runtime_error(
            "move() requires a variable name, not an expression"
        );
    }
    
    // æ—¢ã«ãƒ ãƒ¼ãƒ–æ¸ˆã¿ã®å¤‰æ•°ã‹ã‚‰ã¯ãƒ ãƒ¼ãƒ–ã§ããªã„
    if (var->is_moved_from) {
        throw std::runtime_error(
            "Cannot move from already moved variable: " + var_name
        );
    }
    
    // å³è¾ºå€¤ã¸ã®å¤‰æ›
    Variable result = *var;
    result.value_category = RVALUE;
    return result;
}
```

**ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¾‹**:
```cb
Buffer b = move(123);        // ã‚¨ãƒ©ãƒ¼: å³è¾ºå€¤ã¯ãƒ ãƒ¼ãƒ–ã§ãã¾ã›ã‚“
Buffer b = move(get_buffer());  // ã‚¨ãƒ©ãƒ¼: ä¸€æ™‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ ãƒ¼ãƒ–ã§ãã¾ã›ã‚“
```

---

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®æ‹¡å¼µ

### Variable æ§‹é€ ä½“

**å ´æ‰€**: `src/common/ast.h` ã¾ãŸã¯ `src/backend/interpreter/core/interpreter.h`

```cpp
struct Variable {
    // æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    std::string name;
    VariableType type;
    TypedValue value;
    bool is_const;
    bool is_pointer;
    bool is_reference;
    
    // NEW: ãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ç”¨
    bool is_rvalue_reference;  // T&& å‹ã‹
    ValueCategory value_category;  // LVALUE or RVALUE
    bool is_moved_from;  // ãƒ ãƒ¼ãƒ–æ¸ˆã¿ãƒ•ãƒ©ã‚°
    
    Variable() 
        : is_rvalue_reference(false),
          value_category(LVALUE),
          is_moved_from(false) {}
};
```

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### Test 1: åŸºæœ¬çš„ãªãƒ ãƒ¼ãƒ–

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/basic_move_test.cb`

```cb
struct Point {
    int x;
    int y;
}

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    self(const Point& other) {
        self.x = other.x;
        self.y = other.y;
        println("Copy constructor");
    }
    
    // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    self(Point&& other) {
        self.x = other.x;
        self.y = other.y;
        other.x = 0;
        other.y = 0;
        println("Move constructor");
    }
    
    ~self() {
        println("Destructor: (", self.x, ", ", self.y, ")");
    }
}

void main() {
    Point p1(10, 20);
    println("p1: (", p1.x, ", ", p1.y, ")");
    
    Point p2 = move(p1);  // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
    println("After move:");
    println("  p1: (", p1.x, ", ", p1.y, ")");  // (0, 0)
    println("  p2: (", p2.x, ", ", p2.y, ")");  // (10, 20)
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// p1: (10, 20)
// Move constructor
// After move:
//   p1: (0, 0)
//   p2: (10, 20)
// Destructor: (10, 20)  â† p2ã®ã¿ï¼ˆp1ã¯ãƒ ãƒ¼ãƒ–æ¸ˆã¿ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—ï¼‰
```

### Test 2: ãƒªã‚½ãƒ¼ã‚¹æ‰€æœ‰æ¨©ã®ç§»å‹•

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/move_ownership_test.cb`

```cb
struct Buffer {
    int* data;
    int size;
    bool owns_data;
}

impl Buffer {
    self(int s) {
        self.size = s;
        self.owns_data = true;
        println("Buffer created: size=", s);
    }
    
    // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ï¼‰
    self(const Buffer& other) {
        self.size = other.size;
        self.owns_data = true;
        println("Buffer copied (DEEP): size=", self.size);
    }
    
    // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆæ‰€æœ‰æ¨©ç§»å‹•ï¼‰
    self(Buffer&& other) {
        self.size = other.size;
        self.data = other.data;
        self.owns_data = other.owns_data;
        
        // ãƒ ãƒ¼ãƒ–å…ƒã‚’ç„¡åŠ¹åŒ–
        other.size = 0;
        other.data = nullptr;
        other.owns_data = false;
        
        println("Buffer moved (FAST): size=", self.size);
    }
    
    ~self() {
        if (self.owns_data) {
            println("Buffer destroyed: size=", self.size);
        } else {
            println("Buffer destroyed: (moved from, no cleanup)");
        }
    }
}

void main() {
    println("=== Copy vs Move Test ===");
    
    Buffer b1(100);
    Buffer b2 = b1;        // ã‚³ãƒ”ãƒ¼ï¼ˆé‡ã„ï¼‰
    Buffer b3 = move(b1);  // ãƒ ãƒ¼ãƒ–ï¼ˆè»½ã„ï¼‰
    
    println("End of main");
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// === Copy vs Move Test ===
// Buffer created: size=100
// Buffer copied (DEEP): size=100
// Buffer moved (FAST): size=100
// End of main
// Buffer destroyed: size=100  â† b3ï¼ˆæ‰€æœ‰æ¨©ã‚ã‚Šï¼‰
// Buffer destroyed: size=100  â† b2ï¼ˆæ‰€æœ‰æ¨©ã‚ã‚Šï¼‰
// Buffer destroyed: (moved from, no cleanup)  â† b1ï¼ˆãƒ ãƒ¼ãƒ–æ¸ˆã¿ï¼‰
```

### Test 3: å³è¾ºå€¤ã®ãƒ ãƒ¼ãƒ–ç¦æ­¢

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/move_error_test.cb`

```cb
struct Point {
    int x;
    int y;
}

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    self(Point&& other) {
        self.x = other.x;
        self.y = other.y;
    }
}

Point create_point() {
    Point p(10, 20);
    return p;
}

void main() {
    // ã‚¨ãƒ©ãƒ¼: å³è¾ºå€¤ã¯ãƒ ãƒ¼ãƒ–ã§ããªã„
    // Point p1 = move(123);  // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
    
    // ã‚¨ãƒ©ãƒ¼: ä¸€æ™‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ ãƒ¼ãƒ–ã§ããªã„
    // Point p2 = move(create_point());  // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
    
    // OK: å¤‰æ•°ï¼ˆå·¦è¾ºå€¤ï¼‰ã¯ãƒ ãƒ¼ãƒ–ã§ãã‚‹
    Point p3(30, 40);
    Point p4 = move(p3);  // OK
    
    println("Test passed");
}
```

### Test 4: ãƒ ãƒ¼ãƒ–å¾Œã®ã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/moved_from_access_test.cb`

```cb
struct Point {
    int x;
    int y;
}

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    self(Point&& other) {
        self.x = other.x;
        self.y = other.y;
        other.x = 0;
        other.y = 0;
    }
}

void main() {
    Point p1(10, 20);
    Point p2 = move(p1);
    
    // âš ï¸ è­¦å‘Š: ãƒ ãƒ¼ãƒ–å¾Œã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
    // println(p1.x);  // æŠ€è¡“çš„ã«ã¯å¯èƒ½ã ãŒã€æœªå®šç¾©å‹•ä½œ
    
    // ã‚¨ãƒ©ãƒ¼: ãƒ ãƒ¼ãƒ–æ¸ˆã¿å¤‰æ•°ã‹ã‚‰å†åº¦ãƒ ãƒ¼ãƒ–ã¯ã§ããªã„
    // Point p3 = move(p1);  // ã‚¨ãƒ©ãƒ¼
    
    println("p2: (", p2.x, ", ", p2.y, ")");
}
```

---

## ğŸ“ å®Ÿè£…é †åº

### ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®æ‹¡å¼µï¼ˆ1æ—¥ï¼‰
- [ ] `Variable` ã« `is_rvalue_reference`, `value_category`, `is_moved_from` ã‚’è¿½åŠ 
- [ ] `ValueCategory` enum ã®å®šç¾©
- [ ] `ReferenceType` enum ã®å®šç¾©

### ã‚¹ãƒ†ãƒƒãƒ—2: æ§‹æ–‡è§£æï¼ˆ2æ—¥ï¼‰
- [ ] `&&` ãƒˆãƒ¼ã‚¯ãƒ³ã®èªè­˜
- [ ] ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è§£æã§ `T&&` ã‚’ã‚µãƒãƒ¼ãƒˆ
- [ ] `move()` é–¢æ•°å‘¼ã³å‡ºã—ã®ASTãƒãƒ¼ãƒ‰

### ã‚¹ãƒ†ãƒƒãƒ—3: å‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ1æ—¥ï¼‰
- [ ] `determine_value_category()` é–¢æ•°ã®å®Ÿè£…
- [ ] å³è¾ºå€¤å‚ç…§ã®å‹ãƒã‚§ãƒƒã‚¯

### ã‚¹ãƒ†ãƒƒãƒ—4: ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆ3æ—¥ï¼‰
- [ ] `find_move_constructor()` ã®å®Ÿè£…
- [ ] `call_move_constructor()` ã®å®Ÿè£…
- [ ] `remove_from_destructor_stack()` ã®å®Ÿè£…

### ã‚¹ãƒ†ãƒƒãƒ—5: move() é–¢æ•°ï¼ˆ2æ—¥ï¼‰
- [ ] `execute_move_expression()` ã®å®Ÿè£…
- [ ] å³è¾ºå€¤ãƒã‚§ãƒƒã‚¯ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- [ ] ãƒ ãƒ¼ãƒ–æ¸ˆã¿å¤‰æ•°ã®ãƒã‚§ãƒƒã‚¯

### ã‚¹ãƒ†ãƒƒãƒ—6: å¤‰æ•°å®£è¨€ã®è‡ªå‹•åˆ¤å®šï¼ˆ1æ—¥ï¼‰
- [ ] åˆæœŸåŒ–å¼ã®å€¤ã‚«ãƒ†ã‚´ãƒªåˆ¤å®š
- [ ] ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–ã®è‡ªå‹•é¸æŠ

### ã‚¹ãƒ†ãƒƒãƒ—7: ãƒ†ã‚¹ãƒˆï¼ˆ2æ—¥ï¼‰
- [ ] åŸºæœ¬çš„ãªãƒ ãƒ¼ãƒ–ãƒ†ã‚¹ãƒˆ
- [ ] ãƒªã‚½ãƒ¼ã‚¹æ‰€æœ‰æ¨©ãƒ†ã‚¹ãƒˆ
- [ ] ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆã®æ›´æ–°

**åˆè¨ˆ**: ç´„12æ—¥ï¼ˆ2é€±é–“ï¼‰

---

## ğŸš¨ æ³¨æ„äº‹é …

### 1. C++ã¨ã®é•ã„

**C++**:
```cpp
Buffer b = Buffer(100);  // è‡ªå‹•çš„ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹ï¼ˆRVOï¼‰
```

**Cbè¨€èª**:
```cb
Buffer b = create_buffer();  // ã‚³ãƒ”ãƒ¼ï¼ˆæ˜ç¤ºçš„ãªmove()ãŒå¿…è¦ï¼‰
Buffer b = move(create_buffer());  // ã‚¨ãƒ©ãƒ¼: å³è¾ºå€¤ã¯ãƒ ãƒ¼ãƒ–ä¸å¯
```

### 2. ãƒ ãƒ¼ãƒ–å¾Œã®çŠ¶æ…‹

**C++**: ãƒ ãƒ¼ãƒ–å¾Œã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Œæœ‰åŠ¹ã ãŒæœªè¦å®šã€
**Cbè¨€èª**: ãƒ ãƒ¼ãƒ–å¾Œã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ˜ç¤ºçš„ã«ç„¡åŠ¹åŒ–ï¼ˆãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ãªã—ï¼‰

### 3. æš—é»™ã®ãƒ ãƒ¼ãƒ–

**å®Ÿè£…ã—ãªã„æ©Ÿèƒ½**:
- é–¢æ•°ã®æˆ»ã‚Šå€¤ã§ã®è‡ªå‹•ãƒ ãƒ¼ãƒ–ï¼ˆRVO/NRVOï¼‰
- ä¸€æ™‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è‡ªå‹•ãƒ ãƒ¼ãƒ–

**ç†ç”±**: ã‚·ãƒ³ãƒ—ãƒ«ã•ã‚’ä¿ã¤ãŸã‚ã€æ˜ç¤ºçš„ãª`move()`ã®ã¿ã‚µãƒãƒ¼ãƒˆ

---

## ğŸ“š å‚è€ƒè³‡æ–™

### C++11 ãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹
- å³è¾ºå€¤å‚ç…§: `T&&`
- `std::move()`: å·¦è¾ºå€¤ã‚’å³è¾ºå€¤ã«ã‚­ãƒ£ã‚¹ãƒˆ
- ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿: `T(T&& other)`

### å®Ÿè£…å‚è€ƒ
- GCC ã® libstdc++ implementation
- Clang ã® libc++ implementation
- Microsoft STL implementation

---

## âœ… å®Œäº†åŸºæº–

- [ ] `T&&` æ§‹æ–‡ãŒãƒ‘ãƒ¼ã‚¹ã§ãã‚‹
- [ ] `move()` é–¢æ•°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹
- [ ] ãƒ ãƒ¼ãƒ–å¾Œã€ã‚½ãƒ¼ã‚¹å¤‰æ•°ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œãªã„
- [ ] å³è¾ºå€¤ã®ãƒ ãƒ¼ãƒ–ãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
- [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒåˆæ ¼
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã¦ã„ã‚‹

---

## ğŸ”„ æ¬¡ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã®æ‹¡å¼µï¼ˆv0.12.0ï¼‰

- [ ] Return Value Optimization (RVO)
- [ ] Named Return Value Optimization (NRVO)
- [ ] Perfect Forwardingï¼ˆå®Œå…¨è»¢é€ï¼‰
- [ ] Universal Referencesï¼ˆ`T&&` in templatesï¼‰

---

**ä½œæˆæ—¥**: 2025-10-11
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: è¨ˆç”»ä¸­ï¼ˆv0.11.0ï¼‰
**æ‹…å½“**: @shadowlink0122
