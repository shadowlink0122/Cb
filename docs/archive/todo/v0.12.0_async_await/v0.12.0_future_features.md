# Cb言語 将来機能ロードマップ

## 最終更新日
2025年11月3日

## 概要
v0.11.0 Part 1a完成後の将来バージョンで実装予定の機能をまとめています。

---

## 📋 v0.11.0の状況

### ✅ v0.11.0 Part 1a で実装済み（2025年10月28日リリース）
- ✅ デストラクタ機能（自動リソース管理）
- ✅ デストラクタスコープシステム（break/continue対応）
- ✅ ジェネリクスシステム（構造体、関数、enum）
- ✅ 文字列補間機能
- ✅ Option<T> / Result<T, E> 組み込み型
- ✅ Vector<T> 双方向リンクリスト実装
- ✅ 文字列リテラルimport廃止

### ⏭️ v0.12.0 - Part 2（2026年3月予定）
**非同期処理とパターンマッチング**
- Event Loop
- Future<T>型
- パターンマッチング
- async/await構文
- ?オペレーター

詳細は `v0.11.0_implementation_roadmap.md` を参照。

---

## 🎯 v0.13.0以降の機能

### 1. 複合文 `{}` の変数スコープ対応

**優先度**: 🟡 中  
**リリース**: v0.13.0  
**見積もり**: 2週間  
**難易度**: ⭐⭐⭐⭐

#### 現状
v0.11.0では「デストラクタスコープ」を実装し、複合文でデストラクタとdeferのみを管理しています。
変数スコープは作成せず、変数はすべて関数スコープに属します。

#### 目標
C++/Rustスタイルの変数スコープを実装。

```cb
void main() {
    int x = 10;
    println(x);  // 10
    
    {
        int x = 20;  // ← 新しいスコープの変数
        println(x);  // 20
    }
    
    println(x);  // 10（外側のx）
}
```

#### 実装方針
1. **複合文のスコープ管理**
   - `AST_STATEMENT_LIST` の処理時に変数スコープを作成
   - ブロック終了時に `pop_scope()` を呼び出し

2. **スコープスタックの拡張**
   - 関数スコープと複合文スコープを区別
   - ネストしたブロックに対応

3. **変数の可視性**
   - ブロック内で宣言された変数はブロック外からアクセス不可
   - シャドーイングのサポート

#### 影響範囲
- `src/backend/interpreter/executors/statement_list_executor.cpp`
- `src/backend/interpreter/managers/variables/*.cpp`

#### 注意事項
**なぜv0.11.0で実装しなかったか**:
- デストラクタスコープで十分な機能性が得られた
- 変数スコープは破壊的変更になる可能性がある
- 既存のコードへの影響を最小化するため

---

### 2. Interface Bounds（型制約）の拡張

**優先度**: 🟢 低  
**リリース**: v0.13.0  
**見積もり**: 3週間  
**難易度**: ⭐⭐⭐⭐⭐

#### 現状
v0.11.0では基本的なジェネリクスを実装しましたが、型制約は限定的です。

#### 目標
Rustスタイルの型制約を実装。

**Union型制約**:
```cb
// 整数型のみ受け入れる
struct NumericBox<T: int | tiny | short | long> {
    T value;
}

void main() {
    NumericBox<int> box;     // ✅ OK
    NumericBox<string> err;  // ❌ エラー
}
```

**Interface制約**:
```cb
interface Printable {
    void print();
}

void print_all<T: Printable>(T item) {
    item.print();
}
```

**複数制約**:
```cb
interface Display {
    string to_string();
}

interface Debug {
    void debug();
}

void show<T: Display + Debug>(T value) {
    println(value.to_string());
    value.debug();
}
```

**where句**:
```cb
struct Container<T, U>
    where T: Display,
          U: Debug + Clone
{
    T first;
    U second;
}
```

#### 実装方針

**Phase 1: Union型制約（1週間）**
1. Union型制約の解析と検証
2. 制約違反の検出
3. テスト: 制約の検証

**Phase 2: Interface制約（1週間）**
1. Interface制約の解析
2. 実装チェック
3. エラーメッセージの改善

**Phase 3: 複数制約とwhere句（1週間）**
1. `+` 演算子のサポート
2. where句の解析
3. 複雑な制約の検証

#### 文法定義（BNF追加）
```bnf
<type_parameter> ::= <identifier> [ ':' <type_constraint> ]
<type_constraint> ::= <constraint_item> { '+' <constraint_item> }
<constraint_item> ::= <interface_name> | <type_union>
<type_union> ::= <type_specifier> { '|' <type_specifier> }

<where_clause> ::= 'where' <where_constraint> { ',' <where_constraint> }
<where_constraint> ::= <type_parameter> ':' <type_constraint>

<generic_struct> ::= 'struct' <identifier> <type_parameter_list> [ <where_clause> ] '{' ... '}'
```

#### テスト計画
- Union型制約: 20テスト
- Interface制約: 30テスト
- 複数制約: 20テスト
- where句: 15テスト
- エラーメッセージ: 15テスト

---

### 3. 型推論の強化

**優先度**: 🟢 低  
**リリース**: v0.13.0  
**見積もり**: 2週間  
**難易度**: ⭐⭐⭐⭐

#### 目標
関数呼び出し時の型パラメータ自動推論。

```cb
T max<T>(T a, T b) {
    if (a > b) {
        return a;
    }
    return b;
}

void main() {
    // 現状: 明示的に型を指定
    int i = max<int>(10, 20);
    
    // 目標: 型推論で省略可能
    int j = max(10, 20);  // intと推論
    long k = max(100L, 200L);  // longと推論
}
```

#### 実装方針
1. 引数の型から型パラメータを推論
2. 複数の型パラメータの推論
3. 制約との整合性チェック

---

### 4. ジェネリックInterface

**優先度**: 🟢 低  
**リリース**: v0.14.0  
**見積もり**: 3週間  
**難易度**: ⭐⭐⭐⭐⭐

#### 目標
Interfaceに型パラメータを持たせる。

```cb
interface Container<T> {
    void add(T item);
    T get(int index);
    int size();
}

struct List<T> {
    T[100] items;
    int count;
}

impl Container<T> for List<T> {
    void add(T item) {
        self.items[self.count] = item;
        self.count = self.count + 1;
    }
    
    T get(int index) {
        return self.items[index];
    }
    
    int size() {
        return self.count;
    }
}
```

#### 部分的なインスタンス化
```cb
// intに対してのみ実装
impl Container<int> for List<int> {
    // 特殊化された実装
}
```

---

### 5. ムーブセマンティクスの完全実装

**優先度**: 🟡 中  
**リリース**: v0.13.0  
**見積もり**: 3週間  
**難易度**: ⭐⭐⭐⭐⭐

#### 現状
v0.10.1で右辺値参照を実装しましたが、不完全です。

#### 目標
完全なムーブセマンティクスの実装。

**return文での自動ムーブ（NRVO）**:
```cb
Vector<int> create_vector() {
    Vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    return vec;  // ← 自動的にムーブされる（コピーなし）
}
```

**ムーブ代入演算子**:
```cb
impl Vector<T> {
    self&& operator=(self&& other) {
        // ムーブ代入
        self.data = other.data;
        self.length = other.length;
        other.data = nullptr;
        other.length = 0;
        return self;
    }
}
```

**右辺値の自動検出**:
```cb
Vector<int> vec1;
Vector<int> vec2 = vec1;         // コピー
Vector<int> vec3 = create_vector();  // ムーブ（自動）
```

#### 参考資料
- `docs/todo/v0.11.0_move_semantics_implementation.md`
- C++ move semantics
- Rust ownership system

---

### 6. エラーハンドリングの強化

**優先度**: 🟡 中  
**リリース**: v0.14.0  
**見積もり**: 4週間  
**難易度**: ⭐⭐⭐⭐

#### 目標
Rust風のエラーハンドリング。

**try-catch構文**:
```cb
try {
    Result<int, string> result = divide(10, 0);
    match (result) {
        Ok(value) => println("Result: ", value),
        Err(error) => throw error
    }
} catch (string error) {
    println("Error: ", error);
}
```

**?オペレーター**:
```cb
Result<int, string> complex_operation() -> Result<int, string> {
    int a = divide(10, 2)?;  // エラー時は早期リターン
    int b = divide(20, a)?;
    int c = divide(b, 3)?;
    return Ok(c);
}
```

#### 実装要素
1. try-catch構文の解析
2. throw文の実装
3. ?オペレーターの実装
4. スタックアンワインド
5. デストラクタの例外安全性

---

### 7. 並行処理

**優先度**: 🟢 低  
**リリース**: v0.15.0  
**見積もり**: 8週間  
**難易度**: ⭐⭐⭐⭐⭐

#### 目標
Go/Rustスタイルの軽量スレッド。

**goroutine風の軽量スレッド**:
```cb
void worker(int id) {
    println("Worker ", id, " running");
}

void main() {
    spawn worker(1);  // 新しいスレッドで実行
    spawn worker(2);
    spawn worker(3);
    
    // メインスレッドは待機
    sleep(1000);
}
```

**チャネル通信**:
```cb
void producer(Channel<int> ch) {
    for (int i = 0; i < 10; i = i + 1) {
        ch.send(i);
    }
    ch.close();
}

void consumer(Channel<int> ch) {
    while (true) {
        Option<int> value = ch.receive();
        match (value) {
            Some(v) => println("Received: ", v),
            None => break
        }
    }
}

void main() {
    Channel<int> ch = Channel<int>::new();
    spawn producer(ch);
    spawn consumer(ch);
}
```

#### 実装要素
1. スレッドプール
2. チャネルの実装
3. 同期プリミティブ（Mutex, RwLock）
4. デッドロック検出

---

### 8. コンパイラバックエンド

**優先度**: 🟢 低  
**リリース**: v1.0.0  
**見積もり**: 16週間  
**難易度**: ⭐⭐⭐⭐⭐

#### 目標
ネイティブコードの生成。

**LLVM IR生成**:
- Cb AST → LLVM IR
- 最適化パスの適用
- ネイティブコード生成

**利点**:
- インタプリタより高速
- AOT（Ahead-of-Time）コンパイル
- 実行ファイルの配布

#### 実装フェーズ
1. LLVM統合（4週間）
2. 基本的な文の変換（4週間）
3. ジェネリクスのサポート（4週間）
4. 最適化とテスト（4週間）

---

### 9. 所有権システムの強化

**優先度**: 🟢 低  
**リリース**: v1.0.0  
**見積もり**: 12週間  
**難易度**: ⭐⭐⭐⭐⭐

#### 目標
Rust風の借用チェッカー。

**借用チェック**:
```cb
void main() {
    Vector<int> vec;
    vec.push_back(10);
    
    Vector<int>& ref = &vec;  // 不変借用
    println(ref.get_length());
    
    vec.push_back(20);  // ❌ エラー: 不変借用中に変更不可
}
```

**ライフタイム注釈**:
```cb
struct Container<'a, T> {
    T& data;  // 'a は data のライフタイム
}

impl<'a, T> Container<'a, T> {
    self(T& data) {
        self.data = &data;
    }
}
```

#### 実装要素
1. 借用ルールの定義
2. ライフタイム推論
3. 借用チェッカーの実装
4. エラーメッセージの改善

---

## 📊 優先度マトリクス

| 機能 | 優先度 | リリース | 難易度 | 見積もり |
|-----|-------|---------|-------|---------|
| Event Loop | 🔴 高 | v0.12.0 | ⭐⭐⭐⭐⭐ | 4週間 |
| Future<T>型 | 🔴 高 | v0.12.0 | ⭐⭐⭐⭐⭐ | 3週間 |
| パターンマッチング | 🔴 高 | v0.12.0 | ⭐⭐⭐⭐ | 3週間 |
| async/await構文 | 🔴 高 | v0.12.0 | ⭐⭐⭐⭐⭐ | 4週間 |
| ?オペレーター | 🟡 中 | v0.12.0 | ⭐⭐⭐ | 1週間 |
| 変数スコープ | 🟡 中 | v0.13.0 | ⭐⭐⭐⭐ | 2週間 |
| Interface Bounds | 🟢 低 | v0.13.0 | ⭐⭐⭐⭐⭐ | 3週間 |
| 型推論強化 | 🟢 低 | v0.13.0 | ⭐⭐⭐⭐ | 2週間 |
| ムーブセマンティクス | � 中 | v0.13.0 | ⭐⭐⭐⭐⭐ | 3週間 |
| ジェネリックInterface | � 低 | v0.14.0 | ⭐⭐⭐⭐⭐ | 3週間 |
| エラーハンドリング | 🟡 中 | v0.14.0 | ⭐⭐⭐⭐ | 4週間 |
| 並行処理 | 🟢 低 | v0.15.0 | ⭐⭐⭐⭐⭐ | 8週間 |
| コンパイラバックエンド | 🟢 低 | v1.0.0 | ⭐⭐⭐⭐⭐ | 16週間 |
| 所有権システム | 🟢 低 | v1.0.0 | ⭐⭐⭐⭐⭐ | 12週間 |

---

## 🗺️ ロードマップ

### v0.12.0（2026年3月予定）- Part 2機能
- ✨ Event Loop
- ✨ Future<T>型
- ✨ パターンマッチング
- ✨ async/await構文
- ✨ ?オペレーター

### v0.13.0（2026年6月予定）- スコープと型制約
- ✨ 複合文の変数スコープ
- ✨ Interface Bounds（型制約）
- ✨ 型推論の強化
- ✨ ムーブセマンティクスの完全実装

### v0.14.0（2026年9月予定）- エラーハンドリング
- ✨ ジェネリックInterface
- ✨ エラーハンドリング強化（try-catch, ?演算子の拡張）
- ✨ 標準ライブラリの拡充

### v0.15.0（2026年12月予定）- 並行処理
- ✨ 並行処理（軽量スレッド、チャネル）
- ✨ パフォーマンス最適化

### v1.0.0（2027年予定）- 安定版
- ✨ コンパイラバックエンド（LLVM IR）
- ✨ 所有権システムの強化
- ✨ 言語仕様の安定化

---

## 📚 参考資料

### 言語設計
- **Rust**: 所有権、借用、ライフタイム
- **C++**: テンプレート、ムーブセマンティクス
- **Go**: 並行処理、goroutine、チャネル
- **Swift**: プロトコル、ジェネリクス

### 実装参考
- LLVM公式ドキュメント
- Rust Compiler Internals
- C++ Templates
- Go Runtime

---

## 🔗 関連ドキュメント

- `v0.11.0.md`: リリースノート
- `v0.11.0_implementation_roadmap.md`: Part 2の計画
- `v0.11.0_move_semantics_implementation.md`: ムーブセマンティクス詳細
- `v0.11.0_generics_spec.md`: ジェネリクス仕様

---

**作成者**: shadowlink0122  
**更新日**: 2025年11月3日
