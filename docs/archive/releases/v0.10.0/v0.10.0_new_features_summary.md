# v0.10.0 新機能追加サマリー

**追加日**: 2025年10月9日  
**対象バージョン**: v0.10.0

---

## 📋 追加された機能

v0.10.0の実装計画に以下の5つの新機能を追加しました:

### 1. コンストラクタ/デストラクタ 🔴 高優先度

**目的**: オブジェクトのライフサイクル管理を自動化

**主な機能**:
- `impl` ブロック内で `self()` をコンストラクタとして認識
- `impl` ブロック内で `~self()` をデストラクタとして認識
- `self` キーワードによるメンバーアクセス（既に実装済み）
- スコープ終了時の自動デストラクタ呼び出し
- 配列要素ごとのコンストラクタ/デストラクタ呼び出し
- コピーコンストラクタ: `self(const Point other)`
- ムーブコンストラクタ: `self(Point&& other)`
- private メンバーのサポート

**設計原則**:
- 構造体 (`struct`) はデータのみを定義
- コンストラクタ/デストラクタ/メソッドは `impl` ブロック内で定義
- `impl Struct {}` パターンで構造体用のimplを定義

**使用例**:
```cb
// データ定義
struct Point {
    int x;
    int y;
}

// 実装定義（コンストラクタ/デストラクタ/メソッド）
impl Point {
    // コンストラクタ（名前は"self"）
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    // デストラクタ（名前は"~self"）
    ~self() {
        println("Point destroyed");
    }
}

void main() {
    Point p(10, 20);  // コンストラクタ呼び出し
    // スコープ終了時にデストラクタ自動呼び出し
}
```

**呼び出し方法**:
```cb
Point p1;              // デフォルトコンストラクタ
Point p2(10, 20);      // パラメータ付きコンストラクタ
Point p3 = Point();    // 一時オブジェクト生成+コピー
Point p4 = Point(30, 40);  // 一時オブジェクト生成+ムーブ
```

**詳細**: 
- [仕様書](../features/constructor_destructor.md) - 完全な機能仕様
- [実装計画](v0.10.0_constructor_implementation.md) - 実装の詳細

---

### 2. デフォルト引数 🔴 高優先度

**目的**: 関数呼び出しの柔軟性向上、API設計の改善

**主な機能**:
- 関数パラメータにデフォルト値を設定
- 呼び出し時に引数を省略可能
- 右側から連続してデフォルト値を指定
- 定数式のみ許可

**使用例**:
```cb
func int add(int a, int b = 10, int c = 20) {
    return a + b + c;
}

void main() {
    println(add(1));        // 1 + 10 + 20 = 31
    println(add(1, 2));     // 1 + 2 + 20 = 23
    println(add(1, 2, 3));  // 1 + 2 + 3 = 6
}
```

**詳細**: [v0.10.0_default_arguments.md](v0.10.0_default_arguments.md)

---

### 3. デフォルトメンバ（default修飾子） 🔴 高優先度

**目的**: 構造体の利便性向上、型安全なラッパー型の実現

**主な機能**:
- 構造体に1つだけ `default` メンバーを設定可能
- 型推論による暗黙的アクセス（読み取り/書き込み）
- 構造体リテラル `{}` と基本型の代入を区別
- 関数引数での自動変換

**使用例**:
```cb
struct String {
    default string value;
};

void main() {
    String s = {"Hello"};
    
    // 暗黙的参照
    println(s);  // "Hello" (s.value として解釈)
    
    // 暗黙的代入
    s = "World";  // s.value = "World" として解釈
    println(s);   // "World"
    
    // 明示的アクセスも可能
    s.value = "Direct";
    
    // 構造体リテラル
    s = {"Explicit"};
}
```

**詳細**: [v0.10.0_default_member.md](v0.10.0_default_member.md)

---

### 4. 無名関数（ラムダ式） 🔴 高優先度

**目的**: 高階関数のサポート、コールバック関数の簡潔な記述

**主な機能**:
- `func` キーワードを式として使用
- 内部識別子の自動生成（重複エラーなし）
- 関数ポインタへの自動変換
- 高階関数やコールバックでの使用

**使用例**:
```cb
void main() {
    // 関数ポインタへの代入
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    println(add(5, 3));  // 8
    
    // 関数引数として
    apply(int func(int x) { return x * 2; }, 10);
    
    // 配列要素として
    int*[3] ops = [
        int func(int x) { return x + 1; },
        int func(int x) { return x * 2; },
        int func(int x) { return x * x; }
    ];
}
```

**詳細**: [v0.10.0_lambda_functions.md](v0.10.0_lambda_functions.md)

---

### 5. 無名変数（_ 識別子） 🟡 中優先度

**目的**: 将来のタプル実装への布石、意図の明確化

**主な機能**:
- `_` を無名変数として認識
- 代入・参照不可（値を無視する専用）
- 複数の `_` が同じスコープに存在可能
- 将来的なタプル分解での使用

**使用例**:
```cb
void main() {
    // 戻り値を無視（関数は実行される）
    int _ = compute();
    
    // 複数の無名変数
    int _ = 10;      // 内部: __discard_1
    string _ = "a";  // 内部: __discard_2
    
    // ❌ エラー: 参照不可
    // println(_);
    
    // ❌ エラー: 代入不可
    // _ = 20;
}

// 将来的な使用例（タプル実装後）
// (int value, _, float pi) = get_data();  // 第2戻り値を無視
```

**詳細**: [v0.10.0_discard_variable.md](v0.10.0_discard_variable.md)

---

### 6. defer文（Go言語スタイル） 🔴 高優先度

**目的**: リソース解放の確実な実行、クリーンアップコードの簡潔化

**主な機能**:
- スコープの最後に必ず実行される処理を登録
- 複数のdefer文がある場合は逆順（LIFO）で実行
- return、break、continueでスコープを抜けても実行される
- エラーが発生しても実行される

**使用例**:
```cb
void process_file(string path) {
    File f = open(path);
    defer close(f);  // 関数終了時に必ず実行
    
    if (error_check()) {
        return;  // ここで戻っても close(f) が実行される
    }
    
    // ファイル処理
    write(f, "data");
}

void multiple_defers() {
    defer println("1");  // 3番目に実行
    defer println("2");  // 2番目に実行
    defer println("3");  // 1番目に実行（最後のdeferが最初）
    println("main");     // 最初に実行
    // 出力: main, 3, 2, 1
}
```

**詳細**: ※仕様提示待ち

---

### 7. switch文 🔴 高優先度

**目的**: 多分岐処理の簡潔化、可読性向上

**主な機能**:
- `switch`, `case`, `else` キーワードでの分岐
- OR演算子（`||`）による複数値マッチング
- 範囲演算子（`...`）による範囲指定
- 自動break（fallthrough無し）
- ブロック必須構文

**使用例**:
```cb
void check_value(int x) {
    switch (x) {
        case (1) {
            println("one");
        } case (2 || 3) {
            println("two or three");
        } case (10...20) {
            println("ten to twenty");
        } else {
            println("other");
        }
    }
}

string get_grade(int score) {
    switch (score) {
        case (90...100) {
            return "A";
        } case (80...89) {
            return "B";
        } case (70...79) {
            return "C";
        } case (60...69) {
            return "D";
        } else {
            return "F";
        }
    }
}

void check_char(string c) {
    switch (c) {
        case ("a" || "e" || "i" || "o" || "u") {
            println("vowel");
        } case ("A"..."Z") {
            println("uppercase consonant");
        } else {
            println("other");
        }
    }
}
```

**主な特徴**:
- **OR演算子**: `case (2 || 3)` で複数の値をマッチング
- **範囲指定**: `case (10...20)` で範囲内の値をマッチング
- **elseブロック**: `default`の代わりに`else`を使用
- **自動break**: 各caseは自動的に終了（fallthrough無し）
- **ブロック必須**: 各caseは`{}`ブロックで囲む
- **ユニオン型対応**: ユニオン型のswitch式では型混在のcaseが可能

**型の扱い**:
```cb
// ✅ 通常型: 同じ型のみ
int x = 5;
switch (x) {
    case (1 || 2 || 3) { }  // OK
}

// ✅ ユニオン型: 型混在可能
union Value {
    int num;
    string str;
};
Value v = /* ... */;
switch (v) {
    case (1 || "text") {  // OK: ユニオン型なら型混在可
        println("matched");
    }
}

// ❌ 通常型で型混在はエラー
int x = 5;
switch (x) {
    case (1 || "two") { }  // エラー
}
```

**詳細**: ※実装ドキュメント作成予定

---

### 8. import/export（モジュールシステム） 🟡 中優先度

**目的**: モジュール間の依存関係管理、名前空間の整理、コードの再利用性向上

**主な機能**:
- `export`キーワードで関数/構造体/インターフェース/型/定数/変数を公開
- `default export`で1ファイル1つのデフォルトエクスポート
- `import`キーワードでドット記法によるモジュール読み込み
- 依存関係の自動解決（使用される関数・定数の自動登録）
- 未使用コードの除外によるパフォーマンス最適化

**exportルール**:

```cb
// stdlib/math/basic.cb

// 1. default export（ファイルに1つのみ）
default export int add(int a, int b) {
    return a + b;
}

// 2. 個別export（複数可能）
export int multiply(int a, int b) {
    return a * b;
}

export const int PI = 3.14159;

export struct Point {
    int x;
    int y;
};

export interface Drawable {
    void draw();
};

// 3. まとめてexport
int subtract(int a, int b) {
    return a - b;
}

float divide(float a, float b) {
    return a / b;
}

export {
    subtract,
    divide
};

// exportできないもの（実装のみ）
impl Point {
    Point(int px, int py) {  // コンストラクタ
        self.x = px;
        self.y = py;
    }
    
    ~Point() { }  // デストラクタ
};

// プライベート関数（exportなし）
int helper() {
    return 42;
}
```

**importルール**:

```cb
// main.cb

// 1. 個別インポート（モジュール単位）
import stdlib.math.basic.multiply;  // multiply()で呼び出し
import stdlib.math.basic.PI;        // PIで呼び出し

// 2. default exportの読み込み（ファイル単位）
import stdlib.math.basic;           // basic()で呼び出し（関数の場合）
                                    // basicで呼び出し（定数の場合）

// 3. まとめてimport
import stdlib.math.basic {
    multiply,
    subtract,
    PI,
    Point
};

// 4. as を使った名前空間エイリアス（TypeScript風）
import stdlib.math.basic as math;
math.multiply(5, 3);
math.PI;

// 5. 複数のasを使ったimport
import stdlib.math.basic {
    multiply as mul,
    subtract as sub
};
mul(5, 3);
sub(10, 3);

// 6. GitHub URL（優先度低、今回は実装しない）
// import "github.com/user/repo/module";

void main() {
    // default exportの使用
    int sum = basic(5, 3);  // add関数
    
    // 個別importの使用
    int product = multiply(5, 3);
    int diff = subtract(10, 3);
    println(PI);
    
    Point p;
    p.x = 10;
}
```

**名前空間（namespace）**:

```cb
// stdlib/io.cb
namespace std {
    void print(string msg) {
        println(msg);
    }
    
    struct Console {
        int level;
    };
}

// main.cb
import stdlib.io;

void main() {
    std::print("Hello");  // C++スタイルの::演算子
    
    std::Console console;
    console.level = 1;
}
```

**モジュール検索パス**:
1. **プロジェクトルート（実行箇所）**: `./`
2. **modulesディレクトリ**: `./modules/`
3. **将来的に拡張**: `cb_config.json`で追加パスを指定可能

```cb
// プロジェクト構造
project/
  ├── main.cb
  ├── modules/
  │   └── utils/
  │       └── helper.cb
  └── cb_config.json (将来)

// main.cbから
import modules.utils.helper;  // OK: modulesディレクトリから
import utils.helper;          // OK: modules/を省略可能
```

**`as`キーワードの2つの用途**:

```cb
// 1. import文での名前変更（TypeScript風）
import stdlib.math.basic as math;
import stdlib.io { print as output };

math.add(1, 2);
output("Hello");

// 2. 型キャスト（Rust風）
int x = 10;
float y = x as float;        // intからfloatへキャスト

void* ptr = get_memory();
int* int_ptr = ptr as int*;  // void*からint*へキャスト

// 基本型のキャスト
int a = 10;
float b = a as float;        // 10.0
string s = a as string;      // "10"

// 構造体のキャスト（メンバが完全一致する場合）
struct Point2D {
    int x;
    int y;
}

struct Vector2D {
    int x;
    int y;
}

Point2D p = {10, 20};
Vector2D v = p as Vector2D;  // OK: メンバの型・サイズ・順序が一致

// typedefやユニオンも同様
typedef struct { float x; float y; } Position;
typedef struct { float x; float y; } Velocity;

Position pos = {1.0, 2.0};
Velocity vel = pos as Velocity;  // OK

// エラーケース
struct Point3D { int x; int y; int z; }
Point3D p3 = p as Point3D;  // エラー: メンバ数が異なる

struct FloatPoint { float x; float y; }
FloatPoint fp = p as FloatPoint;  // エラー: メンバの型が異なる

// パーサーは文脈で判定
// - import文内: 名前変更
// - 式内: 型キャスト
```

**型キャストの設計方針**:

| 変換 | 許可 | 備考 |
|------|------|------|
| 数値 → 数値 | ✅ | 範囲外は警告 |
| 数値 → string | ✅ | 文字列に変換 |
| ポインタ → ポインタ | ✅ | void*から任意のポインタへ |
| 構造体 → 構造体 | ✅ | メンバ構造が完全一致する場合のみ |
| typedef構造体 → typedef構造体 | ✅ | メンバ構造が完全一致する場合のみ |
| ユニオン → ユニオン | ✅ | サイズとアライメントが一致する場合 |

**構造体キャストの許可条件**:
1. メンバ数が完全一致
2. 各メンバの型が完全一致
3. メンバの宣言順序が一致
4. 構造体全体のサイズが一致（padding含む）
5. 各メンバのオフセット位置が一致

**exportできる要素**:
- ✅ 関数
- ✅ 構造体（struct）
- ✅ インターフェース（interface）
- ✅ 型エイリアス（typedef）
- ✅ 定数（const）
- ✅ グローバル変数
- ✅ namespace（名前空間全体をexport可能）
- ❌ impl ブロック（実装は自動的に含まれる）
- ❌ コンストラクタ/デストラクタ（実装は自動的に含まれる）

**依存関係の自動解決**:
```cb
// math.cb
export int complexCalc(int x) {
    return helper1(x) + helper2(x);  // 内部でhelper1, helper2を使用
}

int helper1(int x) {  // exportしていないが使用される
    return x * 2;
}

int helper2(int x) {  // exportしていないが使用される
    return x + 10;
}

int unused() {  // 使用されないので登録されない
    return 999;
}

// main.cb
import math.complexCalc;

void main() {
    int result = complexCalc(5);
    // helper1, helper2は自動的にASTに登録される
    // unusedは登録されない（パフォーマンス最適化）
}
```

**実装の最適化戦略**:
1. **依存関係解析**: exportされた関数・定数から使用される要素を再帰的に解析
2. **選択的AST登録**: 実際に使用される要素のみをASTに登録
3. **未使用コード除外**: 使用されない関数・定数はASTから除外
4. **循環依存検出**: モジュール間の循環参照を検出しエラー報告

**詳細**: ※実装ドキュメント作成予定

---

## 📅 実装スケジュール

### Phase 2: 高優先度機能（新規追加）

1. **コンストラクタ/デストラクタ** - 推定6週間
   - Phase 1: 基本構造（2週間）
   - Phase 2: コンストラクタ実装（2週間）
   - Phase 3: デストラクタ実装（2週間）
   - Phase 4: テストと検証（1週間）

2. **デフォルト引数** - 推定4週間
   - Phase 1: 構文解析（1週間）
   - Phase 2: 型チェック（1週間）
   - Phase 3: 実行時処理（1週間）
   - Phase 4: テストと検証（1週間）

3. **デフォルトメンバ** - 推定5週間
   - Phase 1: 基本構造（1週間）
   - Phase 2: 型チェック（1週間）
   - Phase 3: 暗黙的変換（2週間）
   - Phase 4: テストと検証（1週間）

4. **無名関数（ラムダ式）** - 推定6週間
   - Phase 1: 基本構造（2週間）
   - Phase 2: 式としての統合（2週間）
   - Phase 3: 型チェック（1週間）
   - Phase 4: テストと検証（1週間）

5. **無名変数（_ 識別子）** - 推定4週間
   - Phase 1: 基本実装（1週間）
   - Phase 2: エラー検出（1週間）
   - Phase 3: 最適化（1週間）
   - Phase 4: テストと検証（1週間）

6. **defer文** - 推定5週間
   - Phase 1: 基本構造（1週間）
   - Phase 2: スタック管理（2週間）
   - Phase 3: 制御フローとの統合（1週間）
   - Phase 4: テストと検証（1週間）

7. **switch文** - 推定5週間
   - Phase 1: 構文解析（1週間）
   - Phase 2: 分岐処理（2週間）
   - Phase 3: 最適化（1週間）
   - Phase 4: テストと検証（1週間）

8. **import/export** - 推定8週間
   - Phase 1: 基本設計（2週間）
   - Phase 2: export実装（2週間）
   - Phase 3: import実装（2週間）
   - Phase 4: 名前空間管理（1週間）
   - Phase 5: テストと検証（1週間）

**合計**: 約43週間（約10ヶ月）

---

## 🎯 期待される効果

### コンストラクタ/デストラクタ
- ✅ リソース管理の自動化
- ✅ 初期化忘れの防止
- ✅ オブジェクト指向プログラミングの基盤

### デフォルト引数
- ✅ API設計の柔軟性向上
- ✅ 後方互換性を保った機能拡張
- ✅ コードの簡潔化

### デフォルトメンバ
- ✅ 型安全なラッパー型の実現
- ✅ 構造体の透過的な使用
- ✅ ドメイン固有型の簡潔な記述

### 無名関数（ラムダ式）
- ✅ 高階関数のサポート
- ✅ コールバック関数の簡潔な記述
- ✅ 関数型プログラミングスタイルの導入

### 無名変数（_ 識別子）
- ✅ 意図の明確化（値を使わないことを明示）
- ✅ 未使用変数警告の回避
- ✅ 将来のタプル分解への布石

### defer文
- ✅ リソース管理の確実性向上
- ✅ クリーンアップコードの簡潔化
- ✅ エラー時でも確実に実行される処理
- ✅ コードの可読性向上（リソース確保とクリーンアップを近くに記述）

### switch文
- ✅ 多分岐処理の簡潔化
- ✅ if-else チェーンより可読性が高い
- ✅ コンパイラによる最適化の可能性
- ✅ 状態遷移などの実装が容易

### import/export
- ✅ モジュール化による保守性向上
- ✅ 名前空間の整理
- ✅ 再利用性の向上
- ✅ 大規模プロジェクトへの対応

---

## 📚 関連ドキュメント

- [v0.10.0 実装計画](v0.10.0_implementation_plan.md) - メインの実装計画
- [v0.10.0 コンストラクタ/デストラクタ](v0.10.0_constructor_destructor.md) - 詳細設計
- [v0.10.0 デフォルト引数](v0.10.0_default_arguments.md) - 詳細設計
- [v0.10.0 デフォルトメンバ](v0.10.0_default_member.md) - 詳細設計
- [v0.10.0 無名関数（ラムダ式）](v0.10.0_lambda_functions.md) - 詳細設計
- [v0.10.0 無名変数（_ 識別子）](v0.10.0_discard_variable.md) - 詳細設計

---

## 🔄 更新履歴

- 2025/10/09: 初版作成 - 3つの新機能を追加
  - コンストラクタ/デストラクタ
  - デフォルト引数
  - デフォルトメンバ（default修飾子）
- 2025/10/09: コンストラクタ/デストラクタをimpl内定義に変更
  - 構造体はデータのみを定義する設計方針に統一
- 2025/10/09: 2つの新機能を追加
  - 無名関数（ラムダ式）
  - 無名変数（_ 識別子）
- 2025/10/11: 修正と追加
  - `this` → `self` に修正（既に実装済み）
  - defer文を追加（Go言語スタイル）
  - switch文を追加（OR演算子、範囲演算子対応）
  - import/export（モジュールシステム）を追加（詳細仕様確定）
  - 関数定義の構文を修正（`func`キーワードはラムダ式のみ）
  - 実装済み機能を削除（多次元配列ポインタ、constポインタ、多重ポインタ、構造体配列メンバー代入など）
- 2025/10/11: コンストラクタ/デストラクタの詳細仕様を確定
  - コンストラクタ名を `self` に統一
  - デストラクタ名を `~self` に統一
  - コピー/ムーブコンストラクタの仕様追加
  - private メンバーの仕様追加
  - 完全な仕様書と実装計画を作成

````
