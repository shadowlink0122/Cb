# è‡ªå·±å‚ç…§ãƒ»å¾ªç’°å‚ç…§ãƒ»å‚ç…§ä»•æ§˜ã®å®Ÿè£…ã¨æ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆ

å®Ÿè£…æ—¥: 2025å¹´10æœˆ5æ—¥

## ğŸ“‹ æ¦‚è¦

ä»¥ä¸‹ã®3ã¤ã®æ©Ÿèƒ½ã‚’å®Ÿè£…ãƒ»æ¤œè¨¼ã—ã¾ã—ãŸï¼š

1. **è‡ªå·±å‚ç…§æ§‹é€ ä½“ã®ãƒã‚¤ãƒ³ã‚¿å‹ãƒã‚§ãƒƒã‚¯** - âœ… å®Ÿè£…å®Œäº†
2. **å¾ªç’°å‚ç…§ã®æ¤œå‡º**ï¼ˆå€¤ãƒ¡ãƒ³ãƒãƒ¼ã®ã¿ï¼‰ - âš ï¸ å‰æ–¹å®£è¨€æœªå¯¾å¿œã®ãŸã‚åˆ¶é™ã‚ã‚Š
3. **å‚ç…§ï¼ˆ&ï¼‰ã®ä»•æ§˜ç¢ºèª** - âœ… æ­£ã—ãå®Ÿè£…æ¸ˆã¿

---

## ğŸ¯ 1. è‡ªå·±å‚ç…§æ§‹é€ ä½“ã®ãƒã‚¤ãƒ³ã‚¿å‹ãƒã‚§ãƒƒã‚¯

### å®Ÿè£…å†…å®¹

æ§‹é€ ä½“ãŒè‡ªåˆ†è‡ªèº«ã®å‹ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’æŒã¤å ´åˆã€ãã®ãƒ¡ãƒ³ãƒãƒ¼ã¯**ãƒã‚¤ãƒ³ã‚¿å‹**ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†åˆ¶ç´„ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãƒã‚§ãƒƒã‚¯ã€‚

### ãƒ†ã‚¹ãƒˆçµæœ

#### âŒ ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹: å€¤ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦è‡ªå·±å‚ç…§
```cb
struct Node {
    int value;
    Node child;  // âŒ ã‚¨ãƒ©ãƒ¼
};
```

**ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**:
```
Error: Self-recursive struct member 'child' must be a pointer type. 
       Use 'Node* child;' instead of 'Node child;'
```

#### âœ… OKã‚±ãƒ¼ã‚¹: ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹è‡ªå·±å‚ç…§
```cb
struct Node {
    int value;
    Node* next;  // âœ… OK
};
```

**å®Ÿè¡Œçµæœ**:
```
Node value:  3
Node value:  2
Node value:  1
Sum:  6
```

### çŠ¶æ…‹

âœ… **å®Œå…¨å‹•ä½œ** - è‡ªå·±å‚ç…§ã®ãƒã‚§ãƒƒã‚¯ã¯æ­£ã—ãæ©Ÿèƒ½ã—ã¦ã„ã¾ã™ã€‚

---

## ğŸ”„ 2. å¾ªç’°å‚ç…§ã®æ¤œå‡º

### å®Ÿè£…å†…å®¹

è¤‡æ•°ã®æ§‹é€ ä½“é–“ã§ã®å¾ªç’°å‚ç…§ï¼ˆå€¤ãƒ¡ãƒ³ãƒãƒ¼ã®ã¿ï¼‰ã‚’æ¤œå‡ºã™ã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚

#### å®Ÿè£…ã•ã‚ŒãŸãƒã‚§ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯

```cpp
bool RecursiveParser::detectCircularReference(const std::string& struct_name, 
                                             const std::string& member_type,
                                             std::unordered_set<std::string>& visited,
                                             std::vector<std::string>& path);
```

**æ©Ÿèƒ½**:
- ã‚°ãƒ©ãƒ•ç†è«–ã‚’ç”¨ã„ãŸå¾ªç’°æ¤œå‡ºï¼ˆDFSï¼‰
- ãƒã‚¤ãƒ³ã‚¿ãƒ¡ãƒ³ãƒãƒ¼ã¯ã‚°ãƒ©ãƒ•ã«å«ã‚ãªã„ï¼ˆãƒ¡ãƒ¢ãƒªç™ºæ•£ã—ãªã„ãŸã‚ï¼‰
- é…åˆ—ãƒ¡ãƒ³ãƒãƒ¼ã‚‚ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå›ºå®šã‚µã‚¤ã‚ºï¼‰
- å€¤ãƒ¡ãƒ³ãƒãƒ¼ã®ã¿ã‚’è¾¿ã£ã¦å¾ªç’°ã‚’æ¤œå‡º

### åˆ¶é™äº‹é …

#### âš ï¸ å‰æ–¹å®£è¨€æœªå¯¾å¿œ

ç¾åœ¨ã®Cbè¨€èªã¯**æ§‹é€ ä½“ã®å‰æ–¹å®£è¨€ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“**ã€‚

**å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰**:
```cb
// A -> B -> A ã®å¾ªç’°å‚ç…§ã‚’ä½œã‚ã†ã¨ã™ã‚‹ã¨...

struct A {
    int value;
    B member_b;  // âŒ ã‚¨ãƒ©ãƒ¼: 'B' is not defined yet
};

struct B {
    int data;
    A member_a;  // Aã¯å®šç¾©æ¸ˆã¿ã ãŒBã‹ã‚‰Aã¸ã®å‚ç…§
};
```

**é †åºã‚’å¤‰ãˆã¦ã‚‚**:
```cb
struct B {
    int data;
    A member_a;  // âŒ ã‚¨ãƒ©ãƒ¼: 'A' is not defined yet
};

struct A {
    int value;
    B member_b;
};
```

ã©ã¡ã‚‰ã®é †åºã§ã‚‚ã€ç‰‡æ–¹ãŒæœªå®šç¾©ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚

#### ç¾åœ¨å‹•ä½œã™ã‚‹å¾ªç’°å‚ç…§æ¤œå‡º

**è‡ªå·±å‚ç…§ã®ã¿**ãŒæ¤œå‡ºå¯èƒ½ï¼š

```cb
struct Node {
    int value;
    Node child;  // âŒ è‡ªå·±å†å¸°ã‚¨ãƒ©ãƒ¼
};
```

ã“ã‚Œã¯`struct_name == member_type`ã®ãƒã‚§ãƒƒã‚¯ã§æ¤œå‡ºã•ã‚Œã¾ã™ã€‚

#### ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹å¾ªç’°ã¯è¨±å¯ã•ã‚Œã‚‹ï¼ˆç†è«–ä¸Šï¼‰

```cb
struct B {
    int data;
    A* member_a;  // ãƒã‚¤ãƒ³ã‚¿ãªã‚‰å‰æ–¹å‚ç…§å¯èƒ½ï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰
};

struct A {
    int value;
    B* member_b;  // ãƒã‚¤ãƒ³ã‚¿ãªã‚‰å¾ªç’°OK
};
```

**ç¾çŠ¶**: å‰æ–¹å®£è¨€ãŒæœªå®Ÿè£…ã®ãŸã‚ã€ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚å‹•ä½œã—ã¾ã›ã‚“ã€‚

### å°†æ¥ã®æ‹¡å¼µ

å‰æ–¹å®£è¨€ãŒå®Ÿè£…ã•ã‚Œã‚Œã°ã€ä»¥ä¸‹ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ï¼š

```cb
// å‰æ–¹å®£è¨€ï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰
struct B;  // forward declaration

struct A {
    int value;
    B* member_b;  // âœ… OK: ãƒã‚¤ãƒ³ã‚¿ãªã‚‰å‰æ–¹å‚ç…§å¯èƒ½
};

struct B {
    int data;
    A* member_a;  // âœ… OK: ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹å¾ªç’°
};
```

### å®Ÿè£…ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã®å‹•ä½œ

å¾ªç’°å‚ç…§æ¤œå‡ºã‚³ãƒ¼ãƒ‰ã¯å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€ä»¥ä¸‹ã®ãƒ­ã‚¸ãƒƒã‚¯ã§å‹•ä½œã—ã¾ã™ï¼š

1. **è‡ªå·±å†å¸°ãƒã‚§ãƒƒã‚¯**: `struct_name == member_type`
2. **å¾ªç’°ãƒã‚§ãƒƒã‚¯**: DFSã§å€¤ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¾¿ã‚Šã€é–‹å§‹æ§‹é€ ä½“ã«æˆ»ã‚‹ãƒ‘ã‚¹ã‚’æ¤œå‡º
3. **ãƒã‚¤ãƒ³ã‚¿é™¤å¤–**: `member.is_pointer` ãŒtrueã®ãƒ¡ãƒ³ãƒãƒ¼ã¯ã‚¹ã‚­ãƒƒãƒ—
4. **é…åˆ—é™¤å¤–**: å›ºå®šã‚µã‚¤ã‚ºé…åˆ—ã¯ã‚¹ã‚­ãƒƒãƒ—

**ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¾‹**ï¼ˆå°†æ¥ã®å‰æ–¹å®£è¨€å®Ÿè£…å¾Œï¼‰:
```
Error: Circular reference detected in struct value members: A -> B -> C -> A. 
       Use pointers to break the cycle.
```

### çŠ¶æ…‹

âš ï¸ **éƒ¨åˆ†å®Ÿè£…** - ã‚³ãƒ¼ãƒ‰ã¯å®Ÿè£…æ¸ˆã¿ã ãŒã€å‰æ–¹å®£è¨€æœªå¯¾å¿œã®ãŸã‚å®Ÿç”¨çš„ã«ã¯è‡ªå·±å‚ç…§ã®ã¿æ¤œå‡ºå¯èƒ½ã€‚

---

## ğŸ“Œ 3. å‚ç…§ï¼ˆ&ï¼‰ã®ä»•æ§˜ç¢ºèª

### ä»•æ§˜

C++ã¨åŒæ§˜ã®å‚ç…§ä»•æ§˜ï¼š
- **åˆæœŸåŒ–æ™‚ã«1å›ã ã‘æŸç¸›**
- **å†ä»£å…¥ã¯å‚ç…§å…ˆã®å€¤ã‚’å¤‰æ›´**
- **å‚ç…§è‡ªä½“ã®å†æŸç¸›ã¯ä¸å¯**

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

```cb
int main() {
    int a = 10;
    int b = 20;
    int c = 30;
    
    // å‚ç…§ã®åˆæœŸåŒ–
    int& ref = a;  // refã¯aã‚’å‚ç…§
    
    // å‚ç…§çµŒç”±ã§å€¤ã‚’å¤‰æ›´
    ref = b;  // ã“ã‚Œã¯ã€Œref = bã€ã§ã¯ãªãã€Œa = bã€ã®æ„å‘³ï¼ˆaã«20ã‚’ä»£å…¥ï¼‰
    
    assert(a == 20);  // âœ… aãŒ20ã«å¤‰ã‚ã£ã¦ã„ã‚‹
    assert(ref == 20); // âœ… refã‚‚20
    
    // ã•ã‚‰ã«å€¤ã‚’å¤‰æ›´
    ref = c;  // ã€Œa = cã€ã®æ„å‘³ï¼ˆaã«30ã‚’ä»£å…¥ï¼‰
    
    assert(a == 30);  // âœ… aãŒ30ã«å¤‰ã‚ã£ã¦ã„ã‚‹
    assert(ref == 30); // âœ… refã‚‚30
    
    // ç›´æ¥ä»£å…¥
    ref = 100;  // ã€Œa = 100ã€ã®æ„å‘³
    
    assert(a == 100); // âœ… aãŒ100ã«å¤‰ã‚ã£ã¦ã„ã‚‹
    
    return 0;
}
```

### å®Ÿè¡Œçµæœ

```
Initial state:
a =  10 , b =  20 , c =  30
ref =  10

After ref = b:
a =  20 , b =  20
ref =  20

After ref = c:
a =  30 , c =  30
ref =  30

After ref = 100:
a =  100
ref =  100

Reference semantics test passed
Conclusion: ref = value always modifies the referenced variable
References cannot be rebound to different variables
```

### å®Ÿè£…ã®å‹•ä½œ

#### å‚ç…§ã®åˆæœŸåŒ–

```cpp
// variable_manager.cpp: process_var_decl_or_assign()

// å‚ç…§å¤‰æ•°ã‚’ä½œæˆ
Variable ref_var;
ref_var.is_reference = true;
ref_var.type = target_var->type;

// å‚ç…§å…ˆå¤‰æ•°ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å€¤ã¨ã—ã¦ä¿å­˜
ref_var.value = reinterpret_cast<int64_t>(target_var);
```

#### å‚ç…§çµŒç”±ã®ä»£å…¥

```cpp
// variable_manager.cpp: assign_variable()

// å‚ç…§å¤‰æ•°ã¸ã®ä»£å…¥ã®å ´åˆã€å‚ç…§å…ˆå¤‰æ•°ã«ä»£å…¥
Variable* var = interpreter_->find_variable(name);
if (var && var->is_reference) {
    Variable* target_var = reinterpret_cast<Variable*>(var->value);
    // target_varã«å€¤ã‚’ä»£å…¥ï¼ˆå‚ç…§ã®å†æŸç¸›ã§ã¯ãªã„ï¼‰
    target_var->value = numeric_value;
    target_var->is_assigned = true;
}
```

### ä»•æ§˜ã®ç¢ºèªçµæœ

âœ… **æ­£ã—ãå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™**:

| æ©Ÿèƒ½ | ä»•æ§˜ | å®Ÿè£… | çŠ¶æ…‹ |
|------|------|------|------|
| åˆæœŸåŒ–å¿…é ˆ | å‚ç…§ã¯å®£è¨€æ™‚ã«åˆæœŸåŒ–å¿…é ˆ | âœ… ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ | OK |
| 1å›ã ã‘æŸç¸› | åˆæœŸåŒ–æ™‚ã«å‚ç…§å…ˆãŒæ±ºå®š | âœ… `ref_var.value` ã«ä¿å­˜ | OK |
| å†ä»£å…¥ã¯å€¤å¤‰æ›´ | `ref = value` ã¯ `*ref = value` | âœ… `target_var->value = ...` | OK |
| å†æŸç¸›ä¸å¯ | åˆ¥ã®å¤‰æ•°ã¸ã®å‚ç…§å¤‰æ›´ä¸å¯ | âœ… å¸¸ã«`target_var`ã«ä»£å…¥ | OK |

---

## ğŸ“Š å®Ÿè£…çµ±è¨ˆ

### ã‚³ãƒ¼ãƒ‰å¤‰æ›´

| ãƒ•ã‚¡ã‚¤ãƒ« | å¤‰æ›´å†…å®¹ | è¡Œæ•° |
|---------|---------|------|
| `recursive_parser.h` | å¾ªç’°å‚ç…§æ¤œå‡ºé–¢æ•°å®£è¨€ã€includeè¿½åŠ  | +8 |
| `recursive_parser.cpp` | å¾ªç’°å‚ç…§æ¤œå‡ºå®Ÿè£…ã€ãƒã‚§ãƒƒã‚¯è¿½åŠ  | +100 |
| åˆè¨ˆ | | +108 |

### ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«

| ãƒ•ã‚¡ã‚¤ãƒ« | å†…å®¹ | çµæœ |
|---------|------|------|
| `self_recursive_ok.cb` | å˜æ–¹å‘ãƒªã‚¹ãƒˆ | âœ… PASS |
| `self_recursive_error.cb` | è‡ªå·±å†å¸°å€¤ãƒ¡ãƒ³ãƒãƒ¼ | âŒ ã‚¨ãƒ©ãƒ¼æ¤œå‡º |
| `typedef_self_recursive_ok.cb` | äºŒåˆ†æœ¨ | âœ… PASS |
| `typedef_self_recursive_error.cb` | typedefè‡ªå·±å†å¸° | âŒ ã‚¨ãƒ©ãƒ¼æ¤œå‡º |
| `circular_reference_error.cb` | è‡ªå·±å‚ç…§ï¼ˆå¾ªç’°ã®ç‰¹æ®Šã‚±ãƒ¼ã‚¹ï¼‰ | âŒ ã‚¨ãƒ©ãƒ¼æ¤œå‡º |
| `reference_semantics.cb` | å‚ç…§ã®ä»•æ§˜ç¢ºèª | âœ… PASS |

### ãƒ†ã‚¹ãƒˆçµæœ

```
Total Integration Tests: 2229
Unit Tests: 50
Success Rate: 100% (2229/2229) âœ…
```

---

## ğŸ”§ æŠ€è¡“è©³ç´°

### å¾ªç’°å‚ç…§æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

#### DFSï¼ˆæ·±ã•å„ªå…ˆæ¢ç´¢ï¼‰ã«ã‚ˆã‚‹å®Ÿè£…

```cpp
bool detectCircularReference(const string& struct_name, 
                            const string& member_type,
                            unordered_set<string>& visited,
                            vector<string>& path) {
    // 1. å‹åã‚’æ­£è¦åŒ–
    string normalized_type = member_type;
    if (normalized_type.rfind("struct ", 0) == 0) {
        normalized_type = normalized_type.substr(7);
    }
    
    // 2. æ§‹é€ ä½“å‹ã§ãªã‘ã‚Œã°å¾ªç’°ãªã—
    if (struct_definitions_.find(normalized_type) == struct_definitions_.end()) {
        return false;
    }
    
    // 3. é–‹å§‹æ§‹é€ ä½“ã«æˆ»ã£ã¦ããŸã‚‰å¾ªç’°æ¤œå‡º â˜…
    if (normalized_type == struct_name) {
        path.push_back(normalized_type);
        return true;
    }
    
    // 4. æ—¢ã«è¨ªå•æ¸ˆã¿ãªã‚‰å¾ªç’°ãªã—
    if (visited.find(normalized_type) != visited.end()) {
        return false;
    }
    
    // 5. è¨ªå•ãƒãƒ¼ã‚¯
    visited.insert(normalized_type);
    path.push_back(normalized_type);
    
    // 6. ãƒ¡ãƒ³ãƒãƒ¼ã‚’å†å¸°çš„ã«ãƒã‚§ãƒƒã‚¯
    const StructDefinition& struct_def = struct_definitions_[normalized_type];
    for (const auto& member : struct_def.members) {
        // ãƒã‚¤ãƒ³ã‚¿ãƒ»é…åˆ—ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (member.is_pointer || member.array_info.is_array()) {
            continue;
        }
        
        // å†å¸°å‘¼ã³å‡ºã—
        if (detectCircularReference(struct_name, member.type_alias, visited, path)) {
            return true;
        }
    }
    
    // 7. ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯
    path.pop_back();
    visited.erase(normalized_type);
    
    return false;
}
```

#### ã‚°ãƒ©ãƒ•ç†è«–çš„è§£é‡ˆ

- **ãƒãƒ¼ãƒ‰**: æ§‹é€ ä½“å®šç¾©
- **ã‚¨ãƒƒã‚¸**: å€¤ãƒ¡ãƒ³ãƒãƒ¼ï¼ˆãƒã‚¤ãƒ³ã‚¿ã‚’é™¤ãï¼‰
- **æ¤œå‡º**: æœ‰å‘ã‚°ãƒ©ãƒ•ã®é–‰è·¯æ¤œå‡º
- **æ™‚é–“è¨ˆç®—é‡**: O(V + E)ï¼ˆV=æ§‹é€ ä½“æ•°ã€E=ãƒ¡ãƒ³ãƒãƒ¼æ•°ï¼‰

### å‚ç…§ã®å†…éƒ¨å®Ÿè£…

#### ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

```cpp
struct Variable {
    bool is_reference;         // å‚ç…§ãƒ•ãƒ©ã‚°
    int64_t value;            // é€šå¸¸: å€¤ã€å‚ç…§: ãƒã‚¤ãƒ³ã‚¿
    // ...
};

// å‚ç…§ã®ä½œæˆ
Variable ref_var;
ref_var.is_reference = true;
ref_var.value = reinterpret_cast<int64_t>(target_var);
```

#### ãƒã‚¤ãƒ³ã‚¿ã¨ã®é•ã„

| ç‰¹æ€§ | å‚ç…§ï¼ˆ&ï¼‰ | ãƒã‚¤ãƒ³ã‚¿ï¼ˆ*ï¼‰ |
|------|----------|--------------|
| nullè¨±å¯ | âŒ ä¸å¯ | âœ… å¯èƒ½ |
| å†æŸç¸› | âŒ ä¸å¯ | âœ… å¯èƒ½ |
| åˆæœŸåŒ–å¿…é ˆ | âœ… å¿…é ˆ | âŒ ä»»æ„ |
| ãƒ‡ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ | è‡ªå‹• | æ˜ç¤ºçš„ï¼ˆ`*ptr`ï¼‰ |
| ã‚¢ãƒ‰ãƒ¬ã‚¹æ¼”ç®— | âŒ ä¸å¯ | âœ… å¯èƒ½ |
| å†…éƒ¨å®Ÿè£… | ãƒã‚¤ãƒ³ã‚¿ | ãƒã‚¤ãƒ³ã‚¿ |

---

## ğŸ¯ ã¾ã¨ã‚

### é”æˆé …ç›®

| æ©Ÿèƒ½ | çŠ¶æ…‹ | å‚™è€ƒ |
|------|------|------|
| âœ… è‡ªå·±å‚ç…§ãƒã‚¤ãƒ³ã‚¿ãƒã‚§ãƒƒã‚¯ | å®Œå…¨å®Ÿè£… | å€¤ãƒ¡ãƒ³ãƒãƒ¼è‡ªå·±å‚ç…§ã‚’ã‚¨ãƒ©ãƒ¼æ¤œå‡º |
| âš ï¸ å¾ªç’°å‚ç…§æ¤œå‡º | éƒ¨åˆ†å®Ÿè£… | ã‚³ãƒ¼ãƒ‰ã¯å®Œæˆã€å‰æ–¹å®£è¨€å¾…ã¡ |
| âœ… å‚ç…§ä»•æ§˜ç¢ºèª | æ­£ã—ãå®Ÿè£…æ¸ˆã¿ | C++ã¨åŒç­‰ã®å‹•ä½œ |

### ä¸»è¦ãªç™ºè¦‹

1. **å‚ç…§ã¯æ­£ã—ãå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹**
   - åˆæœŸåŒ–ã®ã¿å¯èƒ½
   - å†ä»£å…¥ã¯å€¤ã®å¤‰æ›´
   - å‚ç…§ã®å†æŸç¸›ã¯ä¸å¯

2. **è‡ªå·±å‚ç…§ãƒã‚§ãƒƒã‚¯ã¯å®Œå…¨å‹•ä½œ**
   - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¨ãƒ©ãƒ¼æ¤œå‡º
   - æ˜ç¢ºãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

3. **å¾ªç’°å‚ç…§æ¤œå‡ºã¯å°†æ¥ã®æ‹¡å¼µç”¨**
   - å‰æ–¹å®£è¨€å®Ÿè£…å¾…ã¡
   - ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯å®Œæˆæ¸ˆã¿

### ä»Šå¾Œã®èª²é¡Œ

#### å„ªå…ˆåº¦ğŸ”´: å‰æ–¹å®£è¨€ã®å®Ÿè£…

```cb
// å°†æ¥å®Ÿè£…äºˆå®š
struct Node;  // forward declaration

struct Tree {
    Node* root;  // âœ… å‰æ–¹å‚ç…§å¯èƒ½ã«
};

struct Node {
    int value;
    Node* left;
    Node* right;
};
```

å‰æ–¹å®£è¨€ãŒå®Ÿè£…ã•ã‚Œã‚Œã°ã€å¾ªç’°å‚ç…§æ¤œå‡ºãŒå®Ÿç”¨çš„ã«ãªã‚Šã¾ã™ã€‚

---

**å®Ÿè£…è€…**: GitHub Copilot  
**ãƒ¬ãƒ“ãƒ¥ãƒ¼çŠ¶æ…‹**: ãƒ†ã‚¹ãƒˆå®Œäº†ãƒ»å‹•ä½œç¢ºèªæ¸ˆã¿  
**å®Ÿè£…æ—¥**: 2025å¹´10æœˆ5æ—¥
