# ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å®Ÿè£…è¨ˆç”»

**ä½œæˆæ—¥**: 2025å¹´10æœˆ11æ—¥  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.10.0  
**å„ªå…ˆåº¦**: ğŸ”´ é«˜  
**æ‹…å½“**: Core Team

---

## ğŸ“‹ å®Ÿè£…æ¦‚è¦

æ§‹é€ ä½“ã«å¯¾ã™ã‚‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å®Ÿè£…ã—ã€RAIIãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚‹ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

**è¨­è¨ˆæ–¹é‡**:
```cb
struct Point { int x; int y; }

impl Point {
    self(int px, int py) { self.x = px; self.y = py; }
    ~self() { println("Destroyed"); }
}
```

**é‡è¦ãªåˆ¶ç´„**:
- `impl Struct {}` å†…ã®ãƒ¡ãƒ³ãƒãƒ¼å¤‰æ•°ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã™ã¹ã¦ **private**
- é€šå¸¸ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ `impl Interface for Struct` ã§å®šç¾©

---

## ğŸ¯ å®Ÿè£…ç›®æ¨™

### å¿…é ˆæ©Ÿèƒ½ï¼ˆv0.10.0ï¼‰

- [x] âœ… ä»•æ§˜æ›¸ã®ä½œæˆãƒ»ä¿®æ­£
  - [x] ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’&&ã‹ã‚‰ãƒã‚¤ãƒ³ã‚¿ã«å¤‰æ›´
  - [x] impl Struct {} ã®ã‚«ãƒ—ã‚»ãƒ«åŒ–è¦å‰‡ã‚’æ˜ç¢ºåŒ–
  - [x] nullptr ã®å‹•ä½œã‚’æ˜ç¢ºåŒ–
- [ ] ğŸ”„ åŸºæœ¬çš„ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  - [ ] ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  - [ ] ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä»˜ãã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  - [ ] ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰è§£æ±º
- [ ] ğŸ”„ ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  - [ ] ã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†æ™‚ã®è‡ªå‹•å‘¼ã³å‡ºã—
  - [ ] ç ´æ£„é †åºã®ä¿è¨¼ï¼ˆé€†é †ï¼‰
  - [ ] æ—©æœŸreturnã¸ã®å¯¾å¿œ
- [ ] ğŸ”„ `self` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
  - [ ] ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å†…ã§ã®ä½¿ç”¨
  - [ ] ãƒ¡ãƒ³ãƒãƒ¼ã‚¢ã‚¯ã‚»ã‚¹: `self.member`
- [ ] ğŸ”„ é…åˆ—ã®ã‚µãƒãƒ¼ãƒˆ
  - [ ] é…åˆ—è¦ç´ ã®åˆæœŸåŒ–
  - [ ] é…åˆ—è¦ç´ ã®ç ´æ£„
- [ ] ğŸ”„ ã‚«ãƒ—ã‚»ãƒ«åŒ–
  - [ ] impl Struct {} å†…ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’privateã«åˆ¶é™
  - [ ] private ãƒ¡ãƒ³ãƒãƒ¼å¤‰æ•°
  - [ ] private ãƒ¡ã‚½ãƒƒãƒ‰

### æ‹¡å¼µæ©Ÿèƒ½ï¼ˆv0.11.0ä»¥é™ï¼‰

- [ ] â³ ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆconstå‚ç…§å¼•æ•°: `self(const Struct& other)`ï¼‰
- [ ] â³ ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆå‚ç…§å¼•æ•°: `self(Struct& other)`ï¼‰
- [ ] â³ ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–ã®è‡ªå‹•åˆ¤å®š
- [ ] â³ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°

---

## ğŸ“ å®Ÿè£…ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 1. Lexeræ‹¡å¼µ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/frontend/recursive_parser/lexer.cpp`

```cpp
// æ–°ã—ã„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®è¿½åŠ 
enum class TokenType {
    // ... æ—¢å­˜ã®ãƒˆãƒ¼ã‚¯ãƒ³ ...
    SELF,      // "self" ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    TILDE,     // "~" ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    PRIVATE,   // "private" ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
};

Token Lexer::get_next_token() {
    // ... æ—¢å­˜ã®å‡¦ç† ...
    
    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰èªè­˜
    if (identifier == "self") {
        return Token(TokenType::SELF, "self");
    }
    
    // "~" ã®èªè­˜
    if (current_char == '~') {
        advance();
        return Token(TokenType::TILDE, "~");
    }
}
```

### 2. ASTæ‹¡å¼µ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/common/ast.h`

```cpp
// ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®è¿½åŠ 
enum class ASTNodeType {
    // ... æ—¢å­˜ã®ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ— ...
    AST_CONSTRUCTOR_DECL,     // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å®£è¨€
    AST_DESTRUCTOR_DECL,      // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å®£è¨€
    AST_SELF_KEYWORD,         // self ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
};

// ImplDefinitionã®æ‹¡å¼µ
struct ImplDefinition {
    std::string interface_name;  // ç©ºã®å ´åˆã€æ§‹é€ ä½“ç”¨impl
    std::string struct_name;
    
    // NEW: ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    std::vector<const ASTNode*> constructors;
    const ASTNode* destructor = nullptr;
    
    // æ—¢å­˜
    std::vector<const ASTNode*> methods;
    std::vector<const ASTNode*> impl_static_variables;
    
    // Helperé–¢æ•°
    const ASTNode* find_constructor(const std::vector<TypeInfo>& arg_types) const {
        for (const auto* ctor : constructors) {
            if (matches_signature(ctor, arg_types)) {
                return ctor;
            }
        }
        return nullptr;
    }
    
    bool has_default_constructor() const {
        for (const auto* ctor : constructors) {
            if (ctor->parameters.empty()) {
                return true;
            }
        }
        return false;
    }
};

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒãƒ¼ãƒ‰
struct ASTNode {
    // ... æ—¢å­˜ã®ãƒ¡ãƒ³ãƒãƒ¼ ...
    
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ç”¨ï¼ˆAST_CONSTRUCTOR_DECLã®å ´åˆï¼‰
    std::vector<std::unique_ptr<ASTNode>> constructor_params;
    std::unique_ptr<ASTNode> constructor_body;
    bool is_default_constructor;
    
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ç”¨ï¼ˆAST_DESTRUCTOR_DECLã®å ´åˆï¼‰
    std::unique_ptr<ASTNode> destructor_body;
};
```

### 3. Parseræ‹¡å¼µ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/frontend/recursive_parser/parsers/interface_parser.cpp`

```cpp
class InterfaceParser {
public:
    // implå®£è¨€ã®è§£æ
    ASTNode* parseImplDeclaration();
    
private:
    // æ§‹é€ ä½“ç”¨implã®è§£æ
    ASTNode* parseStructImpl();
    
    // interfaceç”¨implã®è§£æï¼ˆæ—¢å­˜ï¼‰
    ASTNode* parseInterfaceImpl();
    
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®è§£æ
    ASTNode* parseConstructor(const std::string& struct_name);
    
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®è§£æ
    ASTNode* parseDestructor(const std::string& struct_name);
    
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®åˆ¤å®š
    bool isConstructor();
    bool isDestructor();
};

ASTNode* InterfaceParser::parseImplDeclaration() {
    consume(TokenType::IMPL);
    
    std::string first_identifier = parseIdentifier();
    
    // ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¤å®š
    if (current_token->type == TokenType::LBRACE) {
        // impl Struct { ... }
        return parseStructImpl(first_identifier);
    } else if (current_token->type == TokenType::FOR) {
        // impl Interface for Struct { ... }
        consume(TokenType::FOR);
        std::string struct_name = parseIdentifier();
        return parseInterfaceImpl(first_identifier, struct_name);
    } else {
        error("Expected '{' or 'for' after impl declaration");
    }
}

ASTNode* InterfaceParser::parseStructImpl(const std::string& struct_name) {
    auto impl_node = std::make_unique<ASTNode>();
    impl_node->node_type = ASTNodeType::AST_IMPL_DECL;
    impl_node->name = struct_name;
    
    consume(TokenType::LBRACE);
    
    while (current_token->type != TokenType::RBRACE) {
        if (isConstructor()) {
            auto ctor = parseConstructor(struct_name);
            impl_node->impl_constructors.push_back(std::move(ctor));
        } else if (isDestructor()) {
            if (impl_node->impl_destructor) {
                error("Multiple destructors are not allowed");
            }
            impl_node->impl_destructor = parseDestructor(struct_name);
        } else if (current_token->type == TokenType::PRIVATE) {
            // å°†æ¥å®Ÿè£…
            auto priv = parsePrivateMember();
            impl_node->impl_private_members.push_back(std::move(priv));
        } else if (current_token->type == TokenType::STATIC) {
            auto static_var = parseStaticVariable();
            impl_node->impl_static_variables.push_back(std::move(static_var));
        } else {
            auto method = parseMethod();
            impl_node->impl_methods.push_back(std::move(method));
        }
    }
    
    consume(TokenType::RBRACE);
    return impl_node.release();
}

bool InterfaceParser::isConstructor() {
    // "self" "(" ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    return current_token->type == TokenType::SELF &&
           peek()->type == TokenType::LPAREN;
}

bool InterfaceParser::isDestructor() {
    // "~" "self" "(" ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    return current_token->type == TokenType::TILDE &&
           peek()->type == TokenType::SELF;
}

ASTNode* InterfaceParser::parseConstructor(const std::string& struct_name) {
    auto ctor_node = std::make_unique<ASTNode>();
    ctor_node->node_type = ASTNodeType::AST_CONSTRUCTOR_DECL;
    ctor_node->name = struct_name;
    
    consume(TokenType::SELF);
    consume(TokenType::LPAREN);
    
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è§£æ
    while (current_token->type != TokenType::RPAREN) {
        auto param = parseParameter();
        ctor_node->constructor_params.push_back(std::move(param));
        
        if (current_token->type == TokenType::COMMA) {
            consume(TokenType::COMMA);
        }
    }
    
    consume(TokenType::RPAREN);
    
    // æœ¬ä½“ã®è§£æ
    ctor_node->constructor_body = parseBlock();
    
    ctor_node->is_default_constructor = ctor_node->constructor_params.empty();
    
    return ctor_node.release();
}

ASTNode* InterfaceParser::parseDestructor(const std::string& struct_name) {
    auto dtor_node = std::make_unique<ASTNode>();
    dtor_node->node_type = ASTNodeType::AST_DESTRUCTOR_DECL;
    dtor_node->name = struct_name;
    
    consume(TokenType::TILDE);
    consume(TokenType::SELF);
    consume(TokenType::LPAREN);
    consume(TokenType::RPAREN);
    
    // æœ¬ä½“ã®è§£æ
    dtor_node->destructor_body = parseBlock();
    
    return dtor_node.release();
}
```

### 4. Interpreteræ‹¡å¼µ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/backend/interpreter/core/interpreter.h`

```cpp
class Interpreter {
private:
    // ã‚¹ã‚³ãƒ¼ãƒ—æƒ…å ±ã®æ‹¡å¼µ
    struct ScopeInfo {
        std::map<std::string, Variable> variables;
        std::vector<std::string> destruction_order;  // NEW: ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—é †åº
        bool is_function_scope;
        bool is_loop_scope;
    };
    
    std::vector<ScopeInfo> scope_stack_;
    
    // self ãƒã‚¤ãƒ³ã‚¿
    Variable* current_self_ = nullptr;
    
    // ImplDefinition ã®ç®¡ç†
    std::map<std::string, ImplDefinition> struct_impl_map_;  // structå -> implå®šç¾©
    
public:
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿é–¢é€£
    void call_constructor(Variable& instance,
                         const ASTNode* ctor_node,
                         const std::vector<Variable>& args);
    
    void call_destructor(Variable& instance);
    
    const ASTNode* find_constructor(const std::string& struct_name,
                                   const std::vector<TypeInfo>& arg_types);
    
    const ASTNode* find_destructor(const std::string& struct_name);
    
    // ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†ã®æ‹¡å¼µ
    void enter_scope(bool is_function = false);
    void exit_scope();  // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è‡ªå‹•å‘¼ã³å‡ºã—
    
    // å¤‰æ•°å®£è¨€ã®æ‹¡å¼µ
    void declare_struct_variable(const ASTNode* decl_node);
    
    // self ã‚¢ã‚¯ã‚»ã‚¹
    Variable* get_self() { return current_self_; }
    void set_self(Variable* self) { current_self_ = self; }
};
```

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/backend/interpreter/core/interpreter.cpp`

```cpp
void Interpreter::register_impl_definition(const ImplDefinition& impl_def) {
    if (impl_def.interface_name.empty()) {
        // æ§‹é€ ä½“ç”¨impl
        struct_impl_map_[impl_def.struct_name] = impl_def;
        debug_msg(DebugMsgId::PARSE_IMPL_DEF,
                 ("Registered struct impl: " + impl_def.struct_name).c_str());
    } else {
        // interfaceç”¨implï¼ˆæ—¢å­˜ã®å‡¦ç†ï¼‰
        interface_operations_->register_impl_definition(impl_def);
    }
}

void Interpreter::declare_struct_variable(const ASTNode* decl_node) {
    const std::string& var_name = decl_node->name;
    const std::string& struct_name = decl_node->type_name;
    
    // æ§‹é€ ä½“å‹ã®å¤‰æ•°ã‚’ä½œæˆ
    Variable var;
    var.type = TypeInfo::STRUCT;
    var.struct_name = struct_name;
    
    // æ§‹é€ ä½“ã®å®šç¾©ã‚’å–å¾—ã—ã¦ãƒ¡ãƒ³ãƒãƒ¼åˆæœŸåŒ–
    auto struct_def = find_struct_definition(struct_name);
    if (struct_def) {
        initialize_struct_members(var, struct_def);
    }
    
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®æ¤œç´¢
    std::vector<TypeInfo> arg_types;
    for (const auto& arg : decl_node->arguments) {
        arg_types.push_back(evaluate_expression(arg.get()).type);
    }
    
    const ASTNode* ctor = find_constructor(struct_name, arg_types);
    
    if (ctor) {
        // å¼•æ•°ã‚’è©•ä¾¡
        std::vector<Variable> args;
        for (const auto& arg : decl_node->arguments) {
            args.push_back(evaluate_expression(arg.get()));
        }
        
        // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
        call_constructor(var, ctor, args);
    } else if (!decl_node->arguments.empty()) {
        // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŒã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¼•æ•°ãŒã‚ã‚‹
        error("No matching constructor for struct '" + struct_name + 
              "' with given arguments");
    }
    
    // ã‚¹ã‚³ãƒ¼ãƒ—ã«å¤‰æ•°è¿½åŠ 
    add_variable_to_current_scope(var_name, var);
    
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç ´æ£„é †åºã«è¿½åŠ 
    if (find_destructor(struct_name)) {
        current_scope().destruction_order.push_back(var_name);
    }
}

void Interpreter::call_constructor(Variable& instance,
                                   const ASTNode* ctor_node,
                                   const std::vector<Variable>& args) {
    debug_msg(DebugMsgId::FUNC_CALL,
             ("Calling constructor: " + ctor_node->name).c_str());
    
    // self ã‚’ instance ã«è¨­å®š
    Variable* old_self = current_self_;
    current_self_ = &instance;
    
    // æ–°ã—ã„ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹
    enter_scope();
    
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¼•æ•°ã§åˆæœŸåŒ–
    for (size_t i = 0; i < args.size(); i++) {
        const auto& param = ctor_node->constructor_params[i];
        add_variable_to_current_scope(param->name, args[i]);
    }
    
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿æœ¬ä½“ã‚’å®Ÿè¡Œ
    execute_statement(ctor_node->constructor_body.get());
    
    // ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
    exit_scope();
    
    // self ã‚’å¾©å…ƒ
    current_self_ = old_self;
}

void Interpreter::call_destructor(Variable& instance) {
    const ASTNode* dtor = find_destructor(instance.struct_name);
    if (!dtor) {
        return;  // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„
    }
    
    debug_msg(DebugMsgId::FUNC_CALL,
             ("Calling destructor: ~" + instance.struct_name).c_str());
    
    // self ã‚’ instance ã«è¨­å®š
    Variable* old_self = current_self_;
    current_self_ = &instance;
    
    // æ–°ã—ã„ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹
    enter_scope();
    
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿æœ¬ä½“ã‚’å®Ÿè¡Œ
    execute_statement(dtor->destructor_body.get());
    
    // ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
    exit_scope();
    
    // self ã‚’å¾©å…ƒ
    current_self_ = old_self;
}

const ASTNode* Interpreter::find_constructor(
    const std::string& struct_name,
    const std::vector<TypeInfo>& arg_types) {
    
    auto it = struct_impl_map_.find(struct_name);
    if (it == struct_impl_map_.end()) {
        return nullptr;  // implå®šç¾©ãªã—
    }
    
    const ImplDefinition& impl_def = it->second;
    return impl_def.find_constructor(arg_types);
}

const ASTNode* Interpreter::find_destructor(const std::string& struct_name) {
    auto it = struct_impl_map_.find(struct_name);
    if (it == struct_impl_map_.end()) {
        return nullptr;
    }
    
    return it->second.destructor;
}

void Interpreter::enter_scope(bool is_function) {
    ScopeInfo scope;
    scope.is_function_scope = is_function;
    scope.is_loop_scope = false;
    scope_stack_.push_back(scope);
    
    debug_msg(DebugMsgId::SCOPE_ENTER,
             ("Scope depth: " + std::to_string(scope_stack_.size())).c_str());
}

void Interpreter::exit_scope() {
    if (scope_stack_.empty()) {
        error("Cannot exit scope: no scope to exit");
        return;
    }
    
    ScopeInfo& scope = scope_stack_.back();
    
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’é€†é †ã§å‘¼ã³å‡ºã—
    for (auto it = scope.destruction_order.rbegin();
         it != scope.destruction_order.rend(); ++it) {
        
        auto var_it = scope.variables.find(*it);
        if (var_it != scope.variables.end()) {
            Variable& var = var_it->second;
            
            if (var.type == TypeInfo::STRUCT) {
                call_destructor(var);
            }
        }
    }
    
    // ã‚¹ã‚³ãƒ¼ãƒ—ã‚’pop
    scope_stack_.pop_back();
    
    debug_msg(DebugMsgId::SCOPE_EXIT,
             ("Scope depth: " + std::to_string(scope_stack_.size())).c_str());
}

Variable Interpreter::evaluate_expression(const ASTNode* node) {
    // ... æ—¢å­˜ã®å‡¦ç† ...
    
    switch (node->node_type) {
        // ... æ—¢å­˜ã®ã‚±ãƒ¼ã‚¹ ...
        
        case ASTNodeType::AST_SELF_KEYWORD:
            if (!current_self_) {
                error("'self' can only be used inside impl methods/constructors/destructors");
            }
            return *current_self_;
        
        // ... ãã®ä»–ã®ã‚±ãƒ¼ã‚¹ ...
    }
}
```

### 5. é…åˆ—ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/backend/interpreter/managers/variables/array_operations.cpp`

```cpp
void ArrayOperations::initialize_struct_array(Variable& array_var) {
    if (array_var.type != TypeInfo::ARRAY) {
        return;
    }
    
    // é…åˆ—è¦ç´ ã®å‹ãŒæ§‹é€ ä½“ã®å ´åˆ
    if (array_var.element_type == TypeInfo::STRUCT) {
        const std::string& struct_name = array_var.struct_name;
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®æ¤œç´¢
        const ASTNode* default_ctor = 
            interpreter_->find_constructor(struct_name, {});
        
        if (default_ctor) {
            // å„è¦ç´ ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã—
            for (auto& element : array_var.array_elements) {
                interpreter_->call_constructor(element, default_ctor, {});
            }
        }
    }
}

void ArrayOperations::destroy_struct_array(Variable& array_var) {
    if (array_var.type != TypeInfo::ARRAY ||
        array_var.element_type != TypeInfo::STRUCT) {
        return;
    }
    
    // é…åˆ—è¦ç´ ã‚’é€†é †ã§ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
    for (auto it = array_var.array_elements.rbegin();
         it != array_var.array_elements.rend(); ++it) {
        interpreter_->call_destructor(*it);
    }
}
```

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆè¨ˆç”»

### Phase 1: åŸºæœ¬çš„ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/test_basic_constructor.cb`

```cb
struct Counter {
    int value;
}

impl Counter {
    self() {
        self.value = 0;
        println("Default constructor");
    }
    
    self(int v) {
        self.value = v;
        println("Parameterized constructor: ", v);
    }
    
    ~self() {
        println("Destructor: ", self.value);
    }
}

void main() {
    Counter c1;
    println("c1.value = ", c1.value);
    
    Counter c2(42);
    println("c2.value = ", c2.value);
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// Default constructor
// c1.value = 0
// Parameterized constructor: 42
// c2.value = 42
// Destructor: 42
// Destructor: 0
```

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/test_destructor_order.cb`

```cb
struct Logger {
    string name;
}

impl Logger {
    self(string n) {
        self.name = n;
        println("Created: ", n);
    }
    
    ~self() {
        println("Destroyed: ", self.name);
    }
}

void main() {
    Logger a("First");
    Logger b("Second");
    Logger c("Third");
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// Created: First
// Created: Second
// Created: Third
// Destroyed: Third
// Destroyed: Second
// Destroyed: First
```

### Phase 2: ã‚¹ã‚³ãƒ¼ãƒ—ã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/test_scope_destructor.cb`

```cb
struct Resource {
    int id;
}

impl Resource {
    self(int i) {
        self.id = i;
        println("Resource acquired: ", i);
    }
    
    ~self() {
        println("Resource released: ", self.id);
    }
}

void main() {
    Resource r1(1);
    {
        Resource r2(2);
        {
            Resource r3(3);
        }
        Resource r4(4);
    }
    Resource r5(5);
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// Resource acquired: 1
// Resource acquired: 2
// Resource acquired: 3
// Resource released: 3
// Resource acquired: 4
// Resource released: 4
// Resource released: 2
// Resource acquired: 5
// Resource released: 5
// Resource released: 1
```

### Phase 3: é…åˆ—ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/test_array_constructor.cb`

```cb
struct Item {
    int id;
}

impl Item {
    self() {
        self.id = 0;
        println("Item constructed");
    }
    
    ~self() {
        println("Item destructed");
    }
}

void main() {
    Item[3] items;
    println("Array initialized");
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// Item constructed
// Item constructed
// Item constructed
// Array initialized
// Item destructed
// Item destructed
// Item destructed
```

### Phase 4: æ—©æœŸreturnã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/test_early_return.cb`

```cb
struct Guard {
    string name;
}

impl Guard {
    self(string n) {
        self.name = n;
        println("Guard entered: ", n);
    }
    
    ~self() {
        println("Guard exited: ", self.name);
    }
}

void test(bool early_exit) {
    Guard g1("outer");
    
    if (early_exit) {
        Guard g2("inner");
        println("Early return");
        return;
    }
    
    println("Normal path");
}

void main() {
    println("=== Test 1: Early return ===");
    test(true);
    
    println("\n=== Test 2: Normal path ===");
    test(false);
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// === Test 1: Early return ===
// Guard entered: outer
// Guard entered: inner
// Early return
// Guard exited: inner
// Guard exited: outer
//
// === Test 2: Normal path ===
// Guard entered: outer
// Normal path
// Guard exited: outer
```

### Phase 5: çµ±åˆãƒ†ã‚¹ãƒˆ

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cases/constructor/test_comprehensive.cb`

```cb
struct BankAccount {
    string owner;
}

impl BankAccount {
    private int balance;
    
    self(string name, int initial) {
        self.owner = name;
        balance = initial;
        println("Account created for ", name, " with balance ", initial);
    }
    
    ~self() {
        println("Account closed for ", self.owner, " with final balance ", balance);
    }
    
    void deposit(int amount) {
        balance = balance + amount;
        println(self.owner, " deposited ", amount, ", new balance: ", balance);
    }
    
    void withdraw(int amount) {
        if (balance >= amount) {
            balance = balance - amount;
            println(self.owner, " withdrew ", amount, ", new balance: ", balance);
        } else {
            println(self.owner, " insufficient funds");
        }
    }
    
    int getBalance() {
        return balance;
    }
}

void main() {
    BankAccount alice("Alice", 1000);
    alice.deposit(500);
    alice.withdraw(300);
    
    {
        BankAccount bob("Bob", 2000);
        bob.deposit(1000);
    }
    
    println("Alice final balance: ", alice.getBalance());
}

// æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
// Account created for Alice with balance 1000
// Alice deposited 500, new balance: 1500
// Alice withdrew 300, new balance: 1200
// Account created for Bob with balance 2000
// Bob deposited 1000, new balance: 3000
// Account closed for Bob with final balance 3000
// Alice final balance: 1200
// Account closed for Alice with final balance 1200
```

---

## ğŸ“Š å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

### Week 1-2: åŸºæœ¬æ§‹é€ ã®å®Ÿè£…

- [ ] Day 1-2: Lexeræ‹¡å¼µï¼ˆ`self`, `~` ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰
- [ ] Day 3-4: ASTæ‹¡å¼µï¼ˆConstructorNode, DestructorNodeï¼‰
- [ ] Day 5-7: Parseræ‹¡å¼µï¼ˆ`impl Struct {}` è§£æï¼‰
- [ ] Day 8-10: åŸºæœ¬çš„ãªæ§‹æ–‡ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã¨ãƒ†ã‚¹ãƒˆ

**ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³**: æ§‹æ–‡è§£æãŒæ­£ã—ãå‹•ä½œã—ã€ASTãŒæ§‹ç¯‰ã•ã‚Œã‚‹

### Week 3-4: ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å®Ÿè£…

- [ ] Day 11-13: Interpreteræ‹¡å¼µï¼ˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—æ©Ÿæ§‹ï¼‰
- [ ] Day 14-16: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®è‡ªå‹•å‘¼ã³å‡ºã—
- [ ] Day 17-19: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä»˜ãã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
- [ ] Day 20-22: ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰è§£æ±º
- [ ] Day 23-24: `self` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å®Ÿè£…
- [ ] Day 25-28: é…åˆ—è¦ç´ ã®åˆæœŸåŒ–

**ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³**: ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒæ­£ã—ãå‘¼ã³å‡ºã•ã‚Œã‚‹

### Week 5-6: ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å®Ÿè£…

- [ ] Day 29-31: ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†æ©Ÿæ§‹ã®æ‹¡å¼µ
- [ ] Day 32-34: ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®è‡ªå‹•å‘¼ã³å‡ºã—
- [ ] Day 35-37: ç ´æ£„é †åºã®å®Ÿè£…ï¼ˆé€†é †ï¼‰
- [ ] Day 38-40: æ—©æœŸreturnæ™‚ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
- [ ] Day 41-42: é…åˆ—è¦ç´ ã®ç ´æ£„

**ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³**: ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒæ­£ã—ã„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å‘¼ã³å‡ºã•ã‚Œã‚‹

### Week 7: ãƒ†ã‚¹ãƒˆã¨æœ€é©åŒ–

- [ ] Day 43-45: åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
- [ ] Day 46-47: ãƒã‚°ä¿®æ­£
- [ ] Day 48-49: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–

**ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³**: v0.10.0ãƒªãƒªãƒ¼ã‚¹æº–å‚™å®Œäº†

---

## âš ï¸ å®Ÿè£…ä¸Šã®æ³¨æ„äº‹é …

### 1. æ—¢å­˜æ©Ÿèƒ½ã¨ã®çµ±åˆ

#### deferæ–‡ã¨ã®é–¢ä¿‚

```cb
struct Resource { int id; }
impl Resource {
    self(int i) { self.id = i; }
    ~self() { println("Destructor: ", self.id); }
}

void main() {
    Resource r(1);
    defer { println("Defer 1"); }
    Resource r2(2);
    defer { println("Defer 2"); }
}

// å®Ÿè¡Œé †åºã®ä¿è¨¼:
// 1. "Defer 2" (æœ€å¾Œã®defer)
// 2. Destructor: 2 (r2 ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿)
// 3. "Defer 1" (æœ€åˆã®defer)
// 4. Destructor: 1 (r ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿)
```

**å®Ÿè£…**: deferæ–‡ã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å®Ÿè¡Œé †åºã‚’é©åˆ‡ã«ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

#### default ãƒ¡ãƒ³ãƒãƒ¼ã¨ã®ä½µç”¨

```cb
struct Wrapper {
    default int value;
}

impl Wrapper {
    self() {
        self.value = 0;  // default ãƒ¡ãƒ³ãƒãƒ¼ã‚‚åˆæœŸåŒ–å¯èƒ½
    }
    
    self(int v) {
        self.value = v;
    }
}
```

**å®Ÿè£…**: default ãƒ¡ãƒ³ãƒãƒ¼ã‚’æŒã¤æ§‹é€ ä½“ã§ã‚‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚

#### interfaceå®Ÿè£…ã¨ã®åˆ†é›¢

```cb
interface Printable {
    string toString();
}

struct Point { int x; int y; }

// âœ… OK: åˆ¥ã€…ã®implãƒ–ãƒ­ãƒƒã‚¯
impl Point {
    self(int px, int py) { self.x = px; self.y = py; }
}

impl Printable for Point {
    string toString() { return "Point"; }
}

// âŒ NG: åŒã˜implãƒ–ãƒ­ãƒƒã‚¯ã«ã¯è¨˜è¿°ä¸å¯
// impl Printable for Point {
//     self(int px, int py) { }  // ã‚¨ãƒ©ãƒ¼
// }
```

**å®Ÿè£…**: `impl Struct {}` ã¨ `impl Interface for Struct {}` ã‚’æ˜ç¢ºã«åŒºåˆ¥ã™ã‚‹ã€‚

### 2. ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

```
// é‡è¤‡ã—ãŸã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
Error: Multiple constructors with the same signature in impl for 'Point'
  --> test.cb:5
   |
 5 |     self(int x, int y) { ... }
   |     ^^^^^^^^^^^^^^^^^^^^^^^ duplicate constructor
   |
Note: First defined here:
  --> test.cb:3
   |
 3 |     self(int x, int y) { ... }
   |     ^^^^^^^^^^^^^^^^^^^^^^^

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„
Error: No matching constructor for struct 'Point' with arguments (int, string)
  --> test.cb:15
   |
15 |     Point p(10, "hello");
   |             ^^^^^^^^^^^^ no matching constructor
   |
Note: Available constructors:
   - Point()
   - Point(int, int)

// è¤‡æ•°ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
Error: Multiple destructors are not allowed
  --> test.cb:10
   |
10 |     ~self() { ... }
   |     ^^^^^^^^^^^^^^^ second destructor
   |
Note: First defined here:
  --> test.cb:8
   |
 8 |     ~self() { ... }
   |     ^^^^^^^^^^^^^^^
```

### 3. ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

```cpp
// ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¿½åŠ 
enum class DebugMsgId {
    // ... æ—¢å­˜ã®ID ...
    CONSTRUCTOR_CALL,      // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
    DESTRUCTOR_CALL,       // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
    SCOPE_DESTRUCTOR,      // ã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†æ™‚ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
};

// ä½¿ç”¨ä¾‹
debug_msg(DebugMsgId::CONSTRUCTOR_CALL,
         ("Calling constructor: " + struct_name + 
          "(" + arg_types + ")").c_str());

debug_msg(DebugMsgId::DESTRUCTOR_CALL,
         ("Calling destructor: ~" + struct_name).c_str());
```

### 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

- **é…åˆ—ã®åˆæœŸåŒ–**: å¤§ããªé…åˆ—ã§ã®åˆæœŸåŒ–ã‚³ã‚¹ãƒˆã‚’æœ€å°åŒ–
- **ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–**: å°ã•ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æœ€é©åŒ–
- **RVOï¼ˆReturn Value Optimizationï¼‰**: ä¸è¦ãªã‚³ãƒ”ãƒ¼ã‚’å‰Šæ¸›ï¼ˆå°†æ¥å®Ÿè£…ï¼‰

---

## ğŸ”„ å°†æ¥ã®æ‹¡å¼µï¼ˆv0.11.0ä»¥é™ï¼‰

### ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

```cb
struct Point { int x; int y; }

impl Point {
    self(int px, int py) {
        self.x = px;
        self.y = py;
    }
    
    // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    self(const Point other) {
        self.x = other.x;
        self.y = other.y;
        println("Copied");
    }
}
```

### ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

```cb
struct Buffer { int* data; int size; }

impl Buffer {
    // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    self(Buffer&& other) {
        self.data = other.data;
        self.size = other.size;
        other.data = nullptr;
        other.size = 0;
    }
}
```

### private ãƒ¡ãƒ³ãƒãƒ¼

```cb
struct BankAccount { string owner; }

impl BankAccount {
    private int balance;  // privateå¤‰æ•°
    
    self(string name, int initial) {
        self.owner = name;
        balance = initial;
    }
}
```

---

## ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ä»•æ§˜æ›¸](../features/constructor_destructor.md)
- [Cbè¨€èªä»•æ§˜æ›¸](../spec.md)
- [v0.10.0å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—](./v0.10.0_implementation_plan.md)

---

**ä½œæˆæ—¥**: 2025å¹´10æœˆ11æ—¥  
**æœ€çµ‚æ›´æ–°**: 2025å¹´10æœˆ11æ—¥  
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: ğŸ“ å®Ÿè£…æº–å‚™ä¸­
