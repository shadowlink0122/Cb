# 無名関数（ラムダ式）実装計画

**作成日**: 2025年10月9日  
**対象バージョン**: v0.10.0  
**優先度**: 🔴 高

---

## 📋 概要

関数を式として扱える無名関数（ラムダ式）を実装する。関数ポインタや高階関数での使用を想定。

---

## 🎯 目的

1. **関数の即時定義**: 関数ポインタへの代入時に即座に定義
2. **高階関数のサポート**: コールバック関数の簡潔な記述
3. **クロージャの基盤**: 将来的なクロージャ実装への布石

---

## 📝 基本仕様

### 構文

#### パターン1: 関数ポインタへの代入（型明示）

```cb
void main() {
    // 型* 変数 = 型 func(引数) { 処理; }
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    println(add(5, 3));  // 8
}
```

#### パターン2: 直接代入（型推論）

```cb
void main() {
    // 型 func(引数) { 処理; }
    int func(int x) {
        return x * 2;
    };
    
    // 内部的には一意な識別子が生成される
    // 例: __lambda_1, __lambda_2, ...
}
```

#### パターン3: 関数引数として

```cb
func void apply(int* callback, int x) {
    println(callback(x));
}

void main() {
    // コールバック関数を即座に定義
    apply(int func(int n) { return n * n; }, 5);  // 25
}
```

#### パターン4: 配列要素として

```cb
void main() {
    // 関数ポインタの配列
    int*[3] operations = [
        int func(int x) { return x + 1; },
        int func(int x) { return x * 2; },
        int func(int x) { return x * x; }
    ];
    
    for (int i = 0; i < 3; i++) {
        println(operations[i](10));
    }
    // 出力: 11, 20, 100
}
```

### 重要な特性

#### 1. funcキーワード自体はスコープを持たない

```cb
void main() {
    // 同じスコープ内に複数のfunc()が存在可能
    int* f1 = int func(int x) { return x + 1; };
    int* f2 = int func(int x) { return x * 2; };
    
    // 重複エラーは発生しない
    // 内部的には __lambda_1, __lambda_2 のように識別
}
```

#### 2. 内部識別子の自動生成

コンパイラ/インタプリタが自動的に一意な識別子を生成:

```cb
// ユーザーコード
int* f = int func(int x) { return x * 2; };

// 内部的には
int __lambda_1(int x) { return x * 2; }
int* f = &__lambda_1;
```

#### 3. 式としての扱い

無名関数は式として評価されるため、様々な場所で使用可能:

```cb
// 代入式
int* f = int func(int x) { return x; };

// 関数引数
process(int func(int x) { return x * 2; });

// return文
func int* get_doubler() {
    return int func(int x) { return x * 2; };
}

// 配列初期化
int*[2] funcs = [
    int func(int x) { return x; },
    int func(int x) { return -x; }
];
```

---

## 🔧 実装要件

### 1. 構文拡張

**Lexer**:
- `func` キーワードは既存（関数定義で使用中）
- 新しいトークンは不要

**Parser**:
- 式の中で `func` を検出した場合、無名関数として解析
- 戻り値の型、パラメータリスト、本体を解析
- セミコロンで終端

### 2. AST拡張

```cpp
// 無名関数ノード
struct LambdaExpressionNode : public ExpressionNode {
    TypeInfo return_type;
    std::vector<Parameter> parameters;
    std::unique_ptr<StatementNode> body;
    std::string generated_name;  // 自動生成された内部識別子
};

// 通常の式として扱えるようにExpressionNodeを継承
```

### 3. 識別子の自動生成

**命名規則**:
```cpp
class LambdaNameGenerator {
    static int lambda_counter;
    
public:
    static std::string generate() {
        return "__lambda_" + std::to_string(++lambda_counter);
    }
};
```

**スコープ管理**:
- 各無名関数に一意な内部識別子を割り当て
- 関数テーブルに通常の関数と同様に登録
- スコープ終了時に削除（または関数ポインタで参照されている間は保持）

### 4. 型推論

#### 関数ポインタへの代入

```cb
// 型明示
int* f = int func(int x) { return x * 2; };
```

型チェック:
1. 左辺の型: `int*`（int型を返す関数へのポインタ）
2. 右辺の型: `int func(int) { ... }`
3. シグネチャが一致するか検証

#### 直接呼び出し

```cb
// 即座に呼び出し（IIFE: Immediately Invoked Function Expression）
int result = (int func(int x) { return x * 2; })(5);
println(result);  // 10
```

### 5. インタプリタでの実装

**無名関数の登録**:
```cpp
void Interpreter::evaluate_lambda(LambdaExpressionNode* lambda) {
    // 1. 一意な名前を生成
    std::string internal_name = LambdaNameGenerator::generate();
    lambda->generated_name = internal_name;
    
    // 2. 通常の関数として登録
    FunctionDef func_def;
    func_def.name = internal_name;
    func_def.return_type = lambda->return_type;
    func_def.parameters = lambda->parameters;
    func_def.body = std::move(lambda->body);
    
    register_function(func_def);
    
    // 3. 関数ポインタとして返す
    return create_function_pointer(internal_name);
}
```

**関数ポインタへの変換**:
```cpp
int64_t Interpreter::lambda_to_function_pointer(LambdaExpressionNode* lambda) {
    std::string internal_name = evaluate_lambda(lambda);
    return get_function_address(internal_name);
}
```

---

## 📊 実装ステップ

### Phase 1: 基本構造（2週間）
- [ ] LambdaExpressionNode の定義
- [ ] 識別子自動生成機構
- [ ] 基本的な構文解析

### Phase 2: 式としての統合（2週間）
- [ ] 代入式での使用
- [ ] 関数引数での使用
- [ ] 配列初期化での使用

### Phase 3: 型チェック（1週間）
- [ ] シグネチャの一致検証
- [ ] 型推論の実装
- [ ] エラーメッセージの改善

### Phase 4: テストと検証（1週間）
- [ ] 基本的な無名関数テスト
- [ ] 高階関数テスト
- [ ] エッジケーステスト

---

## 🧪 テストケース

### 1. 基本的な無名関数
```cb
void main() {
    int* add = int func(int a, int b) {
        return a + b;
    };
    
    assert(add(3, 4) == 7);
    assert(add(10, 20) == 30);
}
```

### 2. 複数の無名関数（同じスコープ）
```cb
void main() {
    int* f1 = int func(int x) { return x + 1; };
    int* f2 = int func(int x) { return x * 2; };
    int* f3 = int func(int x) { return x * x; };
    
    assert(f1(5) == 6);
    assert(f2(5) == 10);
    assert(f3(5) == 25);
}
```

### 3. 高階関数
```cb
func void apply_twice(int* f, int x) {
    int result = f(f(x));
    println(result);
}

void main() {
    apply_twice(int func(int n) { return n + 1; }, 5);  // 7
    apply_twice(int func(int n) { return n * 2; }, 5);  // 20
}
```

### 4. 関数を返す関数
```cb
func int* make_multiplier(int factor) {
    return int func(int x) {
        return x * factor;  // 外部変数を参照（クロージャ的）
    };
}

void main() {
    int* double = make_multiplier(2);
    int* triple = make_multiplier(3);
    
    assert(double(5) == 10);
    assert(triple(5) == 15);
}
```

### 5. 配列での使用
```cb
void main() {
    int*[3] operations = [
        int func(int x) { return x + 10; },
        int func(int x) { return x - 10; },
        int func(int x) { return x * 10; }
    ];
    
    for (int i = 0; i < 3; i++) {
        println(operations[i](5));
    }
    // 出力: 15, -5, 50
}
```

### 6. IIFE（即座に呼び出される関数式）
```cb
void main() {
    // 無名関数を定義して即座に実行
    int result = (int func(int x) { return x * x; })(7);
    println(result);  // 49
}
```

### 7. 条件分岐での使用
```cb
void main() {
    bool is_positive = true;
    
    int* operation = is_positive 
        ? int func(int x) { return x; }
        : int func(int x) { return -x; };
    
    println(operation(10));  // 10 or -10
}
```

---

## 🔗 関連機能

### クロージャ（将来の拡張）

現在の無名関数は外部変数をキャプチャしませんが、将来的には:

```cb
func int* make_counter() {
    int count = 0;  // 外部変数
    
    return int func() {
        count = count + 1;  // 外部変数をキャプチャ
        return count;
    };
}

void main() {
    int* counter = make_counter();
    println(counter());  // 1
    println(counter());  // 2
    println(counter());  // 3
}
```

**実装課題**:
- キャプチャされた変数のライフタイム管理
- 値キャプチャ vs 参照キャプチャ
- メモリ管理

---

## ⚠️ 注意事項

1. **スコープ管理**: 無名関数のライフタイムは関数ポインタの生存期間に依存
2. **パフォーマンス**: 関数生成のオーバーヘッド
3. **デバッグ**: 内部識別子が生成されるため、エラーメッセージの改善が必要
4. **再帰**: 無名関数内から自身を呼び出す方法（現状では不可能）

---

## 🔄 将来の拡張

1. **型推論の強化**: 戻り値の型を省略可能に
   ```cb
   int* f = func(int x) { return x * 2; };  // int を推論
   ```

2. **短縮構文**: アロー関数スタイル
   ```cb
   int* f = (int x) => x * 2;
   ```

3. **クロージャ**: 外部変数のキャプチャ
   ```cb
   int factor = 10;
   int* f = int func(int x) { return x * factor; };
   ```

4. **ジェネリック**: 型パラメータを持つ無名関数
   ```cb
   T* identity<T> = T func(T x) { return x; };
   ```

---

## 📐 TypeScriptとの比較

**TypeScript**:
```typescript
// 無名関数
const add = function(a: number, b: number): number {
    return a + b;
};

// アロー関数
const double = (x: number): number => x * 2;

// 即座に呼び出し
const result = (function(x: number) { return x * x; })(5);
```

**Cb（提案）**:
```cb
// 無名関数
int* add = int func(int a, int b) {
    return a + b;
};

// 即座に呼び出し
int result = (int func(int x) { return x * x; })(5);
```

**類似点**:
- 関数を式として扱える
- 高階関数のサポート
- 即座に呼び出し可能

**相違点**:
- Cbは型を明示的に指定（現時点）
- Cbはアロー関数構文なし（将来追加可能）
- TypeScriptはクロージャを完全サポート

---

**更新履歴**:
- 2025/10/09: 初版作成
