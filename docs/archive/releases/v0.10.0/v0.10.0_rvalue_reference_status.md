# T&& (Rvalue Reference) Implementation Status - v0.10.0

## 実装日
2025年10月11日

## 概要
T&&（右辺値参照）変数の構文解析とパース機能を実装しました。
ただし、完全な参照セマンティクス（エイリアス動作）は未実装です。

## 実装済み機能 ✅

### 1. 構文解析
- **ファイル**: `src/frontend/recursive_parser/parsers/type_utility_parser.cpp`
- **機能**: `&&` トークンの認識（`TOK_AND` および 2つの `TOK_BIT_AND`）
- **行**: 186-199
- **状態**: ✅ 完全動作

```cpp
// 例: Point&& ref = p1;
if (parser_->check(TokenType::TOK_AND)) {
    parser_->advance();
    parsed.is_rvalue_reference = true;
} else if (parser_->check(TokenType::TOK_BIT_AND)) {
    parser_->advance();
    if (parser_->check(TokenType::TOK_BIT_AND)) {
        parsed.is_rvalue_reference = true;
        parser_->advance();
    }
}
```

### 2. データ構造拡張
以下の構造体に `is_rvalue_reference` フラグと `reference_target` フィールドを追加：

- **Variable** (`src/backend/interpreter/core/interpreter.h` line 59-61)
  ```cpp
  bool is_rvalue_reference = false;   // (T&&) v0.10.0
  std::string reference_target;        // 参照している変数名
  ```

- **ASTNode** (`src/common/ast.h` line 829)
- **ParsedTypeInfo** (`src/frontend/recursive_parser/recursive_parser.h` line ~30)
- **ReturnException** (対応済み)

### 3. 型制限
- **ファイル**: `src/backend/interpreter/managers/variables/declaration.cpp`
- **行**: 67-72
- **機能**: T&&は構造体型のみ許可、T&は全型で許可
- **状態**: ✅ 完全動作

```cpp
if (var.is_rvalue_reference && node->type_info != TYPE_STRUCT) {
    throw std::runtime_error(
        "Rvalue references (T&&) are only supported for struct types. "
        "Use regular lvalue references (T&) for primitive types.");
}
```

### 4. 参照チェーン追跡
- **ファイル**: `src/backend/interpreter/managers/variables/manager.cpp`
- **行**: 95-100, 112-117
- **機能**: `find_variable()` が再帰的に参照を辿る
- **状態**: ✅ 動作中（ただし、メンバーアクセスで活用されていない）

```cpp
Variable *result = &var_it->second;
if ((result->is_reference || result->is_rvalue_reference) &&
    !result->reference_target.empty()) {
    return find_variable(result->reference_target);
}
```

### 5. フラグ伝播
- **ファイル**: `src/frontend/recursive_parser/parsers/variable_declaration_parser.cpp`
- **行**: 213, 270
- **機能**: パーサーからASTノードへのフラグ伝播
- **状態**: ✅ 完全動作

### 6. 参照変数の作成
- **ファイル**: `src/backend/interpreter/managers/variables/declaration.cpp`
- **行**: 1804-1827
- **機能**: 参照変数の初期化と reference_target の設定
- **状態**: ⚠️ 部分的（コピーが作成される）

```cpp
if ((var.is_reference || var.is_rvalue_reference) && source_var) {
    Variable ref_var = *source_var;  // 完全なコピー
    ref_var.is_reference = true;
    ref_var.is_rvalue_reference = var.is_rvalue_reference;
    ref_var.reference_target = source_var_name;
    interpreter_->current_scope().variables[node->name] = ref_var;
}
```

## 未実装機能 ❌

### 1. メンバーアクセスでの参照解決
**問題**: `ref.x` が `p1.x` を参照しない
- **ファイル**: `src/backend/interpreter/evaluator/access/member.cpp`
- **状態**: ❌ 未実装
- **理由**: 複数のメンバーアクセスパスがあり、全てで参照名解決が必要

**テスト結果**:
```
Point p1;
p1.x = 10;
Point&& ref = p1;
println(ref.x);  // 出力: 0 (期待値: 10) ❌
```

### 2. 代入での参照解決
**問題**: `ref.x = 100` が `p1.x` を変更しない
- **ファイル**: `src/backend/interpreter/executors/assignments/member_assignment.cpp`
- **状態**: ❌ 未実装
- **理由**: 代入時に参照ターゲットの解決が必要

**テスト結果**:
```
Point p1;
p1.x = 10;
Point&& ref = p1;
ref.x = 100;
println(p1.x);  // 出力: 10 (期待値: 100) ❌
```

### 3. 真のエイリアスセマンティクス
**問題**: 参照変数が独立したコピーとして動作
- **根本原因**: 変数テーブルに別エントリとして保存されている
- **状態**: ❌ 未実装
- **必要な変更**: アーキテクチャレベルの修正が必要

**テスト結果**:
```
Point p1;
p1.x = 10;
Point&& ref = p1;
p1.x = 99;  // p1を変更
println(ref.x);  // 出力: 0 (期待値: 99) ❌
```

## 技術的課題

### 根本的な問題
現在の実装では、変数が**値渡しでコピー**されるため、真の参照セマンティクスを実現できません。

```cpp
// 現在の実装
interpreter_->current_scope().variables[node->name] = ref_var;
// → std::mapへの挿入でコピーが発生
```

### 解決策の選択肢

#### オプション1: 参照マップアプローチ ⭐ 推奨
変数テーブルとは別に、参照名→元の変数名のマッピングを持つ。

```cpp
// Interpreterクラスに追加
std::map<std::string, std::string> reference_map_;

// 参照変数アクセス時
std::string resolve_reference(const std::string& name) {
    auto it = reference_map_.find(name);
    return (it != reference_map_.end()) ? it->second : name;
}
```

**利点**:
- 既存のコードへの影響が少ない
- 参照チェーンの管理が明確
- デバッグが容易

**欠点**:
- 全てのメンバーアクセス/代入パスで `resolve_reference()` 呼び出しが必要

#### オプション2: ポインタアプローチ
参照変数の値として元の変数のアドレスを保持。

**利点**:
- C++の参照に近い動作

**欠点**:
- 型システムの大幅な変更が必要
- ポインタとの区別が難しい

#### オプション3: 全アクセスパスで参照解決
現在のアプローチを完成させる（多数の箇所を修正）。

**欠点**:
- 修正箇所が多い（member.cpp の複数パス、assignment.cpp、sync.cpp等）
- メンテナンスが困難
- バグが発生しやすい

## テストケース

### テスト1: 構文解析（✅ PASS）
```cb
struct Point { int x; int y; };
int main() {
    Point p1;
    Point&& ref = p1;  // パース成功
}
```

### テスト2: 型制限（✅ PASS）
```cb
int main() {
    int x = 10;
    int&& ref = x;  // エラー: "Rvalue references (T&&) are only supported for struct types"
}
```

### テスト3: メンバーアクセス（❌ FAIL）
**ファイル**: `/tmp/test_ref_simple.cb`
```cb
struct Point { int x; int y; };
int main() {
    Point p1;
    p1.x = 10;
    Point&& ref = p1;
    println(ref.x);  // 期待: 10, 実際: 0
}
```

### テスト4: メンバー代入（❌ FAIL）
**ファイル**: `/tmp/test_ref_debug.cb`
```cb
struct Point { int x; int y; };
int main() {
    Point p1;
    p1.x = 10;
    Point&& ref = p1;
    ref.x = 100;
    println(p1.x);  // 期待: 100, 実際: 10
}
```

## 次のステップ（v0.10.1 または v0.11.0）

### Phase 1: 参照マップの実装
1. `Interpreter` クラスに `reference_map_` を追加
2. `resolve_reference()` ヘルパー関数を実装
3. 参照変数作成時にマップに登録

### Phase 2: メンバーアクセスの修正
1. `member.cpp` の全パスで `resolve_reference()` を呼び出し
2. `sync_struct_members_from_direct_access()` での参照解決
3. ネストメンバーアクセスでの参照解決

### Phase 3: 代入の修正
1. `member_assignment.cpp` での参照解決
2. `simple_assignment.cpp` での参照解決

### Phase 4: テストとデバッグ
1. 既存テストが壊れていないか確認
2. 参照セマンティクスのテストを追加
3. エッジケースのテスト（参照の参照、配列メンバー等）

## 関連ファイル

### 修正済みファイル
- `src/backend/interpreter/core/interpreter.h`
- `src/backend/interpreter/managers/variables/declaration.cpp`
- `src/backend/interpreter/managers/variables/manager.cpp`
- `src/frontend/recursive_parser/parsers/type_utility_parser.cpp`
- `src/frontend/recursive_parser/parsers/variable_declaration_parser.cpp`
- `src/common/ast.h`
- `src/frontend/recursive_parser/recursive_parser.h`
- `src/backend/interpreter/evaluator/access/member.cpp` (部分的)

### 修正が必要なファイル（v0.10.1以降）
- `src/backend/interpreter/evaluator/access/member.cpp` (完全な参照解決)
- `src/backend/interpreter/executors/assignments/member_assignment.cpp`
- `src/backend/interpreter/executors/assignments/simple_assignment.cpp`
- `src/backend/interpreter/managers/structs/sync.cpp`
- `src/backend/interpreter/evaluator/access/recursive_member_evaluator.h/cpp`

## コミットメッセージ案
```
feat(v0.10.0): Add T&& (rvalue reference) syntax support (partial)

- Implement T&& syntax parsing and type checking
- Add is_rvalue_reference flag to Variable, ASTNode, ParsedTypeInfo
- Implement reference chain tracking in find_variable()
- Restrict T&& to struct types only (T& allowed for all types)
- Add reference_target field to track reference source

Known limitations:
- Member access through references not yet working
- Assignment through references not yet working
- Reference semantics (aliasing) incomplete

Full implementation planned for v0.10.1 or v0.11.0
```

## まとめ

**v0.10.0での達成**:
- ✅ T&& 構文のパースと型チェック
- ✅ データ構造の拡張
- ✅ 基本的な参照トラッキング機構

**v0.10.1/v0.11.0で必要な作業**:
- ❌ メンバーアクセスでの参照解決
- ❌ 代入での参照解決
- ❌ 完全な参照セマンティクス（エイリアス動作）

推定作業時間: 8-12時間（参照マップアプローチの場合）
