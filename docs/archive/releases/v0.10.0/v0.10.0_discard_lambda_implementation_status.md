# v0.10.0 無名変数と無名関数の実装状況

**実装日**: 2024年末  
**バージョン**: v0.10.0  
**担当**: GitHub Copilot

## 概要

Cb言語v0.10.0向けに、無名変数（Discard Variables）と無名関数（Lambda Expressions）の2つの新機能を実装しました。

## 1. 無名変数（Discard Variables）- ✅ 完了

### 仕様
- 識別子 `_` を使用して値を破棄
- 式の副作用は実行されるが、値は保存されない
- 複数の無名変数を同じスコープで使用可能

### 実装内容

#### 1.1 AST拡張
- **ファイル**: `src/common/ast.h`, `src/common/ast.cpp`
- 新しいノードタイプ: `AST_DISCARD_VARIABLE`
- フィールド追加:
  - `bool is_discard`
  - `std::string internal_name`
  - `static int discard_counter`
- ヘルパー関数: `generate_discard_name()` - 内部識別子を生成

#### 1.2 パーサー拡張
- **ファイル**: `src/frontend/recursive_parser/parsers/primary_expression_parser.cpp`
- `_` 識別子を検出してAST_DISCARD_VARIABLEノードを作成
- **ファイル**: `src/frontend/recursive_parser/parsers/variable_declaration_parser.cpp`
- 変数宣言時に `_` を検出し、内部名を生成
- 初期化式を評価するが変数は登録しない

#### 1.3 インタプリタ拡張
- **ファイル**: `src/backend/interpreter/core/interpreter.cpp`
- `AST_DISCARD_VARIABLE` ケースを追加
- 初期化式の副作用のみ実行、変数は登録しない
- **ファイル**: `src/backend/interpreter/evaluator/core/evaluator.cpp`
- 無名変数への参照時にエラーを投げる
- **ファイル**: `src/backend/interpreter/evaluator/core/dispatcher.cpp`
- `AST_DISCARD_VARIABLE` ケースを追加

#### 1.4 ビルド設定
- **ファイル**: `Makefile`
- `COMMON_OBJS` に `$(COMMON_DIR)/ast.o` を追加

### テスト
- **テストファイル**: `tests/integration/discard_variable_test.cb`
- **テストケース**:
  1. 基本的な無名変数宣言
  2. 関数戻り値の破棄
  3. 同じスコープ内での複数の無名変数

### テスト結果
```
=== Discard Variable Tests ===

Test 1: Basic discard variable
OK: Discard variables declared successfully

Test 2: Discard function return value
Computing...
OK: Function was called but return value ignored

Test 3: Multiple discard variables in same scope
OK: Multiple discard variables in same scope

=== All tests passed! ===
```

**ステータス**: ✅ 完全に動作確認済み

---

## 2. 無名関数（Lambda Expressions）- ⚠️ 部分実装

### 仕様
- 構文: `type func(param_types...) { body }`
- 関数ポインタとして扱われる
- ローカル変数に代入可能
- 関数ポインタ構文で呼び出し可能: `(*lambda)(args)` または `lambda(args)`

### 実装内容

#### 2.1 AST拡張
- **ファイル**: `src/common/ast.h`, `src/common/ast.cpp`
- 新しいノードタイプ: `AST_LAMBDA_EXPR`
- フィールド追加:
  - `bool is_lambda`
  - `std::unique_ptr<ASTNode> lambda_body`
  - `std::vector<std::unique_ptr<ASTNode>> lambda_params`
  - `TypeInfo lambda_return_type`
  - `std::string lambda_return_type_name`
  - `static int lambda_counter`
- ヘルパー関数: `generate_lambda_name()` - 内部識別子を生成

#### 2.2 レキサー拡張
- **ファイル**: `src/frontend/recursive_parser/recursive_lexer.{h,cpp}`
- 新しいトークン: `TOK_FUNC`
- キーワード登録: `{"func", TokenType::TOK_FUNC}`

#### 2.3 パーサー拡張
- **ファイル**: `src/frontend/recursive_parser/parsers/primary_expression_parser.{h,cpp}`
- 新しいメソッド: `parseLambda()`
- ラムダ式の先読み検出ロジック:
  1. 型トークンを検出
  2. 次に `func` キーワードを確認
  3. ラムダとして解析
- ラムダ本体は `AST_STMT_LIST` として解析
- パラメータを `parameters` フィールドに移動（関数と同じ構造）

#### 2.4 インタプリタ拡張
- **ファイル**: `src/backend/interpreter/core/interpreter.cpp`
- `AST_LAMBDA_EXPR` ケースを追加（evaluatorに委譲）
- **ファイル**: `src/backend/interpreter/evaluator/core/evaluator.cpp`
- ラムダ式を評価してグローバルスコープに関数として登録
- `ReturnException` を投げて関数ポインタ情報を渡す
- **ファイル**: `src/backend/interpreter/evaluator/core/dispatcher.cpp`
- `AST_LAMBDA_EXPR` ケースを追加

#### 2.5 関数呼び出しの拡張
- **ファイル**: `src/backend/interpreter/evaluator/functions/call.cpp`
- `lambda_body` フィールドのサポート追加
- ラムダの場合は `lambda_body`、通常の関数は `body` を使用
- **ファイル**: `src/backend/interpreter/evaluator/functions/call_impl.cpp`
- 同様に `lambda_body` のサポート追加（3箇所）

### テスト
- **テストファイル**: 
  - `tests/integration/lambda_simple_test.cb` - ラムダ作成のみ（✅動作）
  - `tests/integration/lambda_assign_test.cb` - 変数代入（❌クラッシュ）
  - `tests/integration/lambda_call_test.cb` - 呼び出し（未テスト）

### テスト結果
```
# Simple test (creation only)
Testing lambda expression...
Lambda created successfully!
✅ PASS

# Assignment test
Before lambda
❌ CRASH (no output after this point)
```

### 既知の問題

#### 問題1: 関数スコープ内でのラムダ式の変数代入時にクラッシュ
**症状**: 関数スコープ内でラムダ式を変数に代入しようとするとプログラムが無限ループまたはクラッシュ

**発生箇所**:
```cb
int main() {
    int* myLambda = int func(int x) { return x + 1; };  // ここでクラッシュ
    return 0;
}
```

**根本原因（調査結果）**:
1. **アーキテクチャ上の問題**: Cbのインタプリタは、変数宣言の処理フロー(`process_variable_declaration`)が非常に複雑で、ラムダ式のような新しいノードタイプが考慮されていない
2. **処理フローの問題**: ポインタ型変数の初期化式として`AST_LAMBDA_EXPR`が来た場合、適切な分岐に入らず、無限ループまたはクラッシュを引き起こす
3. **ReturnExceptionの到達問題**: ラムダ式の評価は成功し、`ReturnException`も正しく投げられているが、変数宣言処理側で適切にキャッチされない

**デバッグ情報**:
```
[LAMBDA] Evaluating lambda expression
[LAMBDA] Lambda name: __lambda_1
[LAMBDA] Registering lambda to global scope
[LAMBDA] Registration complete
[LAMBDA] Creating ReturnException
[LAMBDA] Throwing ReturnException
```
→ この後、処理が停止（無限ループまたはクラッシュ）

**技術的詳細**:
- ラムダ式の構文解析: ✅ 成功
- ラムダ式のグローバル関数登録: ✅ 成功
- `ReturnException`の生成: ✅ 成功
- 変数宣言処理での`ReturnException`キャッチ: ❌ 失敗
  - `process_variable_declaration`関数で、`init_expr->node_type == AST_LAMBDA_EXPR`のケースが適切に処理されていない
  - ポインタ型の初期化式処理は`AST_FUNC_CALL`のみを想定しており、`AST_LAMBDA_EXPR`が追加されたが、それでも到達していない可能性
  - 変数宣言処理の複雑な分岐により、早期リターンまたは無限ループが発生

**回避策**:
現時点では、**グローバルスコープでのみラムダ式をサポート**するか、ラムダ式の使用を避ける

**根本的な解決策（今後の作業）**:
1. `process_variable_declaration`関数のリファクタリング（1800行以上の巨大関数を分割）
2. ラムダ式専用の処理パスを追加
3. または、ラムダ式を通常の関数宣言として別途処理し、その参照を変数に代入する設計に変更

---

## 3. ファイル変更一覧

### 新規作成
- `src/common/ast.cpp` - 静的カウンタと名前生成関数

### 修正
- `src/common/ast.h` - AST拡張
- `src/frontend/recursive_parser/recursive_lexer.{h,cpp}` - TOK_FUNC追加
- `src/frontend/recursive_parser/parsers/primary_expression_parser.{h,cpp}` - ラムダ解析
- `src/frontend/recursive_parser/parsers/variable_declaration_parser.cpp` - 無名変数処理
- `src/backend/interpreter/core/interpreter.cpp` - 新ノードタイプ処理
- `src/backend/interpreter/evaluator/core/evaluator.cpp` - 評価ロジック
- `src/backend/interpreter/evaluator/core/dispatcher.cpp` - ディスパッチ追加
- `src/backend/interpreter/evaluator/functions/call.cpp` - lambda_bodyサポート
- `src/backend/interpreter/evaluator/functions/call_impl.cpp` - lambda_bodyサポート（3箇所）
- `Makefile` - ast.o追加

### テストファイル
- `tests/integration/discard_variable_test.cb` - 無名変数テスト
- `tests/integration/lambda_simple_test.cb` - ラムダ作成テスト
- `tests/integration/lambda_assign_test.cb` - ラムダ代入テスト
- `tests/integration/lambda_call_test.cb` - ラムダ呼び出しテスト

---

## 4. 今後の作業

### 優先度: 高
1. [ ] ラムダ式の変数代入時のクラッシュ修正
2. [ ] ラムダ関数の呼び出しテスト
3. [ ] 統合テストフレームワークへの追加

### 優先度: 中
4. [ ] エラーメッセージの改善
5. [ ] ドキュメントの更新
6. [ ] 複雑なラムダ式のテストケース追加

### 優先度: 低
7. [ ] ラムダのキャプチャ機能（将来の拡張）
8. [ ] ラムダの型推論改善

---

## 5. コード例

### 無名変数の使用例
```cb
// 基本的な使用
int _ = 42;  // 値は破棄される

// 関数戻り値の破棄
int compute() { 
    println("Computing...");
    return 100; 
}
int _ = compute();  // 副作用（println）は実行される

// 複数の無名変数
int _ = 1;
int _ = 2;
int _ = 3;  // すべて異なる内部名を持つ
```

### 無名関数の使用例（期待される動作）
```cb
// 基本的なラムダ
int* double_func = int func(int x) {
    return x * 2;
};

int result = (*double_func)(5);  // result = 10

// 複数パラメータ
int* add_func = int func(int a, int b) {
    return a + b;
};

int sum = add_func(3, 7);  // sum = 10
```

---

## 6. 参考資料

### 類似機能の実装
- 関数ポインタ: `sample/function_pointer_demo.cb`
- 変数宣言: `src/backend/interpreter/managers/variables/declaration.cpp`
- 関数呼び出し: `src/backend/interpreter/evaluator/functions/call_impl.cpp`

### 設計ドキュメント
- [BNF仕様](../BNF.md)
- [実装ロードマップ](v0.10.0_implementation_plan.md)

---

## 7. まとめ

無名変数は完全に実装され、テスト済みです。無名関数は基本的な実装は完了していますが、変数代入時にクラッシュする問題があり、完全な動作確認には至っていません。この問題の修正が次の最優先タスクです。
