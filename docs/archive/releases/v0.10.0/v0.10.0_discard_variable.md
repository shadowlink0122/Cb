# 無名変数（アンダースコア識別子）実装計画

**作成日**: 2025年10月9日  
**対象バージョン**: v0.10.0  
**優先度**: 🟡 中

---

## 📋 概要

`_`（アンダースコア）を無名変数として扱い、使用されない値を明示的に無視できるようにする。

---

## 🎯 目的

1. **意図の明確化**: 値を無視することを明示的に表現
2. **未使用変数警告の回避**: 使わない戻り値を受け取る際の警告を抑制
3. **将来のタプル対応**: 複数の戻り値から一部のみを取り出す際に使用

---

## 📝 基本仕様

### 構文

#### パターン1: 関数戻り値の無視

```cb
// 将来的にタプルが実装された場合
// func (int, string) get_data() {
//     return (42, "hello");
// }

// void main() {
//     (int value, _) = get_data();  // 文字列を無視
//     println(value);  // 42
// }
```

#### パターン2: ループでの無視

```cb
void main() {
    int[5] arr = [1, 2, 3, 4, 5];
    
    // インデックスを使わない場合
    for (int _ = 0; _ < 5; _++) {
        // インデックスは不要だが、ループは必要
        println("iteration");
    }
}
```

#### パターン3: 関数パラメータでの無視（将来）

```cb
// 使わないパラメータを明示
func void callback(int data, _) {
    println(data);
    // 第2引数は使わない
}
```

### 重要な特性

#### 1. 代入には使用できない

```cb
void main() {
    int _ = 10;  // ✅ 宣言時は可能（ただし値は無視される）
    _ = 20;      // ❌ エラー: 無名変数への代入は不可
    println(_);  // ❌ エラー: 無名変数の参照は不可
}
```

#### 2. 複数の`_`が同じスコープに存在可能

```cb
void main() {
    int _ = 10;     // 内部的に __discard_1
    string _ = "a"; // 内部的に __discard_2
    float _ = 3.14; // 内部的に __discard_3
    
    // 重複エラーは発生しない
    // すべて異なる内部識別子として扱われる
}
```

#### 3. 使用場面の制限

**許可される場面**:
- 変数宣言の左辺
- タプル分解（将来）の一部
- ループの制御変数（意味は薄いが構文上は可能）

**禁止される場面**:
- 代入の左辺（宣言以外）
- 式の中での参照
- 関数呼び出しの引数

---

## 🔧 実装要件

### 1. 構文拡張

**Lexer**:
- `_` を特殊な識別子として認識
- 通常の識別子とは別に扱う

**Parser**:
- `_` を検出した場合、無名変数として解析
- 参照や代入を検出した場合はエラー

### 2. AST拡張

```cpp
// 識別子ノードを拡張
struct IdentifierNode : public ExpressionNode {
    std::string name;
    bool is_discard;  // NEW: 無名変数かどうか
    std::string internal_name;  // NEW: 内部識別子（_の場合のみ使用）
};
```

### 3. 識別子の自動生成

**命名規則**:
```cpp
class DiscardNameGenerator {
    static int discard_counter;
    
public:
    static std::string generate() {
        return "__discard_" + std::to_string(++discard_counter);
    }
};
```

### 4. 型チェック

**宣言時の検証**:
```cpp
void TypeChecker::check_variable_declaration(VariableDeclarationNode* node) {
    if (node->name == "_") {
        // 無名変数として扱う
        node->is_discard = true;
        node->internal_name = DiscardNameGenerator::generate();
        
        // 初期化式の型チェックは行うが、値は保存しない
        check_expression(node->initializer);
    }
}
```

**参照時のエラー**:
```cpp
void TypeChecker::check_identifier(IdentifierNode* node) {
    if (node->name == "_") {
        throw std::runtime_error(
            "Cannot reference discard variable '_'"
        );
    }
}
```

**代入時のエラー**:
```cpp
void TypeChecker::check_assignment(AssignmentNode* node) {
    if (node->target->name == "_") {
        throw std::runtime_error(
            "Cannot assign to discard variable '_'"
        );
    }
}
```

### 5. インタプリタでの実装

**変数宣言時**:
```cpp
void Interpreter::declare_variable(VariableDeclarationNode* node) {
    if (node->is_discard) {
        // 初期化式を評価するが、値は破棄
        if (node->initializer) {
            evaluate(node->initializer);
            // 変数テーブルには登録しない（またはダミー登録）
        }
        return;
    }
    
    // 通常の変数宣言処理
    // ...
}
```

**最適化**:
無名変数は実際には変数を作成せず、初期化式の副作用のみを実行:

```cpp
void Interpreter::handle_discard_variable(ExpressionNode* initializer) {
    // 副作用のある式（関数呼び出しなど）は実行
    if (has_side_effects(initializer)) {
        evaluate(initializer);
    }
    // 純粋な式は評価をスキップ（最適化）
}
```

---

## 📊 実装ステップ

### Phase 1: 基本実装（1週間）
- [ ] `_` の特殊な識別子としての認識
- [ ] 内部識別子の自動生成
- [ ] 宣言時の処理

### Phase 2: エラー検出（1週間）
- [ ] 参照エラーの検出
- [ ] 代入エラーの検出
- [ ] 適切なエラーメッセージ

### Phase 3: 最適化（1週間）
- [ ] 副作用のない式のスキップ
- [ ] 変数テーブルへの登録最適化

### Phase 4: テストと検証（1週間）
- [ ] 基本的な無名変数テスト
- [ ] エラーケーステスト
- [ ] 最適化の検証

---

## 🧪 テストケース

### 1. 基本的な無名変数
```cb
void main() {
    int _ = 10;     // OK: 値を無視
    string _ = "a"; // OK: 値を無視
    
    // 実際には何も保存されない
}
```

### 2. 関数戻り値の無視
```cb
func int compute() {
    println("computing...");
    return 42;
}

void main() {
    int _ = compute();  // OK: 戻り値を無視するが関数は実行される
    // 出力: computing...
}
```

### 3. エラーケース: 参照
```cb
void main() {
    int _ = 10;
    println(_);  // ❌ エラー: 無名変数を参照できない
}
```

### 4. エラーケース: 代入
```cb
void main() {
    int _ = 10;  // OK
    _ = 20;      // ❌ エラー: 無名変数に代入できない
}
```

### 5. 複数の無名変数
```cb
void main() {
    int _ = 1;      // 内部: __discard_1
    int _ = 2;      // 内部: __discard_2
    string _ = "a"; // 内部: __discard_3
    
    // 重複エラーなし
}
```

### 6. ループでの使用
```cb
void main() {
    // インデックスを使わないループ
    for (int _ = 0; _ < 5; _++) {
        println("hello");
    }
}
```

### 7. タプル分解（将来の実装）
```cb
// 将来的な使用例
func (int, string, float) get_data() {
    return (42, "hello", 3.14);
}

void main() {
    (int value, _, float pi) = get_data();
    // 文字列は無視、整数と浮動小数点のみ使用
    println(value);  // 42
    println(pi);     // 3.14
}
```

---

## 🔗 他言語での実装

### Go言語

```go
// 戻り値の無視
value, _ := someFunction()

// ループ
for _, item := range items {
    fmt.Println(item)
}

// 複数の_
_, _ = a, b
```

### Python

```python
# タプルアンパック
value, _ = some_function()

# 複数の値を無視
_, _, value = (1, 2, 3)

# ループ
for _ in range(5):
    print("hello")
```

### Rust

```rust
// パターンマッチング
let (x, _) = (10, 20);

// 構造体のフィールド無視
let Point { x, y: _ } = point;
```

---

## ⚠️ 注意事項

1. **副作用**: 無名変数への代入式が副作用を持つ場合、その副作用は実行される
2. **型チェック**: 型は通常通りチェックされる（無視されるだけで型は必要）
3. **パフォーマンス**: 最適化により、不要な計算をスキップ可能
4. **デバッグ**: デバッグ時に無名変数は表示されない（または特殊表示）

---

## 🔄 将来の拡張

### 1. タプル分解での使用

```cb
func (int, string, float) get_values() {
    return (42, "hello", 3.14);
}

void main() {
    (int x, _, float z) = get_values();
    println(x);  // 42
    println(z);  // 3.14
    // 文字列は無視
}
```

### 2. 関数パラメータでの使用

```cb
// 使わないパラメータを明示
func void callback(int data, string _) {
    println(data);
    // 第2引数は使わないことを明示
}
```

### 3. 構造体の分解代入

```cb
struct Point {
    int x;
    int y;
    int z;
};

void main() {
    Point p = {10, 20, 30};
    (int x, _, int z) = p;  // yを無視
    println(x);  // 10
    println(z);  // 30
}
```

### 4. パターンマッチング（遠い将来）

```cb
match value {
    (1, _) => println("First is 1"),
    (_, 2) => println("Second is 2"),
    _ => println("Other")
}
```

---

## 📐 Cb言語における設計方針

### 現在の使用場面

現時点では使用場面が限られているため、将来の拡張を見据えた実装:

1. **副作用のある式の実行**: 関数呼び出しの戻り値を無視
2. **意図の明確化**: 使わない変数であることを明示
3. **警告の抑制**: 未使用変数警告を回避

### タプル実装後の主な用途

```cb
// エラーハンドリング（Result型的な使用）
(int value, string _) = try_parse("123");  // エラーメッセージを無視

// 複数戻り値
(int result, _) = divide_with_remainder(10, 3);  // 余りを無視

// イテレータ（将来）
for ((int index, string _) in items.enumerate()) {
    println(index);  // 値は無視、インデックスのみ使用
}
```

---

**更新履歴**:
- 2025/10/09: 初版作成
