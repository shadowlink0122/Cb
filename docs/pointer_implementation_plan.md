# ネストした構造体とポインタ実装の設計ドキュメント

## 1. 現在の制限
- ネストした構造体メンバーアクセス（`obj.member.submember`）は未実装
- メモリ使用量と実装複雑さを考慮し、ポインタ実装を将来実装として延期

## 2. 代替実装（現在利用可能）
```cb
// ❌ ネストしたアクセス（未実装）
struct Company {
    string name;
    Address address;  // ネストした構造体
};
Company tech_corp;
tech_corp.address.street = "123 Main St";  // エラー

// ✅ フラット実装（現在実装済み）
struct Company {
    string name;
    int employee_count;
};
struct Address {
    string street;
    string city;
    int zipcode;
};
Company tech_corp;
Address corp_address;  // 分離された構造体
corp_address.street = "123 Main St";  // 動作する
```

## 3. 将来のポインタ実装計画

### 3.1 型システム拡張
- `TYPE_POINTER` 型を `ast.h` に追加済み
- ポインタ変数の管理システム
- ポインタ演算とメモリ管理

### 3.2 パーサー拡張
- `*` と `&` 演算子のトークン化
- ポインタ宣言構文の解析
- ポインタアクセス構文の解析

### 3.3 インタープリター拡張
- ポインタ変数の作成と管理
- メモリアドレスの管理
- ポインタを通じたメンバーアクセス

### 3.4 メモリ管理
- ヒープメモリ管理システム
- ガベージコレクションまたは手動メモリ管理
- メモリリーク検出

## 4. 実装上の課題

### 4.1 メモリ使用量
- 深いネスト構造でのメモリ使用量の指数的増加
- 循環参照の処理
- メモリリークの防止

### 4.2 パフォーマンス
- ポインタアクセスのオーバーヘッド
- メモリ断片化の管理
- キャッシュ効率の考慮

### 4.3 安全性
- ヌルポインタアクセスの検出
- ダングリングポインタの防止
- バッファオーバーフローの防止

## 5. 推奨される実装順序
1. 基本的なポインタ型システム
2. ポインタ変数の宣言と初期化
3. ポインタを通じた値アクセス
4. 構造体ポインタの実装
5. ネストしたメンバーアクセスの実装
6. 動的メモリ管理の実装

## 6. 現在の回避策
ネストした構造体が必要な場合は、以下の方法を使用：
- 構造体を個別変数として分離
- 関数を使った構造体間の関係管理
- 配列を使った関連データの管理

## 7. エラーメッセージ
現在のパーサーは以下のエラーメッセージを出力：
```
Nested member access (obj.member.submember) is not supported yet. 
Consider using pointers in future implementation.
```

このメッセージにより、ユーザーは将来実装される機能であることを理解できる。
