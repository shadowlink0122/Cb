// ネストした構造体のデストラクタテスト
// 構造体メンバーが構造体の場合、ポインタの場合、参照の場合のデストラクタ動作を検証

struct Inner {
    int value;
};

impl Inner {
    self(int v) {
        self.value = v;
        println("[INNER] Constructor: value=", self.value);
    }
    
    ~self() {
        println("[INNER] Destructor: value=", self.value);
    }
};

struct Outer {
    Inner* inner_by_pointer;
    int id;
};

impl Outer {
    self(int outer_id) {
        self.id = outer_id;
        self.inner_by_pointer = nullptr;
        println("[OUTER] Constructor: id=", self.id);
    }
    
    ~self() {
        println("[OUTER] Destructor: id=", self.id);
        // NOTE: v0.10.0では、ポインタメンバーのデストラクタは自動的には呼ばれない
        // これは正しい動作（ポインタは所有権を持たない）
    }
};

void test_struct_with_pointer_member() {
    println("=== Test 1: Struct with Pointer Member ===");
    Inner inner(100);
    Outer outer(1);
    outer.inner_by_pointer = &inner;
    println("[MAIN] Outer created with inner pointer");
    println("");
    // v0.10.0: outerとinnerのデストラクタが呼ばれる（LIFO: outer, inner）
    // inner_by_pointerはポインタなので、そのデストラクタは別途呼ばれない（正しい動作）
}

void test_multiple_structs() {
    println("=== Test 2: Multiple Structs ===");
    Inner inner1(200);
    Inner inner2(201);
    Outer outer1(2);
    Outer outer2(3);
    println("[MAIN] Multiple structs created");
    println("");
    // LIFO順: outer2, outer1, inner2, inner1
}

void main() {
    println("===== Nested Struct Destructor Test =====");
    println("");
    
    test_struct_with_pointer_member();
    test_multiple_structs();
    
    println("===== Test Completed =====");
}
