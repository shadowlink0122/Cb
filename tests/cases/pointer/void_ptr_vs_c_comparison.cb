// Comparison: Cb void* vs C/C++ void*
// Testing if Cb's void* behaves the same as C/C++

// ============================================================================
// C/C++での void* の使い方 (コメントで説明)
// ============================================================================

// C/C++では:
//
// 1. 任意の型のポインタを void* に代入できる
//    int x = 42;
//    int* int_ptr = &x;
//    void* generic_ptr = int_ptr;  // OK
//
// 2. void* から任意の型のポインタにキャストできる
//    int* restored_ptr = (int*)generic_ptr;
//
// 3. void* 自体は逆参照できない
//    *generic_ptr = 10;  // ERROR: void型は不完全型
//
// 4. 主な用途:
//    - malloc/free: void* malloc(size_t size);
//    - 汎用コールバック: void callback(void* user_data);
//    - 型消去: 異なる型を統一的に扱う

// ============================================================================
// Cbでの void* の現在の機能
// ============================================================================

interface Allocator {
    void* allocate(int size);      // C/C++と同じ: void*を返す
    void deallocate(void* ptr);    // C/C++と同じ: void*を受け取る
}

struct SystemAllocator {
    int count;
};

impl Allocator for SystemAllocator {
    void* allocate(int size) {
        println("[Cb] Allocating {size} bytes");
        // 現在: nullptr を返す (プレースホルダー)
        // 将来: 実際のメモリアドレスを返す
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        println("[Cb] Deallocating void* pointer");
        // void*を受け取る (C/C++と同じ)
    }
}

// ============================================================================
// Test 1: void* as generic pointer container
// ============================================================================

void test_generic_pointer_concept() {
    println("\n=== Test 1: void* as generic pointer ===");
    println("Concept: void* can store 'any' pointer type");
    
    // 現在のCb: nullptr を格納
    void* ptr1 = nullptr;
    void* ptr2 = nullptr;
    void* ptr3 = nullptr;
    
    println("Created 3 void* pointers (currently nullptr)");
    println("In C/C++, these could point to int*, char*, struct*, etc.");
    
    println("✅ void* can be declared and assigned");
}

// ============================================================================
// Test 2: void* passed between functions
// ============================================================================

void* create_generic_pointer() {
    println("Creating generic pointer");
    return nullptr;  // In C: could return malloc(size)
}

void use_generic_pointer(void* ptr) {
    println("Received generic pointer");
    // In C: could cast and use: int* typed = (int*)ptr;
}

void test_function_parameters() {
    println("\n=== Test 2: void* function parameters ===");
    
    void* ptr = create_generic_pointer();
    use_generic_pointer(ptr);
    
    println("✅ void* works as return value and parameter");
}

// ============================================================================
// Test 3: Multiple void* in struct (like C memory pool)
// ============================================================================

struct GenericContainer {
    void* data1;
    void* data2;
    void* data3;
};

void test_struct_storage() {
    println("\n=== Test 3: void* in struct ===");
    println("Concept: Like C's memory pool or generic container");
    
    GenericContainer container;
    container.data1 = nullptr;
    container.data2 = nullptr;
    container.data3 = nullptr;
    
    println("Created struct with 3 void* members");
    println("In C/C++: data1 could be int*, data2 could be char*, etc.");
    
    println("✅ void* works as struct members");
}

// ============================================================================
// Test 4: Allocator pattern (like C's malloc/free)
// ============================================================================

void test_allocator_pattern() {
    println("\n=== Test 4: Allocator pattern (like malloc/free) ===");
    println("C malloc:  void* malloc(size_t size);");
    println("C free:    void free(void* ptr);");
    println("");
    
    SystemAllocator alloc;
    
    // Same pattern as C malloc
    void* ptr1 = alloc.allocate(100);  // Like malloc(100)
    void* ptr2 = alloc.allocate(200);  // Like malloc(200)
    
    // Same pattern as C free
    alloc.deallocate(ptr1);  // Like free(ptr1)
    alloc.deallocate(ptr2);  // Like free(ptr2)
    
    println("✅ Cb's void* works like C's malloc/free pattern");
}

// ============================================================================
// Test 5: Type erasure concept
// ============================================================================

void process_generic_data(void* data, int size) {
    println("Processing generic data: size={size} bytes");
    // In C/C++: Cast to appropriate type based on context
}

void test_type_erasure() {
    println("\n=== Test 5: Type erasure concept ===");
    println("Concept: void* 'erases' the type information");
    
    // Simulate different types (all nullptr for now)
    void* int_data = nullptr;      // Could be: int*
    void* char_data = nullptr;     // Could be: char*
    void* struct_data = nullptr;   // Could be: MyStruct*
    
    // Process without knowing original type
    process_generic_data(int_data, 4);     // sizeof(int)
    process_generic_data(char_data, 1);    // sizeof(char)
    process_generic_data(struct_data, 16); // sizeof(MyStruct)
    
    println("✅ void* provides type erasure like C/C++");
}

// ============================================================================
// Test 6: Comparison with C/C++ behavior
// ============================================================================

void test_comparison_with_c() {
    println("\n=== Test 6: Cb vs C/C++ comparison ===");
    println("");
    println("┌────────────────────────────────────────┬─────────┬─────────┐");
    println("│ Feature                                │   C     │   Cb    │");
    println("├────────────────────────────────────────┼─────────┼─────────┤");
    println("│ void* variable declaration             │   ✅    │   ✅    │");
    println("│ void* as function return type          │   ✅    │   ✅    │");
    println("│ void* as function parameter            │   ✅    │   ✅    │");
    println("│ void* in struct                        │   ✅    │   ✅    │");
    println("│ nullptr assignment                     │   ✅    │   ✅    │");
    println("│ Type casting (int*)ptr                 │   ✅    │   ⚪    │");
    println("│ Direct dereference *ptr                │   ❌    │   ❌    │");
    println("│ Pointer arithmetic ptr+1               │   ❌    │   ❌    │");
    println("└────────────────────────────────────────┴─────────┴─────────┘");
    println("");
    println("Legend:");
    println("  ✅ = Supported");
    println("  ⚪ = Planned/Future feature");
    println("  ❌ = Not allowed (by design)");
    println("");
    println("Note: Both C and Cb disallow direct dereference/arithmetic");
    println("      because void* has no type information");
}

// ============================================================================
// Test 7: Why void* is called "generic pointer"
// ============================================================================

void test_generic_pointer_explanation() {
    println("\n=== Test 7: Why 'generic pointer'? ===");
    println("");
    println("汎用ポインタ (Generic Pointer) = void*");
    println("");
    println("理由:");
    println("1. 「汎用」= どんな型のポインタも格納できる");
    println("   int*    -> void* ✅");
    println("   char*   -> void* ✅");
    println("   struct* -> void* ✅");
    println("");
    println("2. 「型消去」= 元の型情報を失う");
    println("   void* ptr = some_pointer;");
    println("   // ptrからは元の型がわからない");
    println("");
    println("3. 「型安全性」= 使用時にキャストが必要");
    println("   void* generic = ...");
    println("   int* typed = (int*)generic;  // 明示的なキャスト");
    println("");
    println("✅ Cb's void* follows the same concept as C/C++");
}

// ============================================================================
// Main test suite
// ============================================================================

void main() {
    println("╔════════════════════════════════════════════════════════════╗");
    println("║  Cb void* vs C/C++ void* Comparison                       ║");
    println("╚════════════════════════════════════════════════════════════╝");
    
    test_generic_pointer_concept();
    test_function_parameters();
    test_struct_storage();
    test_allocator_pattern();
    test_type_erasure();
    test_comparison_with_c();
    test_generic_pointer_explanation();
    
    println("\n╔════════════════════════════════════════════════════════════╗");
    println("║  結論: Cb の void* は C/C++ と同じ汎用ポインタです     ║");
    println("║                                                            ║");
    println("║  汎用ポインタ = 任意の型のポインタを格納できる         ║");
    println("║  void*       = Generic pointer (type-erased pointer)      ║");
    println("╚════════════════════════════════════════════════════════════╝");
}
