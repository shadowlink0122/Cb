// 関数ポインタの配列テスト
// 複数の関数ポインタを管理して動的に呼び出す

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

void main() {
    // 関数ポインタ変数を3つ宣言
    int* op0 = &add;
    int* op1 = &subtract;
    int* op2 = &multiply;
    
    // テスト1: 各関数ポインタを順番に呼び出し
    int result1 = op0(10, 5);
    println(result1);  // 期待値: 15
    
    int result2 = op1(10, 5);
    println(result2);  // 期待値: 5
    
    int result3 = op2(10, 5);
    println(result3);  // 期待値: 50
    
    // テスト2: 条件分岐で関数ポインタを選択
    int opType = 0;
    int* selectedOp = &add;
    
    if (opType == 0) {
        selectedOp = op0;
    }
    if (opType == 1) {
        selectedOp = op1;
    }
    if (opType == 2) {
        selectedOp = op2;
    }
    
    int result4 = selectedOp(8, 4);
    println(result4);  // 期待値: 12 (opType=0なのでadd)
    
    // テスト3: 別の条件
    opType = 2;
    if (opType == 0) {
        selectedOp = op0;
    }
    if (opType == 1) {
        selectedOp = op1;
    }
    if (opType == 2) {
        selectedOp = op2;
    }
    
    int result5 = selectedOp(8, 4);
    println(result5);  // 期待値: 32 (opType=2なのでmultiply)
    
    // テスト4: 連続計算
    int x = 10;
    x = op0(x, 5);   // 10 + 5 = 15
    x = op2(x, 2);   // 15 * 2 = 30
    x = op1(x, 10);  // 30 - 10 = 20
    println(x);      // 期待値: 20
}
