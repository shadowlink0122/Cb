// Stdlib Test Runner - å…¨stdlibãƒ†ã‚¹ãƒˆã‚’1ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§å®Ÿè¡Œ
// Resultå‹ã§ã‚¨ãƒ©ãƒ¼æ¤œå‡º

import stdlib.std.test;

// Resultå‹ - ãƒ†ã‚¹ãƒˆçµæœã‚’è¡¨ç¾
export struct TestSuiteResult {
    bool success;
    int passed;
    int failed;
    string suite_name;
};

// Allocatorãƒ†ã‚¹ãƒˆ
void test_system_allocator(TestResult* t) {
    print_section("SystemAllocator");
    // TODO: SystemAllocatorã®ãƒ†ã‚¹ãƒˆå®Ÿè£…
    t.assert_true(true, "SystemAllocator placeholder test");
}

void test_bump_allocator(TestResult* t) {
    print_section("BumpAllocator");
    // TODO: BumpAllocatorã®ãƒ†ã‚¹ãƒˆå®Ÿè£…
    t.assert_true(true, "BumpAllocator placeholder test");
}

// VectoråŸºæœ¬ãƒ†ã‚¹ãƒˆ
void test_vector_basic(TestResult* t) {
    print_section("Vector Basic Operations");
    
    import stdlib.std.vector;
    
    Vector<int> vec;
    
    // push_back
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    
    t.assert_eq_long(vec.get_length(), 3, "Length after push_back");
    t.assert_eq_int(vec.at(0), 10, "First element");
    t.assert_eq_int(vec.at(1), 20, "Second element");
    t.assert_eq_int(vec.at(2), 30, "Third element");
    
    // pop_back
    vec.pop_back();
    t.assert_eq_long(vec.get_length(), 2, "Length after pop_back");
    
    // is_empty
    t.assert_false(vec.is_empty(), "Vector is not empty");
}

// Vectorã‚½ãƒ¼ãƒˆãƒ†ã‚¹ãƒˆï¼ˆåŠ¹ç‡çš„ãªæ¤œè¨¼é–¢æ•°ä»˜ãï¼‰
bool verify_ascending_vector(Vector<int> vec) {
    if (vec.get_length() <= 1) {
        return true;
    }
    
    int ptr_size = sizeof(void*);
    int data_offset = ptr_size + ptr_size;
    
    void* current = vec.front;
    while (current != nullptr) {
        void** next_ptr_field = current + ptr_size;
        void* next_node = *next_ptr_field;
        
        if (next_node != nullptr) {
            void** current_data_ptr = current + data_offset;
            int current_data = *current_data_ptr;
            void** next_data_ptr = next_node + data_offset;
            int next_data = *next_data_ptr;
            
            if (current_data > next_data) {
                return false;
            }
        }
        
        current = next_node;
    }
    
    return true;
}

bool verify_descending_vector(Vector<int> vec) {
    if (vec.get_length() <= 1) {
        return true;
    }
    
    int ptr_size = sizeof(void*);
    int data_offset = ptr_size + ptr_size;
    
    void* current = vec.front;
    while (current != nullptr) {
        void** next_ptr_field = current + ptr_size;
        void* next_node = *next_ptr_field;
        
        if (next_node != nullptr) {
            void** current_data_ptr = current + data_offset;
            int current_data = *current_data_ptr;
            void** next_data_ptr = next_node + data_offset;
            int next_data = *next_data_ptr;
            
            if (current_data < next_data) {
                return false;
            }
        }
        
        current = next_node;
    }
    
    return true;
}

void test_vector_sort(TestResult* t) {
    print_section("Vector Sort Operations");
    
    import stdlib.std.vector;
    
    // smaller()
    Vector<int> vec1;
    int i = 10;
    while (i > 0) {
        vec1.push_back(i);
        i = i - 1;
    }
    vec1.smaller();
    t.assert_true(verify_ascending_vector(vec1), "smaller() sorts in ascending order");
    t.assert_eq_int(vec1.at(0), 1, "First element after smaller()");
    
    // greater()
    Vector<int> vec2;
    i = 1;
    while (i <= 10) {
        vec2.push_back(i);
        i = i + 1;
    }
    vec2.greater();
    t.assert_true(verify_descending_vector(vec2), "greater() sorts in descending order");
    t.assert_eq_int(vec2.at(0), 10, "First element after greater()");
    
    // sort()
    Vector<int> vec3;
    vec3.push_back(5);
    vec3.push_back(2);
    vec3.push_back(8);
    vec3.push_back(1);
    vec3.sort();
    t.assert_true(verify_ascending_vector(vec3), "sort() sorts in ascending order");
}

// QueueåŸºæœ¬ãƒ†ã‚¹ãƒˆ
void test_queue_basic(TestResult* t) {
    print_section("Queue Basic Operations");
    
    import stdlib.std.queue;
    
    Queue<int> q;
    
    // push (enqueue)
    q.push(10);
    q.push(20);
    q.push(30);
    
    t.assert_eq_int(q.size(), 3, "Size after push");
    t.assert_eq_int(q.top(), 10, "Front element");
    
    // pop (dequeue)
    int val = q.pop();
    t.assert_eq_int(val, 10, "Popped value");
    t.assert_eq_int(q.size(), 2, "Size after pop");
    
    // is_empty
    t.assert_false(q.is_empty(), "Queue is not empty");
}

// MapåŸºæœ¬ãƒ†ã‚¹ãƒˆ
void test_map_basic(TestResult* t) {
    print_section("Map Basic Operations");
    
    import stdlib.std.map;
    
    Map<int, int> m;
    
    // insert
    m.insert(1, 100);
    m.insert(2, 200);
    m.insert(3, 300);
    
    t.assert_eq_int(m.size(), 3, "Size after insert");
    t.assert_true(m.contains(1), "Key 1 exists");
    t.assert_true(m.contains(2), "Key 2 exists");
    t.assert_false(m.contains(99), "Key 99 does not exist");
    
    // get
    int val = m.get(2, -1);
    t.assert_eq_int(val, 200, "Value for key 2");
    
    // try_remove
    bool removed = m.try_remove(2);
    t.assert_true(removed, "Key 2 removed");
    t.assert_eq_int(m.size(), 2, "Size after remove");
}

// ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆå®Ÿè¡Œé–¢æ•°
TestSuiteResult run_allocator_tests() {
    TestSuiteResult result;
    result.suite_name = "Allocators";
    
    TestResult t;
    
    test_system_allocator(&t);
    test_bump_allocator(&t);
    
    result.passed = t.passed;
    result.failed = t.failed;
    result.success = t.failed == 0;
    
    return result;
}

TestSuiteResult run_vector_tests() {
    TestSuiteResult result;
    result.suite_name = "Vector";
    
    TestResult t;
    
    test_vector_basic(&t);
    test_vector_sort(&t);
    
    result.passed = t.passed;
    result.failed = t.failed;
    result.success = t.failed == 0;
    
    return result;
}

TestSuiteResult run_queue_tests() {
    TestSuiteResult result;
    result.suite_name = "Queue";
    
    TestResult t;
    
    test_queue_basic(&t);
    
    result.passed = t.passed;
    result.failed = t.failed;
    result.success = t.failed == 0;
    
    return result;
}

TestSuiteResult run_map_tests() {
    TestSuiteResult result;
    result.suite_name = "Map";
    
    TestResult t;
    
    test_map_basic(&t);
    
    result.passed = t.passed;
    result.failed = t.failed;
    result.success = t.failed == 0;
    
    return result;
}

void main() {
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘  Cb Standard Library - Comprehensive Test Suite          â•‘");
    println("â•‘  All tests in one file with Result-based error detection â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("");
    
    // å…¨ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œ
    int total_passed = 0;
    int total_failed = 0;
    int suites_passed = 0;
    int suites_failed = 0;
    
    // [1/4] Allocators
    println("[1/4] Running Allocator Tests...");
    TestSuiteResult r1 = run_allocator_tests();
    total_passed = total_passed + r1.passed;
    total_failed = total_failed + r1.failed;
    if (r1.success) {
        println("  âœ… {r1.suite_name}: {r1.passed} tests passed");
        suites_passed = suites_passed + 1;
    } else {
        println("  âŒ {r1.suite_name}: {r1.failed} tests failed");
        suites_failed = suites_failed + 1;
    }
    println("");
    
    // [2/4] Vector
    println("[2/4] Running Vector Tests...");
    TestSuiteResult r2 = run_vector_tests();
    total_passed = total_passed + r2.passed;
    total_failed = total_failed + r2.failed;
    if (r2.success) {
        println("  âœ… {r2.suite_name}: {r2.passed} tests passed");
        suites_passed = suites_passed + 1;
    } else {
        println("  âŒ {r2.suite_name}: {r2.failed} tests failed");
        suites_failed = suites_failed + 1;
    }
    println("");
    
    // [3/4] Queue
    println("[3/4] Running Queue Tests...");
    TestSuiteResult r3 = run_queue_tests();
    total_passed = total_passed + r3.passed;
    total_failed = total_failed + r3.failed;
    if (r3.success) {
        println("  âœ… {r3.suite_name}: {r3.passed} tests passed");
        suites_passed = suites_passed + 1;
    } else {
        println("  âŒ {r3.suite_name}: {r3.failed} tests failed");
        suites_failed = suites_failed + 1;
    }
    println("");
    
    // [4/4] Map
    println("[4/4] Running Map Tests...");
    TestSuiteResult r4 = run_map_tests();
    total_passed = total_passed + r4.passed;
    total_failed = total_failed + r4.failed;
    if (r4.success) {
        println("  âœ… {r4.suite_name}: {r4.passed} tests passed");
        suites_passed = suites_passed + 1;
    } else {
        println("  âŒ {r4.suite_name}: {r4.failed} tests failed");
        suites_failed = suites_failed + 1;
    }
    println("");
    
    // æœ€çµ‚ã‚µãƒãƒªãƒ¼
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘  Final Test Summary                                       â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    println("Total Tests:  {total_passed + total_failed} tests");
    println("  Passed:     {total_passed} tests");
    println("  Failed:     {total_failed} tests");
    println("");
    println("Test Suites:  {suites_passed + suites_failed} suites");
    println("  Passed:     {suites_passed} suites");
    println("  Failed:     {suites_failed} suites");
    println("");
    
    if (total_failed == 0) {
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println("â•‘  ğŸ‰ All Standard Library Tests Passed!                   â•‘");
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    } else {
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println("â•‘  âš ï¸  Some Tests Failed - Review Output Above             â•‘");
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }
}
