// Comprehensive test for Vector<T> and Queue<T> with basic types
// Note: Struct support is limited due to generic impl return value constraints

import stdlib.collections.vector;
import stdlib.collections.queue;

void test_vector_int() {
    println("═══ Test 1: Vector<int> ═══");
    Vector<int> vec;
    vec.init(4);
    
    vec.push(10);
    vec.push(20);
    vec.push(30);
    vec.push(40);
    
    println("Length: ", vec.get_length());
    println("vec[0] = ", vec.get(0));
    println("vec[1] = ", vec.get(1));
    println("vec[2] = ", vec.get(2));
    println("vec[3] = ", vec.get(3));
    
    int popped = vec.pop();
    println("Popped: ", popped);
    println("Length after pop: ", vec.get_length());
    
    if (vec.get(0) == 10 && vec.get(1) == 20 && vec.get(2) == 30 && popped == 40) {
        println("✅ Vector<int> works!");
    }
}

void test_vector_long() {
    println("\n═══ Test 2: Vector<long> ═══");
    Vector<long> vec;
    vec.init(4);
    
    long v1 = 100;
    long v2 = 200;
    long v3 = 300;
    
    vec.push(v1);
    vec.push(v2);
    vec.push(v3);
    
    println("Length: ", vec.get_length());
    println("vec[0] = ", vec.get(0));
    println("vec[1] = ", vec.get(1));
    println("vec[2] = ", vec.get(2));
    
    if (vec.get(0) == 100 && vec.get(1) == 200 && vec.get(2) == 300) {
        println("✅ Vector<long> works!");
    }
}

void test_queue_int() {
    println("\n═══ Test 3: Queue<int> ═══");
    Queue<int> q;
    
    q.enqueue(1);
    q.enqueue(2);
    q.enqueue(3);
    
    println("Size: ", q.size());
    println("Peek: ", q.peek());
    
    int d1 = q.dequeue();
    println("Dequeued: ", d1);
    println("Size after dequeue: ", q.size());
    
    int d2 = q.dequeue();
    println("Dequeued: ", d2);
    
    if (d1 == 1 && d2 == 2 && q.peek() == 3) {
        println("✅ Queue<int> works!");
    }
}

void test_queue_long() {
    println("\n═══ Test 4: Queue<long> ═══");
    Queue<long> q;
    
    long v1 = 1000;
    long v2 = 2000;
    long v3 = 3000;
    
    q.enqueue(v1);
    q.enqueue(v2);
    q.enqueue(v3);
    
    println("Size: ", q.size());
    
    long d1 = q.dequeue();
    println("Dequeued: ", d1);
    
    long d2 = q.dequeue();
    println("Dequeued: ", d2);
    
    if (d1 == 1000 && d2 == 2000) {
        println("✅ Queue<long> works!");
    }
}

void test_queue_short() {
    println("\n═══ Test 5: Queue<short> ═══");
    Queue<short> q;
    
    short s1 = 10;
    short s2 = 20;
    short s3 = 30;
    
    q.enqueue(s1);
    q.enqueue(s2);
    q.enqueue(s3);
    
    println("Size: ", q.size());
    
    short d1 = q.dequeue();
    println("Dequeued: ", d1);
    
    if (d1 == 10) {
        println("✅ Queue<short> works!");
    }
}

void main() {
    println("╔═══════════════════════════════════════════════════════════════╗");
    println("║  Vector<T> and Queue<T> Comprehensive Test                   ║");
    println("╚═══════════════════════════════════════════════════════════════╝");
    println();
    
    test_vector_int();
    test_vector_long();
    test_queue_int();
    test_queue_long();
    test_queue_short();
    
    println("\n╔═══════════════════════════════════════════════════════════════╗");
    println("║  All tests passed! ✅                                         ║");
    println("║                                                               ║");
    println("║  Supported types: int, long, short, string                   ║");
    println("║  Struct support: Limited (cannot return from generic impl)   ║");
    println("╚═══════════════════════════════════════════════════════════════╝");
}
