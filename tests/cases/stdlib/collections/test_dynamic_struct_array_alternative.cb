// æ§‹é€ ä½“é…åˆ—ã®å‹•çš„ç¢ºä¿ã®ä»£æ›¿å®Ÿè£…
// malloc ã®åˆ¶é™ã«ã‚ˆã‚Šã€æ§‹é€ ä½“é…åˆ—ã¯ãƒ©ãƒƒãƒ‘ãƒ¼æ§‹é€ ä½“çµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹

struct Point {
    int x;
    int y;
};

// Pointé…åˆ—ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹æ§‹é€ ä½“
struct PointArray {
    Point* data;
    int capacity;
    int element_size;
};

// PointArrayã‚’åˆæœŸåŒ–
PointArray* point_array_new(int capacity) {
    PointArray* arr = malloc(sizeof(PointArray));
    arr->capacity = capacity;
    arr->element_size = sizeof(Point);
    arr->data = malloc(arr->element_size * capacity);
    return arr;
}

// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹iã®è¦ç´ ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—
void* point_array_get_ptr(PointArray* arr, int index) {
    if (index < 0 || index >= arr->capacity) {
        println("Error: index out of bounds");
        return nullptr;
    }
    long base = arr->data;
    long offset = index * arr->element_size;
    long target = base + offset;
    void* result = target;
    return result;
}

// ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¨­å®šï¼ˆä½ãƒ¬ãƒ™ãƒ«APIä½¿ç”¨ï¼‰
void point_array_set(PointArray* arr, int index, int x_val, int y_val) {
    void* ptr = point_array_get_ptr(arr, index);
    if (ptr == nullptr) return;
    
    // x ã¯ offset 0
    array_set_int(ptr, 0, x_val);
    // y ã¯ offset 1 (intã‚µã‚¤ã‚ºå˜ä½)
    array_set_int(ptr, 1, y_val);
}

// ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—
int point_array_get_x(PointArray* arr, int index) {
    void* ptr = point_array_get_ptr(arr, index);
    if (ptr == nullptr) return 0;
    return array_get_int(ptr, 0);
}

int point_array_get_y(PointArray* arr, int index) {
    void* ptr = point_array_get_ptr(arr, index);
    if (ptr == nullptr) return 0;
    return array_get_int(ptr, 1);
}

// è§£æ”¾
void point_array_free(PointArray* arr) {
    if (arr->data != nullptr) {
        free(arr->data);
    }
    free(arr);
}

int main() {
    println("=== Dynamic Struct Array (Alternative Implementation) ===\n");
    
    println("--- Test 1: PointArray creation and initialization ---");
    int N = 5;
    PointArray* points = point_array_new(N);
    println("âœ… Created PointArray with capacity {N}");
    
    // åˆæœŸåŒ–
    println("\nInitializing elements//.");
    int i = 0;
    while (i < N) {
        point_array_set(points, i, i * 10, i * 20);
        int x = point_array_get_x(points, i);
        int y = point_array_get_y(points, i);
        println("  points[{i}] = ({x}, {y})");
        i = i + 1;
    }
    
    // èª­ã¿å‡ºã—
    println("\n--- Test 2: Reading values ---");
    i = 0;
    bool values_ok = true;
    while (i < N) {
        int x = point_array_get_x(points, i);
        int y = point_array_get_y(points, i);
        int expected_x = i * 10;
        int expected_y = i * 20;
        
        if (x != expected_x || y != expected_y) {
            println("âŒ points[{i}] has wrong values: ({x}, {y})");
            values_ok = false;
        }
        i = i + 1;
    }
    
    if (values_ok) {
        println("âœ… All values are correct");
    }
    
    // å¤‰æ›´
    println("\n--- Test 3: Modifying elements ---");
    point_array_set(points, 0, 100, 200);
    point_array_set(points, 2, 300, 400);
    
    int x0 = point_array_get_x(points, 0);
    int y0 = point_array_get_y(points, 0);
    println("points[0] = ({x0}, {y0})");
    
    int x2 = point_array_get_x(points, 2);
    int y2 = point_array_get_y(points, 2);
    println("points[2] = ({x2}, {y2})");
    
    // points[1]ãŒå½±éŸ¿ã‚’å—ã‘ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    int x1 = point_array_get_x(points, 1);
    int y1 = point_array_get_y(points, 1);
    if (x1 == 10 && y1 == 20) {
        println("âœ… points[1] remains unchanged: ({x1}, {y1})");
    } else {
        println("âŒ points[1] was corrupted: ({x1}, {y1})");
    }
    
    point_array_free(points);
    println("\nâœ… Memory freed");
    
    println("\nğŸ‰ Dynamic Struct Array (Alternative) Tests Passed!");
    println("\nNOTE: Due to interpreter limitations, malloc'd memory cannot");
    println("      directly support struct member access (ptr->member).");
    println("      This implementation uses array_get_int.array_set_int as");
    println("      a workaround for low-level memory access.");
    
    return 0;
}
