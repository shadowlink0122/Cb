// Comprehensive Test: Generic Vector<T> and Queue<T>
// Tests that both containers work with multiple types using TRUE GENERIC IMPLEMENTATION

import "stdlib/collections/vector.cb";
import "stdlib/collections/queue.cb";

struct Point {
    int x;
    int y;
};

void main() {
    println("╔═══════════════════════════════════════════════════════════════╗");
    println("║  Generic Container Comprehensive Test                        ║");
    println("║  Vector<T> + Queue<T> - TRUE GENERIC IMPLEMENTATION          ║");
    println("╚═══════════════════════════════════════════════════════════════╝");
    println("");
    
    // ================================================================
    // Test 1: Vector<int>
    // ================================================================
    println("═══ Test 1: Vector<int> ═══");
    Vector<int> vec_int;
    vec_int.push_back(10);
    vec_int.push_back(20);
    vec_int.push_back(30);
    
    println("Vector<int> length: ", vec_int.get_length());
    println("Vector<int>[0]: ", vec_int.at(0));
    println("Vector<int>[1]: ", vec_int.at(1));
    println("Vector<int>[2]: ", vec_int.at(2));
    
    int last = vec_int.at(2);
    vec_int.pop_back();
    println("Popped: ", last);
    println("✅ Vector<int> works correctly");
    println("");
    
    // ================================================================
    // Test 2: Vector<long>
    // ================================================================
    println("═══ Test 2: Vector<long> ═══");
    Vector<long> vec_long;
    vec_long.push_back(123456789);
    vec_long.push_back(987654321);
    
    println("Vector<long> length: ", vec_long.get_length());
    println("Vector<long>[0]: ", vec_long.at(0));
    println("✅ Vector<long> works correctly");
    println("");
    
    // ================================================================
    // Test 3: Queue<int>
    // ================================================================
    println("═══ Test 3: Queue<int> ═══");
    Queue<int> queue_int;
    queue_int.push(100);
    queue_int.push(200);
    queue_int.push(300);
    
    println("Queue<int> size: ", queue_int.size());
    int peeked = queue_int.top();
    println("Peeked: ", peeked);
    
    int popped = queue_int.pop();
    println("Popped: ", popped);
    println("Queue<int> size after pop: ", queue_int.size());
    println("✅ Queue<int> works correctly");
    println("");
    
    // ================================================================
    // Test 4: Queue<long>
    // ================================================================
    println("═══ Test 4: Queue<long> ═══");
    Queue<long> queue_long;
    queue_long.push(111111111);
    queue_long.push(222222222);
    
    println("Queue<long> size: ", queue_long.size());
    long val_long = queue_long.pop();
    println("Popped from Queue<long>: ", val_long);
    println("✅ Queue<long> works correctly");
    println("");
    
    // ================================================================
    // Test 5: Vector dynamic growth
    // ================================================================
    println("═══ Test 5: Vector<int> auto-resize ═══");
    Vector<int> vec_resize;
    println("Initial length: ", vec_resize.get_length());
    
    vec_resize.push_back(1);
    vec_resize.push_back(2);
    println("After 2 pushes, length: ", vec_resize.get_length());
    
    vec_resize.push_back(3);  // Linked list grows dynamically
    println("After 3 pushes, length: ", vec_resize.get_length());
    println("Length: ", vec_resize.get_length());
    println("✅ Vector auto-resize works");
    println("");
    
    // ================================================================
    // Test 6: Queue dynamic growth
    // ================================================================
    println("═══ Test 6: Queue<int> dynamic growth ═══");
    Queue<int> queue_circular;
    
    queue_circular.push(1);
    queue_circular.push(2);
    queue_circular.push(3);
    println("Queue has 3 items");
    
    queue_circular.pop();
    queue_circular.pop();
    println("Popped 2 items");
    
    queue_circular.push(4);
    queue_circular.push(5);
    println("Pushed 2 more items");
    println("Queue size: ", queue_circular.size());
    println("✅ Dynamic growth works");
    println("");
    
    // ================================================================
    // Test 7: Memory management (destructor test)
    // ================================================================
    println("═══ Test 7: Memory management ═══");
    {
        Vector<int> temp_vec;
        temp_vec.push_back(999);
        println("Created temporary vector in scope");
        
        Queue<int> temp_queue;
        temp_queue.push(888);
        println("Created temporary queue in scope");
    }
    println("Scope exited - destructors called automatically");
    println("✅ Memory management works");
    println("");
    
    // ================================================================
    // Summary
    // ================================================================
    println("╔═══════════════════════════════════════════════════════════════╗");
    println("║  ✅ ALL TESTS PASSED                                         ║");
    println("╠═══════════════════════════════════════════════════════════════╣");
    println("║  Tested:                                                      ║");
    println("║    ✓ Vector<int>, Vector<long>                               ║");
    println("║    ✓ Queue<int>, Queue<long>                                 ║");
    println("║    ✓ Dynamic growth (Vector & Queue)                         ║");
    println("║    ✓ Memory management (destructors)                         ║");
    println("║                                                               ║");
    println("║  TRUE GENERIC IMPLEMENTATION:                                ║");
    println("║    • Single impl for all types                               ║");
    println("║    • sizeof(T) for type-aware memory                         ║");
    println("║    • array_get/array_set for generic operations              ║");
    println("╚═══════════════════════════════════════════════════════════════╝");
}
