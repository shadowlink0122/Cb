// æ§‹é€ ä½“é…åˆ—ã®å‹•çš„ç¢ºä¿ã¨ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ
// STRUCT* S = malloc(sizeof(STRUCT)*N); ã§ STRUCT[N] ã‚’å†ç¾

struct Point {
    int x;
    int y;
};

struct Person {
    string name;
    int age;
};

// ãƒã‚¤ãƒ³ã‚¿æ¼”ç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
void* ptr_offset(void* ptr, int offset) {
    long base_long = ptr;
    long target_long = base_long + offset;
    void* result = target_long;
    return result;
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
void print_point(Point* p) {
    println("Point({p->x}, {p->y})");
}

int point_distance_from_origin(Point* p) {
    return p->x * p->x + p->y * p->y;
}

void person_greet(Person* p) {
    println("Hello, I'm {p->name}, {p->age} years old");
}

int main() {
    println("=== Dynamic Struct Array Test ===\n");
    
    // ãƒ†ã‚¹ãƒˆ1: Pointæ§‹é€ ä½“ã®å‹•çš„é…åˆ—
    println("--- Test 1: Point array with malloc ---");
    
    int N = 5;
    int point_size = sizeof(Point);
    println("sizeof(Point) = {point_size}");
    
    // STRUCT* S = malloc(sizeof(STRUCT)*N);
    Point* points = malloc(point_size * N);
    
    if (points == nullptr) {
        println("âŒ malloc failed");
        return 1;
    }
    
    println("âœ… Allocated memory for {N} Points at {hex(points)}");
    
    // å„è¦ç´ ã‚’åˆæœŸåŒ–
    println("\nInitializing array elements...");
    int i = 0;
    while (i < N) {
        // Cé¢¨ã®ãƒã‚¤ãƒ³ã‚¿æ¼”ç®—: points + i * sizeof(Point)
        int offset = i * point_size;
        Point* p = ptr_offset(points, offset);
        
        // æ§‹é€ ä½“ã®ãƒ¡ãƒ³ãƒãƒ¼ã«å€¤ã‚’è¨­å®š
        p->x = i * 10;
        p->y = i * 20;
        println("  Initialized points[{i}] = ({p->x}, {p->y})");
        i = i + 1;
    }
    
    // ãƒ†ã‚¹ãƒˆ: S[i]->value ã‚¢ã‚¯ã‚»ã‚¹
    println("\n--- Test 2: Member access S[i]->value ---");
    i = 0;
    bool values_ok = true;
    while (i < N) {
        int expected_x = i * 10;
        int expected_y = i * 20;
        
        int offset = i * point_size;
        Point* p = ptr_offset(points, offset);
        
        if (p->x != expected_x || p->y != expected_y) {
            println("âŒ points[{i}] has wrong values: ({p->x}, {p->y})");
            values_ok = false;
        }
        i = i + 1;
    }
    
    if (values_ok) {
        println("âœ… All S[i]->value accesses work correctly");
    } else {
        free(points);
        return 1;
    }
    
    // ãƒ†ã‚¹ãƒˆ: S[i]->func() ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
    println("\n--- Test 3: Method call S[i]->func() ---");
    println("Calling print_point() on each element:");
    i = 0;
    while (i < N) {
        print("  [{i}] ");
        int offset = i * point_size;
        print_point(ptr_offset(points, offset));
        i = i + 1;
    }
    println("âœ… All S[i]->func() calls work correctly");
    
    // ãƒ†ã‚¹ãƒˆ: ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ã®æˆ»ã‚Šå€¤
    println("\n--- Test 4: Method return values ---");
    i = 0;
    while (i < N) {
        int offset = i * point_size;
        int dist = point_distance_from_origin(ptr_offset(points, offset));
        int expected = (i * 10) * (i * 10) + (i * 20) * (i * 20);
        println("  points[{i}].distance_from_origin() = {dist} (expected: {expected})");
        
        if (dist != expected) {
            println("âŒ Method return value incorrect");
            free(points);
            return 1;
        }
        i = i + 1;
    }
    println("âœ… Method return values are correct");
    
    // ãƒ†ã‚¹ãƒˆ: é…åˆ—è¦ç´ ã®å¤‰æ›´
    println("\n--- Test 5: Modifying array elements ---");
    Point* p0 = ptr_offset(points, 0 * point_size);
    p0->x = 100;
    p0->y = 200;
    
    Point* p2 = ptr_offset(points, 2 * point_size);
    p2->x = 300;
    p2->y = 400;
    
    // å†åº¦å–å¾—ã—ã¦ç¢ºèª
    p0 = ptr_offset(points, 0 * point_size);
    if (p0->x == 100 && p0->y == 200) {
        println("âœ… points[0] modified successfully: ({p0->x}, {p0->y})");
    } else {
        println("âŒ points[0] modification failed");
        free(points);
        return 1;
    }
    
    p2 = ptr_offset(points, 2 * point_size);
    if (p2->x == 300 && p2->y == 400) {
        println("âœ… points[2] modified successfully: ({p2->x}, {p2->y})");
    } else {
        println("âŒ points[2] modification failed");
        free(points);
        return 1;
    }
    
    // ä»–ã®è¦ç´ ãŒå½±éŸ¿ã‚’å—ã‘ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    Point* p1 = ptr_offset(points, 1 * point_size);
    if (p1->x == 10 && p1->y == 20) {
        println("âœ… points[1] remains unchanged: ({p1->x}, {p1->y})");
    } else {
        println("âŒ points[1] was corrupted");
        free(points);
        return 1;
    }
    
    free(points);
    println("âœ… Memory freed");
    
    // ãƒ†ã‚¹ãƒˆ6: Personæ§‹é€ ä½“ï¼ˆstringå‹ãƒ¡ãƒ³ãƒãƒ¼å«ã‚€ï¼‰
    println("\n--- Test 6: Person array with string members ---");
    
    int M = 3;
    int person_size = sizeof(Person);
    println("sizeof(Person) = {person_size}");
    
    Person* people = malloc(person_size * M);
    
    if (people == nullptr) {
        println("âŒ malloc failed for Person array");
        return 1;
    }
    
    println("âœ… Allocated memory for {M} Persons at {hex(people)}");
    
    // åˆæœŸåŒ–
    Person* person0 = ptr_offset(people, 0 * person_size);
    person0->name = "Alice";
    person0->age = 25;
    
    Person* person1 = ptr_offset(people, 1 * person_size);
    person1->name = "Bob";
    person1->age = 30;
    
    Person* person2 = ptr_offset(people, 2 * person_size);
    person2->name = "Charlie";
    person2->age = 35;
    
    println("\nInitialized {M} people");
    
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ
    i = 0;
    bool person_ok = true;
    while (i < M) {
        int offset = i * person_size;
        Person* person = ptr_offset(people, offset);
        println("  people[{i}]: name={person->name}, age={person->age}");
        i = i + 1;
    }
    
    // ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
    println("\nCalling greet() on each person:");
    i = 0;
    while (i < M) {
        print("  ");
        int offset = i * person_size;
        person_greet(ptr_offset(people, offset));
        i = i + 1;
    }
    
    println("âœ… Person array with string members works");
    
    free(people);
    println("âœ… Person array memory freed");
    
    println("\nğŸ‰ All Dynamic Struct Array Tests Passed!");
    println("\nâœ… CONFIRMED: malloc(sizeof(STRUCT)*N) works for struct arrays");
    println("âœ… CONFIRMED: S[i]->value access works");
    println("âœ… CONFIRMED: S[i]->func() method calls work");
    
    return 0;
}
