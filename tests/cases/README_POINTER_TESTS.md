# ポインタと参照のテストスイート

このディレクトリには、ポインタと参照の動作を検証する包括的なテストケースが含まれています。

## テストカテゴリ

### 1. pointer/ - 基本的なポインタ操作
**ファイル**: `test_address_and_value_changes.cb`

**テスト内容**:
- 基本的なポインタの動作（アドレス取得と間接参照）
- ポインタの再代入（異なる変数を指す）
- 複数のポインタが同じ変数を指す場合の動作
- ダブルポインタ（`int**`）の動作
- トリプルポインタ（`int***`）の動作

**検証項目**:
- `&variable` でアドレスを取得できる
- `*ptr` でポインタ経由で値を読み取れる
- `*ptr = value` でポインタ経由で値を変更できる
- ポインタ経由で変更すると元の変数も変更される
- 複数のポインタが同じ変数を指すと、どのポインタで変更しても反映される
- 多段階の間接参照（`**ptr`, `***ptr`）が正しく動作する

### 2. pointer_functions/ - ポインタを関数パラメータとして使用
**ファイル**: `test_pointer_parameters.cb`

**テスト内容**:
- 関数にポインタを渡して値を変更
- 複数回の変更操作
- スワップ関数の実装
- ダブルポインタを関数パラメータとして使用

**検証項目**:
- 関数内でポインタ経由で変更した値が呼び出し元に反映される
- 同じ変数に対して複数の関数で変更を行える
- スワップ関数が正しく2つの変数の値を交換する
- ダブルポインタ経由での変更も正しく動作する

### 3. pointer_chain/ - ポインタチェーンと連続的な操作
**ファイル**: `test_pointer_chains.cb`

**テスト内容**:
- ポインタチェーン（`int*`, `int**`, `int***`）経由での値の変更
- ポインタの向き先を動的に変更
- ループ内でポインタ経由の連続的な代入

**検証項目**:
- `*p1 = x`, `**p2 = x`, `***p3 = x` が全て同じ変数を変更する
- ポインタを別の変数に向け直すと、以降の操作は新しい変数に影響する
- 元の変数は影響を受けない
- ループ内での連続的な操作が正しく累積される

### 4. pointer_nullptr/ - nullptr の動作
**ファイル**: `test_nullptr_checks.cb`

**テスト内容**:
- `nullptr` での初期化
- `nullptr` への再代入
- 複数の `nullptr` ポインタ
- ダブルポインタと `nullptr`

**検証項目**:
- ポインタを `nullptr` で初期化できる
- 既存のポインタを `nullptr` に再代入できる
- `nullptr` から有効なアドレスに再代入できる
- ダブルポインタでも `nullptr` が使用できる

## テスト実行方法

### 個別のテストを実行:
```bash
./main tests/cases/pointer/test_address_and_value_changes.cb
./main tests/cases/pointer_functions/test_pointer_parameters.cb
./main tests/cases/pointer_chain/test_pointer_chains.cb
./main tests/cases/pointer_nullptr/test_nullptr_checks.cb
```

### 全統合テストを実行:
```bash
make test
```

### 出力の検証:
```bash
./main tests/cases/pointer/test_address_and_value_changes.cb > output.txt
diff output.txt tests/cases/pointer/expected_output.txt
```

## 実装されているポインタ機能

✅ **基本機能**:
- ポインタ型宣言（`int*`, `int**`, `int***` など）
- アドレス演算子（`&variable`）
- 間接参照演算子（`*ptr`）
- 間接参照への代入（`*ptr = value`）
- `nullptr` リテラル

✅ **高度な機能**:
- 多段階ポインタ（ダブル、トリプルポインタ）
- ポインタを関数パラメータとして渡す
- 関数内でポインタ経由で値を変更
- ポインタの再代入

⏳ **未実装の機能**:
- アロー演算子（`ptr->member`）
- `new`/`delete` 演算子
- ポインタ演算（`ptr++`, `ptr + n`）
- 構造体のポインタメンバー
- 配列とポインタの相互運用

## テスト結果

全てのテストが期待通りの出力を生成し、以下が確認されています：

1. ポインタ経由での値の変更が正しく元の変数に反映される
2. 複数のポインタが同じ変数を指すと、すべてのポインタで同じ値が見える
3. ポインタの向き先を変更すると、以降の操作は新しい変数に影響する
4. 多段階の間接参照（`**`, `***`）が正しく動作する
5. 関数にポインタを渡して、関数内で変更した値が呼び出し元に反映される
6. `nullptr` の初期化と再代入が正しく動作する

## 注意事項

- ポインタの実装は `reinterpret_cast` を使用してメモリアドレスをシミュレートしています
- `nullptr` は内部的には `0` として表現されます
- null ポインタの間接参照（`*nullptr`）はランタイムエラーになります
- 現在、複合代入演算子（`*ptr += value`）は未サポートです
