// Test: TaskQueue - Basic Operations
// Part of v0.11.0 Week 3 Day 1
//
// Tests basic TaskQueue functionality:
// - Initialization
// - Push/pop operations
// - Priority ordering
// - Empty checks

// Task定義（task_queue_v2.cbから）
struct Task {
    int task_id;
    int priority;
    int callback_type;
    void* data;
};

interface Allocator {
    void* allocate(int size);
    void deallocate(void* ptr);
}

struct SystemAllocator {
    int allocation_count;
};

impl Allocator for SystemAllocator {
    void* allocate(int size) {
        return nullptr;
    }
    
    void deallocate(void* ptr) {
    }
}

struct TaskVector<A: Allocator> {
    int capacity;
    int length;
    Task[100] data;
};

struct TaskQueue<A: Allocator> {
    TaskVector<A> tasks;
    int next_id;
};

// TaskQueue operations implementation
void init(TaskQueue<SystemAllocator>& queue) {
    queue.tasks.length = 0;
    queue.tasks.capacity = 100;
    queue.next_id = 1;
}

void push(TaskQueue<SystemAllocator>& queue, Task& task) {
    if (queue.tasks.length >= queue.tasks.capacity) {
        return;
    }
    
    int idx = queue.tasks.length;
    queue.tasks.data[idx].task_id = task.task_id;
    queue.tasks.data[idx].priority = task.priority;
    queue.tasks.data[idx].callback_type = task.callback_type;
    queue.tasks.data[idx].data = task.data;
    queue.tasks.length = queue.tasks.length + 1;
    
    // ソート
    int i = queue.tasks.length - 1;
    while (i > 0) {
        int curr_priority = queue.tasks.data[i].priority;
        int prev_priority = queue.tasks.data[i - 1].priority;
        
        if (curr_priority < prev_priority) {
            Task temp;
            temp.task_id = queue.tasks.data[i].task_id;
            temp.priority = queue.tasks.data[i].priority;
            temp.callback_type = queue.tasks.data[i].callback_type;
            temp.data = queue.tasks.data[i].data;
            
            queue.tasks.data[i].task_id = queue.tasks.data[i - 1].task_id;
            queue.tasks.data[i].priority = queue.tasks.data[i - 1].priority;
            queue.tasks.data[i].callback_type = queue.tasks.data[i - 1].callback_type;
            queue.tasks.data[i].data = queue.tasks.data[i - 1].data;
            
            queue.tasks.data[i - 1].task_id = temp.task_id;
            queue.tasks.data[i - 1].priority = temp.priority;
            queue.tasks.data[i - 1].callback_type = temp.callback_type;
            queue.tasks.data[i - 1].data = temp.data;
            
            i = i - 1;
        } else {
            i = 0;
        }
    }
}

Task pop(TaskQueue<SystemAllocator>& queue) {
    Task result;
    
    if (queue.tasks.length <= 0) {
        result.task_id = -1;
        result.priority = 999;
        result.callback_type = -1;
        result.data = nullptr;
        return result;
    }
    
    result.task_id = queue.tasks.data[0].task_id;
    result.priority = queue.tasks.data[0].priority;
    result.callback_type = queue.tasks.data[0].callback_type;
    result.data = queue.tasks.data[0].data;
    
    int i = 0;
    while (i < queue.tasks.length - 1) {
        queue.tasks.data[i].task_id = queue.tasks.data[i + 1].task_id;
        queue.tasks.data[i].priority = queue.tasks.data[i + 1].priority;
        queue.tasks.data[i].callback_type = queue.tasks.data[i + 1].callback_type;
        queue.tasks.data[i].data = queue.tasks.data[i + 1].data;
        i = i + 1;
    }
    
    queue.tasks.length = queue.tasks.length - 1;
    return result;
}

bool is_empty(TaskQueue<SystemAllocator>& queue) {
    return queue.tasks.length <= 0;
}

int size(TaskQueue<SystemAllocator>& queue) {
    return queue.tasks.length;
}

Task create_task(int id, int priority, int callback_type) {
    Task t;
    t.task_id = id;
    t.priority = priority;
    t.callback_type = callback_type;
    t.data = nullptr;
    return t;
}

// =============================================================================
// Test Cases
// =============================================================================

void test_init() {
    println("TEST: TaskQueue initialization");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    assert(is_empty(queue));
    assert(size(queue) == 0);
    
    println("  ✅ Initialization test passed");
}

void test_push_single() {
    println("\nTEST: Push single task");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    Task t = create_task(1, 5, 0);
    push(queue, t);
    
    assert(!is_empty(queue));
    assert(size(queue) == 1);
    
    println("  ✅ Push single task test passed");
}

void test_pop_single() {
    println("\nTEST: Pop single task");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    Task t1 = create_task(1, 5, 0);
    push(queue, t1);
    
    Task popped = pop(queue);
    
    assert(popped.task_id == 1);
    assert(popped.priority == 5);
    assert(is_empty(queue));
    
    println("  ✅ Pop single task test passed");
}

void test_priority_order() {
    println("\nTEST: Priority ordering");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    // Push tasks in non-priority order
    Task t1 = create_task(1, 10, 0);  // Low priority
    Task t2 = create_task(2, 0, 0);   // High priority
    Task t3 = create_task(3, 5, 0);   // Medium priority
    
    push(queue, t1);
    push(queue, t2);
    push(queue, t3);
    
    assert(size(queue) == 3);
    
    // Pop should return in priority order (0, 5, 10)
    Task p1 = pop(queue);
    Task p2 = pop(queue);
    Task p3 = pop(queue);
    
    assert(p1.priority == 0);
    assert(p2.priority == 5);
    assert(p3.priority == 10);
    
    println("  ✅ Priority ordering test passed");
}

void test_multiple_tasks() {
    println("\nTEST: Multiple tasks with various priorities");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    // Push many tasks
    Task t1 = create_task(1, 10, 0);
    Task t2 = create_task(2, 3, 0);
    Task t3 = create_task(3, 7, 0);
    Task t4 = create_task(4, 1, 0);
    Task t5 = create_task(5, 5, 0);
    
    push(queue, t1);
    push(queue, t2);
    push(queue, t3);
    push(queue, t4);
    push(queue, t5);
    
    assert(size(queue) == 5);
    
    // Verify priority order
    int prev_priority = -1;
    while (!is_empty(queue)) {
        Task t = pop(queue);
        
        if (prev_priority >= 0) {
            assert(t.priority >= prev_priority);
        }
        
        prev_priority = t.priority;
    }
    
    println("  ✅ Multiple tasks test passed");
}

void test_pop_empty() {
    println("\nTEST: Pop from empty queue");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    Task empty = pop(queue);
    
    assert(empty.task_id == -1);
    assert(empty.priority == 999);
    
    println("  ✅ Pop empty queue test passed");
}

void test_same_priority() {
    println("\nTEST: Tasks with same priority");
    
    TaskQueue<SystemAllocator> queue;
    init(queue);
    
    // Push tasks with same priority
    Task t1 = create_task(10, 5, 0);
    Task t2 = create_task(11, 5, 0);
    Task t3 = create_task(12, 5, 0);
    
    push(queue, t1);
    push(queue, t2);
    push(queue, t3);
    
    Task p1 = pop(queue);
    Task p2 = pop(queue);
    Task p3 = pop(queue);
    
    // Should maintain insertion order for same priority
    assert(p1.task_id == 10);
    assert(p2.task_id == 11);
    assert(p3.task_id == 12);
    
    println("  ✅ Same priority test passed");
}

void main() {
    println("╔════════════════════════════════════════════════════════════╗");
    println("║  TaskQueue Test Suite                                     ║");
    println("╚════════════════════════════════════════════════════════════╝\n");
    
    test_init();
    test_push_single();
    test_pop_single();
    test_priority_order();
    test_multiple_tasks();
    test_pop_empty();
    test_same_priority();
    
    println("\n╔════════════════════════════════════════════════════════════╗");
    println("║  All TaskQueue tests passed! ✅                           ║");
    println("╚════════════════════════════════════════════════════════════╝");
}
