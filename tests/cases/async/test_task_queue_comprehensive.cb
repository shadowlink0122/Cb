// TaskQueue Comprehensive Test Suite
// Tests all TaskQueue operations with various scenarios

struct Task {
    int task_id;
    int priority;
    int callback_type;
    void* data;
};

struct TaskQueue {
    int[100] task_ids;
    int[100] priorities;
    int[100] callback_types;
    void*[100] data_ptrs;
    int length;
    int capacity;
};

void init(TaskQueue& queue) {
    queue.length = 0;
    queue.capacity = 100;
}

void push(TaskQueue& queue, Task& task) {
    if (queue.length >= queue.capacity) {
        return;
    }
    
    int idx = queue.length;
    queue.task_ids[idx] = task.task_id;
    queue.priorities[idx] = task.priority;
    queue.callback_types[idx] = task.callback_type;
    queue.data_ptrs[idx] = task.data;
    queue.length = queue.length + 1;
    
    int i = queue.length - 1;
    while (i > 0) {
        int curr_pr = queue.priorities[i];
        int prev_pr = queue.priorities[i - 1];
        
        if (curr_pr < prev_pr) {
            int temp_id = queue.task_ids[i];
            int temp_pr = queue.priorities[i];
            int temp_cb = queue.callback_types[i];
            void* temp_data = queue.data_ptrs[i];
            
            queue.task_ids[i] = queue.task_ids[i - 1];
            queue.priorities[i] = queue.priorities[i - 1];
            queue.callback_types[i] = queue.callback_types[i - 1];
            queue.data_ptrs[i] = queue.data_ptrs[i - 1];
            
            queue.task_ids[i - 1] = temp_id;
            queue.priorities[i - 1] = temp_pr;
            queue.callback_types[i - 1] = temp_cb;
            queue.data_ptrs[i - 1] = temp_data;
            
            i = i - 1;
        } else {
            i = 0;
        }
    }
}

Task pop(TaskQueue& queue) {
    if (queue.length <= 0) {
        Task invalid = {-1, 999, -1, nullptr};
        return invalid;
    }
    
    Task result = {
        queue.task_ids[0],
        queue.priorities[0],
        queue.callback_types[0],
        queue.data_ptrs[0]
    };
    
    int i = 0;
    while (i < queue.length - 1) {
        queue.task_ids[i] = queue.task_ids[i + 1];
        queue.priorities[i] = queue.priorities[i + 1];
        queue.callback_types[i] = queue.callback_types[i + 1];
        queue.data_ptrs[i] = queue.data_ptrs[i + 1];
        i = i + 1;
    }
    
    queue.length = queue.length - 1;
    return result;
}

bool is_empty(TaskQueue& queue) {
    return queue.length <= 0;
}

int size(TaskQueue& queue) {
    return queue.length;
}

Task create_task(int id, int priority, int callback_type) {
    Task task = {id, priority, callback_type, nullptr};
    return task;
}

void test_init() {
    println("\nTEST: TaskQueue initialization");
    TaskQueue queue;
    init(queue);
    
    assert(queue.length == 0);
    assert(queue.capacity == 100);
    assert(is_empty(queue));
    
    println("  ✅ Initialization test passed");
}

void test_push_single() {
    println("\nTEST: Push single task");
    TaskQueue queue;
    init(queue);
    
    Task t1 = create_task(1, 5, 0);
    push(queue, t1);
    
    assert(size(queue) == 1);
    assert(!is_empty(queue));
    
    println("  ✅ Push single task test passed");
}

void test_pop_single() {
    println("\nTEST: Pop single task");
    TaskQueue queue;
    init(queue);
    
    Task t1 = create_task(1, 5, 0);
    push(queue, t1);
    
    Task popped = pop(queue);
    int id = popped.task_id;
    int pr = popped.priority;
    
    assert(id == 1);
    assert(pr == 5);
    assert(is_empty(queue));
    
    println("  ✅ Pop single task test passed");
}

void test_priority_order() {
    println("\nTEST: Priority ordering");
    TaskQueue queue;
    init(queue);
    
    // Push tasks in non-priority order
    Task t1 = create_task(1, 10, 0);
    Task t2 = create_task(2, 0, 0);
    Task t3 = create_task(3, 5, 0);
    
    push(queue, t1);
    push(queue, t2);
    push(queue, t3);
    
    assert(size(queue) == 3);
    
    // Pop should return in priority order (0, 5, 10)
    Task p1 = pop(queue);
    Task p2 = pop(queue);
    Task p3 = pop(queue);
    
    assert(p1.priority == 0);
    assert(p2.priority == 5);
    assert(p3.priority == 10);
    
    println("  ✅ Priority ordering test passed");
}

void test_multiple_tasks() {
    println("\nTEST: Multiple tasks with various priorities");
    TaskQueue queue;
    init(queue);
    
    Task t1 = create_task(1, 10, 0);
    Task t2 = create_task(2, 3, 0);
    Task t3 = create_task(3, 7, 0);
    Task t4 = create_task(4, 1, 0);
    Task t5 = create_task(5, 5, 0);
    
    push(queue, t1);
    push(queue, t2);
    push(queue, t3);
    push(queue, t4);
    push(queue, t5);
    
    assert(size(queue) == 5);
    
    // Verify priority order
    int prev_priority = -1;
    while (!is_empty(queue)) {
        Task t = pop(queue);
        int curr_pr = t.priority;
        
        if (prev_priority >= 0) {
            assert(curr_pr >= prev_priority);
        }
        
        prev_priority = curr_pr;
    }
    
    println("  ✅ Multiple tasks test passed");
}

void test_pop_empty() {
    println("\nTEST: Pop from empty queue");
    TaskQueue queue;
    init(queue);
    
    Task empty = pop(queue);
    int id = empty.task_id;
    int pr = empty.priority;
    
    assert(id == -1);
    assert(pr == 999);
    
    println("  ✅ Pop empty queue test passed");
}

void test_same_priority() {
    println("\nTEST: Tasks with same priority (FIFO order)");
    TaskQueue queue;
    init(queue);
    
    // Push tasks with same priority
    Task t1 = create_task(10, 5, 0);
    Task t2 = create_task(11, 5, 0);
    Task t3 = create_task(12, 5, 0);
    
    push(queue, t1);
    push(queue, t2);
    push(queue, t3);
    
    Task p1 = pop(queue);
    Task p2 = pop(queue);
    Task p3 = pop(queue);
    
    // Should maintain insertion order for same priority
    assert(p1.task_id == 10);
    assert(p2.task_id == 11);
    assert(p3.task_id == 12);
    
    println("  ✅ Same priority test passed");
}

void test_capacity_limit() {
    println("\nTEST: Queue capacity limit");
    TaskQueue queue;
    init(queue);
    
    // Fill queue to capacity
    int i = 0;
    while (i < 100) {
        Task t = create_task(i, i, 0);
        push(queue, t);
        i = i + 1;
    }
    
    assert(size(queue) == 100);
    
    // Try to push one more (should be ignored)
    Task overflow = create_task(999, 0, 0);
    push(queue, overflow);
    
    assert(size(queue) == 100);  // Still 100
    
    println("  ✅ Capacity limit test passed");
}

void main() {
    println("╔════════════════════════════════════════════════════════════╗");
    println("║  TaskQueue Comprehensive Test Suite                      ║");
    println("╚════════════════════════════════════════════════════════════╝");
    
    test_init();
    test_push_single();
    test_pop_single();
    test_priority_order();
    test_multiple_tasks();
    test_pop_empty();
    test_same_priority();
    test_capacity_limit();
    
    println("\n╔════════════════════════════════════════════════════════════╗");
    println("║  ALL TESTS PASSED ✅                                       ║");
    println("╚════════════════════════════════════════════════════════════╝");
}
