// Test: Multiple await on same Future
// 同じFutureを複数回awaitした場合の動作を検証

async int compute_value(int x) {
    println("Compute: Start with {x}");
    await sleep(50);
    println("Compute: Done");
    return x * 10;
}

async string compute_string(string s) {
    println("ComputeStr: Processing '{s}'");
    await sleep(30);
    return s + "_result";
}

struct Point {
    int x;
    int y;
};

async Point compute_point(int x, int y) {
    println("ComputePoint: ({x}, {y})");
    await sleep(20);
    Point p;
    p.x = x * 2;
    p.y = y * 2;
    return p;
}

// Future配列のテスト
async int task_id(int id) {
    println("Task {id}: Start");
    await sleep(10 * id);
    println("Task {id}: Done");
    return id * 100;
}

void main() {
    println("=== Future Multiple Await Test ===\n");
    
    // Test 1: 同じFutureを2回await
    println("[Test 1] Await same Future twice");
    Future<int> f1 = compute_value(5);
    
    println("First await...");
    int result1a = await f1;
    println("First result: {result1a}");
    
    println("Second await...");
    int result1b = await f1;
    println("Second result: {result1b}");
    
    if (result1a == 50 && result1b == 50) {
        println("✅ Test 1 passed (same result: {result1a})\n");
    } else {
        println("❌ Test 1 failed (results: {result1a}, {result1b})\n");
    }
    
    // Test 2: 文字列型Future
    println("[Test 2] String type Future");
    Future<string> f2 = compute_string("test");
    
    string result2a = await f2;
    string result2b = await f2;
    
    println("Results: '{result2a}', '{result2b}'");
    // 文字列比較は == で行う
    if (result2a == "test_result" && result2b == "test_result") {
        println("✅ Test 2 passed\n");
    } else {
        println("❌ Test 2 failed\n");
    }
    
    // Test 3: 構造体型Future（直接awaitする方式）
    // Note: ジェネリクスが構造体をサポートしていないため、
    // Future<Point>変数の宣言は避け、直接awaitする
    println("[Test 3] Struct type Future (direct await)");
    Point result3 = await compute_point(3, 4);
    
    println("Result: ({result3.x}, {result3.y})");
    
    if (result3.x == 6 && result3.y == 8) {
        println("✅ Test 3 passed\n");
    } else {
        println("❌ Test 3 failed\n");
    }
    
    // ========================================================================
    // 以下のテストはv0.13.0でジェネリクス配列サポートを実装後に有効化
    // 現在はジェネリクス構造体の配列アクセス時に型情報が失われる問題あり
    // 詳細: docs/todo/v0.13.0_generic_array_support.md
    // ========================================================================
    
    // // Test 4: Future配列的な使い方
    // println("[Test 4] Multiple Futures");
    // Future<int> futures[3];
    // futures[0] = task_id(1);
    // futures[1] = task_id(2);
    // futures[2] = task_id(3);
    // 
    // println("Awaiting futures in order...");
    // int r0 = await futures[0];
    // int r1 = await futures[1];
    // int r2 = await futures[2];
    // 
    // println("Results: {r0}, {r1}, {r2}");
    // if (r0 == 100 && r1 == 200 && r2 == 300) {
    //     println("✅ Test 4 passed\n");
    // } else {
    //     println("❌ Test 4 failed\n");
    // }
    // 
    // // Test 5: Future配列を逆順でawait
    // println("[Test 5] Await futures in reverse order");
    // Future<int> futures2[3];
    // futures2[0] = task_id(1);
    // futures2[1] = task_id(2);
    // futures2[2] = task_id(3);
    // 
    // println("Awaiting in reverse...");
    // int r2b = await futures2[2];  // 最長（30ms）を先にawait
    // int r1b = await futures2[1];  // 既に完了しているはず
    // int r0b = await futures2[0];  // 既に完了しているはず
    // 
    // println("Results: {r2b}, {r1b}, {r0b}");
    // if (r0b == 100 && r1b == 200 && r2b == 300) {
    //     println("✅ Test 5 passed (reverse order works)\n");
    // } else {
    //     println("❌ Test 5 failed\n");
    // }
    // 
    // // Test 6: Futureを変数に保存して後でawait
    // println("[Test 6] Store Future and await later");
    // Future<int> saved_future = compute_value(7);
    // 
    // println("Doing other work...");
    // await sleep(20);
    // 
    // println("Now awaiting saved future...");
    // int saved_result = await saved_future;
    // println("Result: {saved_result}");
    // 
    // if (saved_result == 70) {
    //     println("✅ Test 6 passed\n");
    // } else {
    //     println("❌ Test 6 failed\n");
    // }
    // 
    // // Test 7: awaitせずにFutureを破棄（メモリリークチェック）
    // println("[Test 7] Discard Future without await");
    // Future<int> discarded = compute_value(9);
    // println("Future created but not awaited");
    // await sleep(100);  // タスクが完了するまで待つ
    // println("✅ Test 7 completed (no crash)\n");
    
    println("=== Future Tests Completed (3/7 tests - v0.12.0) ===");
    println("Note: Tests 4-7 require generic array support (v0.13.0)");
}
