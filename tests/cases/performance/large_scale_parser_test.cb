// 大規模パーサー効率性テスト - スケーラビリティ確認

int[10] get_large_array() {
    int[10] arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    return arr;
}

int mega_calc(int a, int b, int c, int d, int e) {
    return ((a + b) * (c - d)) / (e + 1) + 
           ((a * c) - (b * d)) * (e % 3) +
           ((a ^ b) & (c | d)) >> (e % 4);
}

int main() {
    println("=== Large Scale Parser Efficiency Test ===");
    
    // 大量の変数宣言（パーサーのメモリ効率）
    int v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5;
    int v6 = 6, v7 = 7, v8 = 8, v9 = 9, v10 = 10;
    int v11 = 11, v12 = 12, v13 = 13, v14 = 14, v15 = 15;
    int v16 = 16, v17 = 17, v18 = 18, v19 = 19, v20 = 20;
    
    // 大規模演算チェーン（演算子優先順位の大規模テスト）
    int huge_calc = 
        v1 + v2 * v3 - v4 / 2 + v5 % 3 +
        v6 << 1 + v7 >> 1 - v8 & 15 | v9 ^ v10 +
        v11 * v12 + v13 - v14 * v15 / v16 + v17 % v18 +
        v19 + v20 - v1 * v2 + v3 / 2 - v4 % 3;
    
    println("Huge calculation result: %d", huge_calc);
    
    // 多重配列アクセス（型推論エンジンの負荷テスト）
    int array_sum = 
        get_large_array()[0] + get_large_array()[1] + get_large_array()[2] +
        get_large_array()[3] + get_large_array()[4] + get_large_array()[5] +
        get_large_array()[6] + get_large_array()[7] + get_large_array()[8] +
        get_large_array()[9];
    
    println("Array sum: %d", array_sum);
    
    // 深い関数ネスト（呼び出しスタック効率性）
    int nested_result = mega_calc(
        mega_calc(v1, v2, v3, v4, v5),
        mega_calc(v6, v7, v8, v9, v10),
        mega_calc(v11, v12, v13, v14, v15),
        mega_calc(v16, v17, v18, v19, v20),
        mega_calc(v1 + v2, v3 + v4, v5 + v6, v7 + v8, v9 + v10)
    );
    
    println("Nested function result: %d", nested_result);
    
    // 複雑な三項演算子チェーン（右結合性の大規模テスト）
    int complex_ternary = 
        v1 > v2 ? 
            (v3 > v4 ? 
                (v5 > v6 ? v7 : v8) : 
                (v9 > v10 ? v11 : v12)) :
            (v13 > v14 ? 
                (v15 > v16 ? v17 : v18) :
                (v19 > v20 ? v1 + v2 : v3 + v4));
    
    println("Complex ternary: %d", complex_ternary);
    
    // 動的配列インデックス計算（式評価の複雑性）
    int dynamic_idx = (v1 + v2 + v3) % 10;
    int dynamic_result = get_large_array()[dynamic_idx];
    println("Dynamic indexing: array[%d] = %d", dynamic_idx, dynamic_result);
    
    // 複合代入の大規模チェーン
    int compound_test = 100;
    compound_test += v1 * v2;
    compound_test -= v3 + v4;
    compound_test *= v5;
    compound_test /= v6;
    compound_test %= v7;
    compound_test <<= 1;
    compound_test >>= 1;
    compound_test &= 255;
    compound_test |= v8;
    compound_test ^= v9;
    
    println("Compound chain result: %d", compound_test);
    
    // 論理演算の短絡評価（効率性確認）
    bool short_circuit = 
        (v1 < v2 && v3 < v4 && v5 < v6) ||
        (v7 > v8 && v9 > v10 && v11 > v12) ||
        (v13 == v14 && v15 != v16 && v17 <= v18) ||
        (v19 >= v20 && v1 != 0 && v2 != 0);
    
    println("Short circuit result: %d", short_circuit ? 1 : 0);
    
    // 最終的な超複雑式（全機能統合）
    int ultimate_test = 
        (mega_calc(v1, v2, v3, v4, v5) + get_large_array()[v6 % 10]) *
        (v7 > v8 ? 
            mega_calc(v9, v10, v11, v12, v13) : 
            get_large_array()[v14 % 10]) +
        ((compound_test & 255) | (nested_result ^ 15)) +
        (short_circuit ? huge_calc : array_sum);
    
    println("Ultimate expression: %d", ultimate_test);
    
    println("=== Test completed successfully ===");
    return 0;
}
