// const T* const の完全不変性保証テスト
// Rustの Pin<&T> 相当の不変性を検証
// 値もポインタも変更不可であることを保証

// Test 6 用の構造体
struct Point {
    int x;
    int y;
};

int main() {
    println("=== Const * Const Comprehensive Immutability Test ===");
    println("");
    
    // Test 1: 基本的な const T* const（値もポインタも変更不可）
    println("Test 1: Basic const T* const - No value or pointer modification");
    int x = 100;
    const int* const ptr1 = &x;
    
    println("Initial: *ptr1 = %d", *ptr1);
    assert(*ptr1 == 100);
    
    // 元の変数は変更可能
    x = 200;
    println("After x = 200: *ptr1 = %d", *ptr1);
    assert(*ptr1 == 200);
    
    // エラーケース（コメントアウト）:
    // *ptr1 = 300;  // Error: 値を変更できない
    // ptr1 = &x;    // Error: ポインタを再代入できない
    println("✓ Test 1 passed");
    println("");
    
    // Test 2: 配列要素への const * const
    println("Test 2: const T* const to array element");
    int[5] arr = [1, 2, 3, 4, 5];
    const int* const ptr2 = &arr[2];
    
    println("Initial: *ptr2 = %d (arr[2])", *ptr2);
    assert(*ptr2 == 3);
    
    // 配列自体は変更可能
    arr[2] = 30;
    println("After arr[2] = 30: *ptr2 = %d", *ptr2);
    assert(*ptr2 == 30);
    
    // エラーケース:
    // *ptr2 = 300;      // Error: 値を変更できない
    // ptr2 = &arr[3];   // Error: ポインタを再代入できない
    // ptr2++;           // Error: ポインタ演算不可
    println("✓ Test 2 passed");
    println("");
    
    // Test 3: const T* をconst T* constにコピー
    println("Test 3: Copy const T* to const T* const");
    int value = 42;
    const int* tempPtr = &value;
    const int* const ptr3 = tempPtr;  // const T* から const T* const へ
    
    println("Initial: *ptr3 = %d", *ptr3);
    assert(*ptr3 == 42);
    
    value = 84;
    println("After value = 84: *ptr3 = %d", *ptr3);
    assert(*ptr3 == 84);
    
    // エラーケース:
    // *ptr3 = 100;      // Error: 値を変更できない
    // ptr3 = &value;    // Error: ポインタを再代入できない
    println("✓ Test 3 passed");
    println("");
    
    // Test 4: 複数の const * const ポインタ（swap不可）
    println("Test 4: Multiple const T* const - No swap allowed");
    int a = 10, b = 20;
    const int* const ptrA = &a;
    const int* const ptrB = &b;
    
    println("Initial: *ptrA = %d, *ptrB = %d", *ptrA, *ptrB);
    assert(*ptrA == 10);
    assert(*ptrB == 20);
    
    // 元の変数は変更可能
    a = 100;
    b = 200;
    println("After a=100, b=200: *ptrA = %d, *ptrB = %d", *ptrA, *ptrB);
    assert(*ptrA == 100);
    assert(*ptrB == 200);
    
    // エラーケース（swap不可）:
    // const int* const temp = ptrA;  // これ自体はOK（新しいconst*constを作成）
    // ptrA = ptrB;                   // Error: ptrAを再代入できない
    // ptrB = temp;                   // Error: ptrBを再代入できない
    
    // ポインタ経由の値変更も不可:
    // *ptrA = 999;  // Error: 値を変更できない
    // *ptrB = 888;  // Error: 値を変更できない
    println("✓ Test 4 passed - Pointers cannot be swapped");
    println("");
    
    // Test 5: 複数の const * const（配列風アクセス）
    println("Test 5: Multiple const T* const pointers (simulating array)");
    int[3] values = [111, 222, 333];
    const int* const ptr5_0 = &values[0];
    const int* const ptr5_1 = &values[1];
    const int* const ptr5_2 = &values[2];
    
    println("Pointer values:");
    println("  *ptr5_0 = %d", *ptr5_0);
    println("  *ptr5_1 = %d", *ptr5_1);
    println("  *ptr5_2 = %d", *ptr5_2);
    
    // エラーケース:
    // *ptr5_0 = 999;           // Error: 値を変更できない
    // ptr5_0 = &values[1];     // Error: ポインタを再代入できない
    println("✓ Test 5 passed");
    println("");
    
    // Test 6: ネストした構造体への const * const
    println("Test 6: const T* const to nested struct member");
    Point p = {x: 10, y: 20};
    const int* const ptrX = &p.x;
    
    println("Initial: p.x = %d, *ptrX = %d", p.x, *ptrX);
    assert(*ptrX == 10);
    
    // 構造体メンバは直接変更可能
    p.x = 50;
    println("After p.x = 50: *ptrX = %d", *ptrX);
    assert(*ptrX == 50);
    
    // エラーケース:
    // *ptrX = 100;      // Error: const経由では変更不可
    // ptrX = &p.y;      // Error: ポインタ再代入不可
    println("✓ Test 6 passed");
    println("");
    
    // Test 7: double const * const（多重ポインタのconst）
    println("Test 7: const T** const - Pointer to const pointer (itself const)");
    int z = 77;
    const int* innerPtr = &z;
    const int** const outerPtr = &innerPtr;
    
    println("Initial: **outerPtr = %d", **outerPtr);
    assert(**outerPtr == 77);
    
    // 元の変数は変更可能
    z = 88;
    println("After z = 88: **outerPtr = %d", **outerPtr);
    assert(**outerPtr == 88);
    
    // エラーケース:
    // **outerPtr = 99;          // Error: 値を変更できない
    // outerPtr = &innerPtr;     // Error: outerPtr自体を再代入不可
    // *outerPtr = &z;           // Error: innerPtrを変更しようとする（constなので不可）
    println("✓ Test 7 passed");
    println("");
    
    println("=== All Immutability Tests PASSED ===");
    println("Rust Pin<&T> equivalent immutability guaranteed!");
    return 0;
}
