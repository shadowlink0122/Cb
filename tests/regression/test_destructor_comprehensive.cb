// Comprehensive Destructor Test
// Tests destructor functionality with various scenarios
// v0.13.1: Destructor with struct_members_ref and TypeContext

import stdlib.collections.queue;
import stdlib.collections.vector;

int test_count = 0;
int pass_count = 0;

void assert_true(bool condition, string message) {
    test_count = test_count + 1;
    if (condition) {
        print("âœ… Test ");
        print(test_count);
        print(": ");
        print(message);
        print("\n");
        pass_count = pass_count + 1;
    } else {
        print("âŒ Test ");
        print(test_count);
        print(": ");
        print(message);
        print(" FAILED\n");
    }
}

void print_summary() {
    print("\n");
    print("========================================\n");
    print("Test Summary: ");
    print(pass_count);
    print("/");
    print(test_count);
    print(" tests passed\n");
    print("========================================\n");
}

int main() {
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    print("â•‘  Comprehensive Destructor Test Suite                        â•‘\n");
    print("â•‘  v0.13.1: TypeContext + struct_members_ref                   â•‘\n");
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Test 1: Single element Queue destructor
    {
        print("=== Test 1: Single Element Queue<int> ===\n");
        Queue<int> q;
        q.enqueue(42);
        int val = q.dequeue();
        assert_true(val == 42, "Single element enqueue/dequeue works");
        // Destructor called here - should not crash
    }
    assert_true(true, "Single element destructor completed");
    
    // Test 2: Multiple elements Queue destructor
    {
        print("\n=== Test 2: Multiple Elements Queue<int> ===\n");
        Queue<int> q;
        q.enqueue(10);
        q.enqueue(20);
        q.enqueue(30);
        assert_true(q.size() == 3, "Three elements enqueued");
        // Destructor called here - should free all 3 nodes
    }
    assert_true(true, "Multiple elements destructor completed");
    
    // Test 3: Queue<long> with different type
    {
        print("\n=== Test 3: Queue<long> Different Type ===\n");
        Queue<long> q;
        q.enqueue(1000000000);
        q.enqueue(2000000000);
        long val = q.dequeue();
        assert_true(val == 1000000000, "Long value enqueue/dequeue works");
        // Destructor called here - sizeof(T) should be 8 for long
    }
    assert_true(true, "Queue<long> destructor completed");
    
    // Test 4: Nested scopes with destructors
    {
        print("\n=== Test 4: Nested Scopes ===\n");
        Queue<int> outer;
        outer.enqueue(1);
        {
            Queue<int> inner;
            inner.enqueue(2);
            inner.enqueue(3);
            assert_true(inner.size() == 2, "Inner queue has 2 elements");
            // inner destructor called here
        }
        assert_true(outer.size() == 1, "Outer queue still has 1 element");
        // outer destructor called here
    }
    assert_true(true, "Nested scopes destructors completed");
    
    // Test 5: Queue in loop (multiple destructor calls)
    {
        print("\n=== Test 5: Queue in Loop ===\n");
        int iterations = 0;
        for (int i = 0; i < 3; i = i + 1) {
            Queue<int> temp;
            temp.enqueue(i * 10);
            temp.enqueue(i * 10 + 1);
            iterations = iterations + 1;
            // temp destructor called at end of each iteration
        }
        assert_true(iterations == 3, "Loop completed 3 iterations");
    }
    assert_true(true, "Multiple destructor calls in loop completed");
    
    // Test 6: Vector destructor (different container)
    {
        print("\n=== Test 6: Vector<int> Destructor ===\n");
        Vector<int> v;
        v.init(2);
        v.push(100);
        v.push(200);
        v.push(300);
        assert_true(v.get_length() == 3, "Vector has 3 elements");
        int popped = v.pop();
        assert_true(popped == 300, "Pop returns last element");
        // Vector destructor called here
    }
    assert_true(true, "Vector destructor completed");
    
    // Test 7: Empty Queue destructor (edge case)
    {
        print("\n=== Test 7: Empty Queue Destructor ===\n");
        Queue<int> q;
        assert_true(q.empty(), "Queue is empty");
        // Destructor with null front pointer - should handle gracefully
    }
    assert_true(true, "Empty queue destructor completed");
    
    // Test 8: Queue with single dequeue then destructor
    {
        print("\n=== Test 8: Partial Dequeue then Destructor ===\n");
        Queue<int> q;
        q.enqueue(1);
        q.enqueue(2);
        q.enqueue(3);
        int val = q.dequeue();
        assert_true(val == 1, "First dequeue returns 1");
        assert_true(q.size() == 2, "Queue has 2 remaining elements");
        // Destructor should free remaining 2 nodes
    }
    assert_true(true, "Partial dequeue destructor completed");
    
    // Test 9: Complex scenario - mixed operations
    {
        print("\n=== Test 9: Complex Mixed Operations ===\n");
        Queue<int> q1;
        Queue<int> q2;
        Vector<int> v1;
        v1.init(2);
        
        q1.enqueue(10);
        q2.enqueue(20);
        v1.push(30);
        
        int sum = q1.peek() + q2.peek() + v1.get(0);
        assert_true(sum == 60, "Mixed operations result correct");
        
        // All three destructors called here
    }
    assert_true(true, "Complex scenario destructors completed");
    
    // Test 10: Stress test - many elements
    {
        print("\n=== Test 10: Stress Test (100 elements) ===\n");
        Queue<int> q;
        for (int i = 0; i < 100; i = i + 1) {
            q.enqueue(i);
        }
        assert_true(q.size() == 100, "Queue has 100 elements");
        // Dequeue half
        for (int i = 0; i < 50; i = i + 1) {
            q.dequeue();
        }
        assert_true(q.size() == 50, "Queue has 50 remaining elements");
        // Destructor should free remaining 50 nodes
    }
    assert_true(true, "Stress test destructor completed");
    
    print_summary();
    
    if (pass_count == test_count) {
        print("\nğŸ‰ All destructor tests passed! Memory management working correctly.\n");
        return 0;
    } else {
        print("\nâš ï¸  Some tests failed. Please review.\n");
        return 1;
    }
}
