// v0.14.0: HIR to C++ Transpiler Implementation
// HIRからC++コードを生成するバックエンド

#include "hir_to_cpp.h"
#include <iostream>

namespace cb {
namespace codegen {

using namespace ir::hir;

HIRToCpp::HIRToCpp() {}

HIRToCpp::~HIRToCpp() {}

// メインの生成関数
std::string HIRToCpp::generate(const HIRProgram &program) {
    output.str("");
    output.clear();
    indent_level = 0;

    // ヘッダーコメント
    emit_line("// Generated by Cb Compiler v0.14.0");
    emit_line("// HIR → C++ Transpiler");
    emit_line("");

    // 必要なインクルード
    emit_line("#include <iostream>");
    emit_line("#include <string>");
    emit_line("#include <memory>");
    emit_line("#include <vector>");
    emit_line("#include <functional>");
    emit_line("#include <cmath>     // For FFI math functions");
    emit_line("#include <cstdlib>   // For FFI C functions");
    emit_line("#include <cassert>   // For assert statements");
    emit_line("");

    // 標準ライブラリのエイリアス
    emit_line("// Cb standard types");
    emit_line("using string = std::string;");
    emit_line("template<typename T> using vector = std::vector<T>;");
    emit_line("");

    // 組み込み関数のマクロ定義
    emit_line("// Cb built-in functions");
    emit_line("#define println(...) cb_println(__VA_ARGS__)");
    emit_line("#define print(...) cb_print(__VA_ARGS__)");
    emit_line("");

    // 組み込み関数の実装
    emit_line("// Built-in function implementations");
    emit_line("template<typename... Args>");
    emit_line("void cb_println(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("    std::cout << std::endl;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename... Args>");
    emit_line("void cb_print(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("}");
    emit_line("");

    // インポート処理
    generate_imports(program);

    // Typedef
    generate_typedefs(program.typedefs);

    // FFI関数宣言
    generate_foreign_functions(program.foreign_functions);

    // 前方宣言
    generate_forward_declarations(program);

    // Enum定義
    generate_enums(program.enums);

    // 構造体定義
    generate_structs(program.structs);

    // インターフェース定義（抽象クラスとして）
    generate_interfaces(program.interfaces);

    // グローバル変数
    generate_global_vars(program.global_vars);

    // 関数定義
    generate_functions(program.functions);

    // Impl定義（メソッド実装）
    generate_impls(program.impls);

    return output.str();
}

// === ヘルパーメソッド ===

void HIRToCpp::emit(const std::string &code) { output << code; }

void HIRToCpp::emit_line(const std::string &code) {
    emit_indent();
    output << code << "\n";
}

void HIRToCpp::emit_indent() {
    for (int i = 0; i < indent_level; i++) {
        output << "    ";
    }
}

void HIRToCpp::increase_indent() { indent_level++; }

void HIRToCpp::decrease_indent() {
    if (indent_level > 0) {
        indent_level--;
    }
}

// v0.14.0: HIR変数名にプレフィックスを追加して名前衝突を防ぐ
std::string HIRToCpp::add_hir_prefix(const std::string &name) {
    // 既にプレフィックスが付いている場合はそのまま返す
    if (name.find("CB_HIR_") == 0) {
        return name;
    }
    // main関数は特別扱い
    if (name == "main") {
        return name;
    }
    // 修飾名(::を含む)はそのまま返す
    if (name.find("::") != std::string::npos) {
        return name;
    }
    // 組み込み関数やC++標準ライブラリの関数はプレフィックスを付けない
    if (name == "println" || name == "print" || name == "std" ||
        name == "assert" || name == "sizeof") {
        return name;
    }
    return "CB_HIR_" + name;
}

// === トップレベル定義の生成 ===

void HIRToCpp::generate_imports(const HIRProgram &program) {
    if (program.imports.empty()) {
        return;
    }

    emit_line("// Imports");
    for (const auto &import : program.imports) {
        emit_line("// import " + import.module_path);
    }
    emit_line("");
}

void HIRToCpp::generate_typedefs(const std::vector<HIRTypedef> &typedefs) {
    if (typedefs.empty()) {
        return;
    }

    emit_line("// Type aliases");
    for (const auto &typedef_def : typedefs) {
        emit("using " + typedef_def.name + " = ");
        emit(generate_type(typedef_def.target_type));
        emit(";\n");
    }
    emit_line("");
}

void HIRToCpp::generate_foreign_functions(
    const std::vector<HIRForeignFunction> &foreign_funcs) {
    if (foreign_funcs.empty()) {
        return;
    }

    emit_line("// FFI (Foreign Function Interface) declarations");
    emit_line("extern \"C\" {");
    increase_indent();

    for (const auto &ffi : foreign_funcs) {
        emit_indent();
        emit(generate_type(ffi.return_type));
        emit(" " + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = ffi.parameters[i];
            emit(generate_type(param.type));
            if (!param.name.empty()) {
                emit(" " + param.name);
            }
        }

        emit(");\n");
    }

    decrease_indent();
    emit_line("}");
    emit_line("");

    // FFI関数のラッパー生成（モジュール修飾名対応）
    emit_line("// FFI wrapper functions (for qualified calls)");
    for (const auto &ffi : foreign_funcs) {
        emit_indent();
        emit("inline ");
        emit(generate_type(ffi.return_type));
        emit(" " + ffi.module_name + "_" + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = ffi.parameters[i];
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        emit(") { return " + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            emit(ffi.parameters[i].name);
        }

        emit("); }\n");
    }
    emit_line("");
}

void HIRToCpp::generate_forward_declarations(const HIRProgram &program) {
    if (program.structs.empty() && program.interfaces.empty()) {
        return;
    }

    emit_line("// Forward declarations");

    for (const auto &struct_def : program.structs) {
        emit_line("struct " + struct_def.name + ";");
    }

    for (const auto &interface : program.interfaces) {
        emit_line("class " + interface.name + ";");
    }

    emit_line("");
}

void HIRToCpp::generate_structs(const std::vector<HIRStruct> &structs) {
    for (const auto &struct_def : structs) {
        generate_struct(struct_def);
    }
}

void HIRToCpp::generate_enums(const std::vector<HIREnum> &enums) {
    for (const auto &enum_def : enums) {
        generate_enum(enum_def);
    }
}

void HIRToCpp::generate_interfaces(
    const std::vector<HIRInterface> &interfaces) {
    for (const auto &interface : interfaces) {
        emit_line("// Interface: " + interface.name);
        emit_line("class " + interface.name + " {");
        emit_line("public:");
        increase_indent();

        emit_line("virtual ~" + interface.name + "() = default;");
        emit_line("");

        for (const auto &method : interface.methods) {
            emit("virtual ");
            emit(generate_type(method.return_type));
            emit(" " + method.name + "(");

            for (size_t i = 0; i < method.parameters.size(); i++) {
                if (i > 0)
                    emit(", ");
                const auto &param = method.parameters[i];
                if (param.is_const)
                    emit("const ");
                emit(generate_type(param.type));
                emit(" " + param.name);
            }

            emit(") = 0;\n");
        }

        decrease_indent();
        emit_line("};");
        emit_line("");
    }
}

void HIRToCpp::generate_global_vars(const std::vector<HIRGlobalVar> &globals) {
    if (globals.empty()) {
        return;
    }

    emit_line("// Global variables");
    for (const auto &global : globals) {
        if (global.is_const)
            emit("const ");
        emit(generate_type(global.type));
        emit(" " + add_hir_prefix(global.name));

        if (global.init_expr) {
            emit(" = ");
            emit(generate_expr(*global.init_expr));
        }

        emit(";\n");
    }
    emit_line("");
}

void HIRToCpp::generate_functions(const std::vector<HIRFunction> &functions) {
    for (const auto &func : functions) {
        generate_function(func);
    }
}

void HIRToCpp::generate_impls(const std::vector<HIRImpl> &impls) {
    for (const auto &impl : impls) {
        generate_impl(impl);
    }
}

// === 個別の定義生成 ===

void HIRToCpp::generate_struct(const HIRStruct &struct_def) {
    emit_line("// Struct: " + struct_def.name);

    // ジェネリック対応
    if (!struct_def.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < struct_def.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + struct_def.generic_params[i]);
        }
        emit(">\n");
    }

    emit_line("struct " + struct_def.name + " {");

    // フィールド
    if (!struct_def.fields.empty()) {
        for (const auto &field : struct_def.fields) {
            emit_indent();
            if (field.is_private) {
                // TODO: privateフィールドのサポート
            }
            emit(generate_type(field.type));
            emit(" " + field.name + ";\n");
        }
    }

    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_enum(const HIREnum &enum_def) {
    emit_line("// Enum: " + enum_def.name);
    emit_line("enum class " + enum_def.name + " {");
    increase_indent();

    for (size_t i = 0; i < enum_def.variants.size(); i++) {
        const auto &variant = enum_def.variants[i];
        emit_indent();
        emit(variant.name);
        emit(" = " + std::to_string(variant.value));
        if (i < enum_def.variants.size() - 1) {
            emit(",");
        }
        emit("\n");
    }

    decrease_indent();
    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_function(const HIRFunction &func) {
    emit_line("// Function: " + func.name);

    // ジェネリック対応
    if (!func.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < func.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + func.generic_params[i]);
        }
        emit(">\n");
    }

    // async関数は将来実装
    if (func.is_async) {
        emit_line("// TODO: async function");
    }

    // 戻り値の型
    emit_indent();
    emit(generate_type(func.return_type));
    emit(" " + add_hir_prefix(func.name) + "(");

    // パラメータ
    for (size_t i = 0; i < func.parameters.size(); i++) {
        if (i > 0)
            emit(", ");
        const auto &param = func.parameters[i];
        if (param.is_const)
            emit("const ");
        emit(generate_type(param.type));
        emit(" " + add_hir_prefix(param.name));
    }

    emit(") {\n");

    // 関数本体
    if (func.body) {
        increase_indent();
        generate_stmt(*func.body);
        decrease_indent();
    }

    emit_line("}");
    emit_line("");
}

void HIRToCpp::generate_impl(const HIRImpl &impl) {
    emit_line("// Impl for: " + impl.struct_name);

    if (!impl.interface_name.empty()) {
        emit_line("// implements: " + impl.interface_name);
    }

    // メソッドを生成（メソッド名にstruct名をプレフィックス）
    for (const auto &method : impl.methods) {
        emit_line("// Method: " + method.name);

        // ジェネリック対応
        if (!method.generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < method.generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + method.generic_params[i]);
            }
            emit(">\n");
        }

        // 戻り値の型
        emit_indent();
        emit(generate_type(method.return_type));
        emit(" " + impl.struct_name + "::" + method.name + "(");

        // パラメータ
        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        emit(") {\n");

        // 関数本体
        if (method.body) {
            increase_indent();
            generate_stmt(*method.body);
            decrease_indent();
        }

        emit_line("}");
        emit_line("");
    }
}

// === 文の生成 ===

void HIRToCpp::generate_stmt(const HIRStmt &stmt) {
    switch (stmt.kind) {
    case HIRStmt::StmtKind::VarDecl:
        generate_var_decl(stmt);
        break;
    case HIRStmt::StmtKind::Assignment:
        generate_assignment(stmt);
        break;
    case HIRStmt::StmtKind::ExprStmt:
        emit_indent();
        emit(generate_expr(*stmt.expr));
        emit(";\n");
        break;
    case HIRStmt::StmtKind::If:
        generate_if(stmt);
        break;
    case HIRStmt::StmtKind::While:
        generate_while(stmt);
        break;
    case HIRStmt::StmtKind::For:
        generate_for(stmt);
        break;
    case HIRStmt::StmtKind::Return:
        generate_return(stmt);
        break;
    case HIRStmt::StmtKind::Break:
        emit_line("break;");
        break;
    case HIRStmt::StmtKind::Continue:
        emit_line("continue;");
        break;
    case HIRStmt::StmtKind::Block:
        generate_block(stmt);
        break;
    case HIRStmt::StmtKind::Switch:
        generate_switch(stmt);
        break;
    case HIRStmt::StmtKind::Defer:
        generate_defer(stmt);
        break;
    case HIRStmt::StmtKind::Delete:
        generate_delete(stmt);
        break;
    case HIRStmt::StmtKind::Try:
        generate_try_catch(stmt);
        break;
    case HIRStmt::StmtKind::Throw:
        emit_indent();
        emit("throw ");
        if (stmt.throw_expr) {
            emit(generate_expr(*stmt.throw_expr));
        }
        emit(";\n");
        break;
    case HIRStmt::StmtKind::Assert:
        generate_assert(stmt);
        break;
    default:
        emit_line("// TODO: Unsupported statement");
        break;
    }
}

void HIRToCpp::generate_var_decl(const HIRStmt &stmt) {
    emit_indent();
    if (stmt.is_const) {
        emit("const ");
    }
    emit(generate_type(stmt.var_type));
    emit(" " + add_hir_prefix(stmt.var_name));

    if (stmt.init_expr) {
        emit(" = ");
        emit(generate_expr(*stmt.init_expr));
    }

    emit(";\n");
}

void HIRToCpp::generate_assignment(const HIRStmt &stmt) {
    emit_indent();
    emit(generate_expr(*stmt.lhs));
    emit(" = ");
    emit(generate_expr(*stmt.rhs));
    emit(";\n");
}

void HIRToCpp::generate_if(const HIRStmt &stmt) {
    emit_indent();
    emit("if (");
    emit(generate_expr(*stmt.condition));
    emit(") {\n");

    increase_indent();
    if (stmt.then_body) {
        generate_stmt(*stmt.then_body);
    }
    decrease_indent();

    if (stmt.else_body) {
        emit_line("} else {");
        increase_indent();
        generate_stmt(*stmt.else_body);
        decrease_indent();
    }

    emit_line("}");
}

void HIRToCpp::generate_while(const HIRStmt &stmt) {
    emit_indent();
    emit("while (");
    emit(generate_expr(*stmt.condition));
    emit(") {\n");

    increase_indent();
    if (stmt.body) {
        generate_stmt(*stmt.body);
    }
    decrease_indent();

    emit_line("}");
}

void HIRToCpp::generate_for(const HIRStmt &stmt) {
    emit_indent();
    emit("for (");

    // init
    if (stmt.init) {
        // セミコロンなしで生成
        if (stmt.init->kind == HIRStmt::StmtKind::VarDecl) {
            if (stmt.init->is_const)
                emit("const ");
            emit(generate_type(stmt.init->var_type));
            emit(" " + add_hir_prefix(stmt.init->var_name));
            if (stmt.init->init_expr) {
                emit(" = ");
                emit(generate_expr(*stmt.init->init_expr));
            }
        } else if (stmt.init->kind == HIRStmt::StmtKind::Assignment) {
            if (stmt.init->lhs && stmt.init->rhs) {
                emit(generate_expr(*stmt.init->lhs));
                emit(" = ");
                emit(generate_expr(*stmt.init->rhs));
            }
        } else if (stmt.init->kind == HIRStmt::StmtKind::ExprStmt) {
            if (stmt.init->expr) {
                emit(generate_expr(*stmt.init->expr));
            }
        }
    }
    emit("; ");

    // condition
    if (stmt.condition) {
        emit(generate_expr(*stmt.condition));
    }
    emit("; ");

    // update
    if (stmt.update) {
        if (stmt.update->kind == HIRStmt::StmtKind::Assignment) {
            if (stmt.update->lhs && stmt.update->rhs) {
                emit(generate_expr(*stmt.update->lhs));
                emit(" = ");
                emit(generate_expr(*stmt.update->rhs));
            }
        } else if (stmt.update->kind == HIRStmt::StmtKind::ExprStmt) {
            if (stmt.update->expr) {
                emit(generate_expr(*stmt.update->expr));
            }
        }
    }

    emit(") {\n");

    increase_indent();
    if (stmt.body) {
        generate_stmt(*stmt.body);
    }
    decrease_indent();

    emit_line("}");
}

void HIRToCpp::generate_return(const HIRStmt &stmt) {
    emit_indent();
    emit("return");

    if (stmt.return_expr) {
        emit(" ");
        emit(generate_expr(*stmt.return_expr));
    }

    emit(";\n");
}

void HIRToCpp::generate_block(const HIRStmt &stmt) {
    // デバッグ: ブロック内の文の種類を確認
    if (stmt.block_stmts.empty()) {
        // 空のブロックの場合は何も出力しない（ただし、デバッグのためコメントを残す）
        emit_line("// Empty block");
        return;
    }

    // 変数宣言のみのブロックの場合、中括弧を省略して直接展開
    bool all_var_decls = !stmt.block_stmts.empty();
    for (const auto &s : stmt.block_stmts) {
        if (s.kind != HIRStmt::StmtKind::VarDecl) {
            all_var_decls = false;
            break;
        }
    }

    if (all_var_decls) {
        // 変数宣言のみなので、中括弧なしで直接出力
        for (const auto &s : stmt.block_stmts) {
            generate_stmt(s);
        }
    } else {
        // 通常のブロック
        emit_line("{");
        increase_indent();

        for (const auto &s : stmt.block_stmts) {
            generate_stmt(s);
        }

        decrease_indent();
        emit_line("}");
    }
}

void HIRToCpp::generate_switch(const HIRStmt &stmt) {
    emit_indent();
    emit("switch (");
    emit(generate_expr(*stmt.switch_expr));
    emit(") {\n");

    increase_indent();

    for (const auto &case_item : stmt.switch_cases) {
        if (case_item.case_value) {
            emit_indent();
            emit("case ");
            emit(generate_expr(*case_item.case_value));
            emit(":\n");
        } else {
            emit_line("default:");
        }

        increase_indent();
        for (const auto &case_stmt : case_item.case_body) {
            generate_stmt(case_stmt);
        }
        emit_line("break;");
        decrease_indent();
    }

    decrease_indent();
    emit_line("}");
}

void HIRToCpp::generate_defer(const HIRStmt &stmt) {
    // C++でdeferを実装するにはRAIIラッパーが必要
    emit_line("// TODO: defer statement");
    if (stmt.defer_stmt) {
        generate_stmt(*stmt.defer_stmt);
    }
}

void HIRToCpp::generate_delete(const HIRStmt &stmt) {
    emit_indent();
    emit("delete ");
    emit(generate_expr(*stmt.delete_expr));
    emit(";\n");
}

void HIRToCpp::generate_try_catch(const HIRStmt &stmt) {
    emit_line("try {");
    increase_indent();

    for (const auto &s : stmt.try_block) {
        generate_stmt(s);
    }

    decrease_indent();
    emit_line("}");

    for (const auto &catch_clause : stmt.catch_clauses) {
        emit_indent();
        emit("catch (");
        emit(generate_type(catch_clause.exception_type));
        emit(" " + catch_clause.exception_var + ") {\n");

        increase_indent();
        for (const auto &s : catch_clause.catch_body) {
            generate_stmt(s);
        }
        decrease_indent();

        emit_line("}");
    }

    if (!stmt.finally_block.empty()) {
        emit_line("// finally block (executed via RAII)");
        for (const auto &s : stmt.finally_block) {
            generate_stmt(s);
        }
    }
}

// === 式の生成 ===

std::string HIRToCpp::generate_expr(const HIRExpr &expr) {
    switch (expr.kind) {
    case HIRExpr::ExprKind::Literal:
        return generate_literal(expr);
    case HIRExpr::ExprKind::Variable:
        return generate_variable(expr);
    case HIRExpr::ExprKind::BinaryOp:
        return generate_binary_op(expr);
    case HIRExpr::ExprKind::UnaryOp:
        return generate_unary_op(expr);
    case HIRExpr::ExprKind::FunctionCall:
        return generate_function_call(expr);
    case HIRExpr::ExprKind::MethodCall:
        return generate_method_call(expr);
    case HIRExpr::ExprKind::MemberAccess:
        return generate_member_access(expr);
    case HIRExpr::ExprKind::ArrayAccess:
        return generate_array_access(expr);
    case HIRExpr::ExprKind::Cast:
        return generate_cast(expr);
    case HIRExpr::ExprKind::Ternary:
        return generate_ternary(expr);
    case HIRExpr::ExprKind::Lambda:
        return generate_lambda(expr);
    case HIRExpr::ExprKind::StructLiteral:
        return generate_struct_literal(expr);
    case HIRExpr::ExprKind::ArrayLiteral:
        return generate_array_literal(expr);
    case HIRExpr::ExprKind::AddressOf:
        return generate_address_of(expr);
    case HIRExpr::ExprKind::Dereference:
        return generate_dereference(expr);
    case HIRExpr::ExprKind::SizeOf:
        return generate_sizeof(expr);
    case HIRExpr::ExprKind::New:
        return generate_new(expr);
    case HIRExpr::ExprKind::Await:
        return generate_await(expr);
    case HIRExpr::ExprKind::PreIncDec:
        return generate_pre_incdec(expr);
    case HIRExpr::ExprKind::PostIncDec:
        return generate_post_incdec(expr);
    default:
        return "/* unsupported expr */";
    }
}

std::string HIRToCpp::generate_literal(const HIRExpr &expr) {
    // 文字列リテラルはエスケープ処理
    if (expr.literal_type.kind == HIRType::TypeKind::String) {
        return "\"" + escape_string(expr.literal_value) + "\"";
    }
    return expr.literal_value;
}

std::string HIRToCpp::generate_variable(const HIRExpr &expr) {
    return add_hir_prefix(expr.var_name);
}

std::string HIRToCpp::generate_binary_op(const HIRExpr &expr) {
    std::string result = "(";
    result += generate_expr(*expr.left);
    result += " " + expr.op + " ";
    result += generate_expr(*expr.right);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_unary_op(const HIRExpr &expr) {
    std::string result = "(";
    result += expr.op;
    result += generate_expr(*expr.operand);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_function_call(const HIRExpr &expr) {
    std::string result = add_hir_prefix(expr.func_name) + "(";

    for (size_t i = 0; i < expr.arguments.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.arguments[i]);
    }

    result += ")";
    return result;
}

std::string HIRToCpp::generate_method_call(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.receiver);
    result += "." + expr.method_name + "(";

    for (size_t i = 0; i < expr.arguments.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.arguments[i]);
    }

    result += ")";
    return result;
}

std::string HIRToCpp::generate_member_access(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.object);
    result += expr.is_arrow ? "->" : ".";
    result += expr.member_name;
    return result;
}

std::string HIRToCpp::generate_array_access(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.array);
    result += "[";
    result += generate_expr(*expr.index);
    result += "]";
    return result;
}

std::string HIRToCpp::generate_cast(const HIRExpr &expr) {
    std::string result = "static_cast<";
    result += generate_type(expr.cast_type);
    result += ">(";
    result += generate_expr(*expr.cast_expr);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_ternary(const HIRExpr &expr) {
    std::string result = "(";
    result += generate_expr(*expr.condition);
    result += " ? ";
    result += generate_expr(*expr.then_expr);
    result += " : ";
    result += generate_expr(*expr.else_expr);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_lambda(const HIRExpr &expr) {
    std::string result = "[](";

    // パラメータ
    for (size_t i = 0; i < expr.lambda_params.size(); i++) {
        if (i > 0)
            result += ", ";
        const auto &param = expr.lambda_params[i];
        if (param.is_const)
            result += "const ";
        result += generate_type(param.type);
        result += " " + add_hir_prefix(param.name);
    }

    result += ") -> ";
    result += generate_type(expr.lambda_return_type);
    result += " { /* lambda body */ }";

    return result;
}

std::string HIRToCpp::generate_struct_literal(const HIRExpr &expr) {
    std::string result = expr.struct_type_name + "{";

    for (size_t i = 0; i < expr.field_values.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.field_values[i]);
    }

    result += "}";
    return result;
}

std::string HIRToCpp::generate_array_literal(const HIRExpr &expr) {
    std::string result = "{";

    for (size_t i = 0; i < expr.array_elements.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.array_elements[i]);
    }

    result += "}";
    return result;
}

std::string HIRToCpp::generate_address_of(const HIRExpr &expr) {
    return "&(" + generate_expr(*expr.operand) + ")";
}

std::string HIRToCpp::generate_dereference(const HIRExpr &expr) {
    return "*(" + generate_expr(*expr.operand) + ")";
}

std::string HIRToCpp::generate_sizeof(const HIRExpr &expr) {
    if (expr.sizeof_expr) {
        return "sizeof(" + generate_expr(*expr.sizeof_expr) + ")";
    } else {
        return "sizeof(" + generate_type(expr.sizeof_type) + ")";
    }
}

std::string HIRToCpp::generate_new(const HIRExpr &expr) {
    std::string result = "new " + generate_type(expr.new_type);

    if (!expr.new_args.empty()) {
        result += "(";
        for (size_t i = 0; i < expr.new_args.size(); i++) {
            if (i > 0)
                result += ", ";
            result += generate_expr(expr.new_args[i]);
        }
        result += ")";
    }

    return result;
}

std::string HIRToCpp::generate_await(const HIRExpr &expr) {
    // C++20 co_await
    return "co_await " + generate_expr(*expr.operand);
}

std::string HIRToCpp::generate_pre_incdec(const HIRExpr &expr) {
    return expr.op + generate_expr(*expr.operand);
}

std::string HIRToCpp::generate_post_incdec(const HIRExpr &expr) {
    return generate_expr(*expr.operand) + expr.op;
}

void HIRToCpp::generate_assert(const HIRStmt &stmt) {
    emit_indent();
    emit("assert(");
    if (stmt.assert_expr) {
        emit(generate_expr(*stmt.assert_expr));
    }
    emit(")");
    if (!stmt.assert_message.empty()) {
        emit(" /* " + stmt.assert_message + " */");
    }
    emit(";\n");
}

// === 型の生成 ===

std::string HIRToCpp::generate_type(const HIRType &type) {
    switch (type.kind) {
    case HIRType::TypeKind::Void:
        return "void";
    case HIRType::TypeKind::Tiny:
        return "int8_t";
    case HIRType::TypeKind::Short:
        return "int16_t";
    case HIRType::TypeKind::Int:
        return "int";
    case HIRType::TypeKind::Long:
        return "int64_t";
    case HIRType::TypeKind::Char:
        return "char";
    case HIRType::TypeKind::String:
        return "std::string";
    case HIRType::TypeKind::Bool:
        return "bool";
    case HIRType::TypeKind::Float:
        return "float";
    case HIRType::TypeKind::Double:
        return "double";
    case HIRType::TypeKind::Struct:
    case HIRType::TypeKind::Enum:
    case HIRType::TypeKind::Interface:
        return type.name;
    case HIRType::TypeKind::Pointer:
        return generate_pointer_type(type);
    case HIRType::TypeKind::Reference:
        return generate_reference_type(type);
    case HIRType::TypeKind::Array:
        return generate_array_type(type);
    case HIRType::TypeKind::Function:
        return generate_function_type(type);
    case HIRType::TypeKind::Generic:
        return type.name;
    case HIRType::TypeKind::Nullptr:
        return "std::nullptr_t";
    default:
        return "/* unknown type */";
    }
}

std::string HIRToCpp::generate_basic_type(const HIRType &type) {
    return generate_type(type);
}

std::string HIRToCpp::generate_pointer_type(const HIRType &type) {
    if (type.inner_type) {
        return generate_type(*type.inner_type) + "*";
    }
    return type.name + "*";
}

std::string HIRToCpp::generate_reference_type(const HIRType &type) {
    if (type.inner_type) {
        return generate_type(*type.inner_type) + "&";
    }
    return type.name + "&";
}

std::string HIRToCpp::generate_array_type(const HIRType &type) {
    if (type.inner_type) {
        if (type.array_size > 0) {
            // 固定長配列
            return "std::array<" + generate_type(*type.inner_type) + ", " +
                   std::to_string(type.array_size) + ">";
        } else {
            // 動的配列
            return "std::vector<" + generate_type(*type.inner_type) + ">";
        }
    }
    return "std::vector<int>"; // fallback
}

std::string HIRToCpp::generate_function_type(const HIRType &type) {
    std::string result = "std::function<";

    if (type.return_type) {
        result += generate_type(*type.return_type);
    } else {
        result += "void";
    }

    result += "(";
    for (size_t i = 0; i < type.param_types.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_type(type.param_types[i]);
    }
    result += ")>";

    return result;
}

// === ユーティリティ ===

std::string HIRToCpp::escape_string(const std::string &str) {
    std::string result;
    for (char c : str) {
        switch (c) {
        case '\n':
            result += "\\n";
            break;
        case '\t':
            result += "\\t";
            break;
        case '\r':
            result += "\\r";
            break;
        case '\\':
            result += "\\\\";
            break;
        case '"':
            result += "\\\"";
            break;
        default:
            result += c;
            break;
        }
    }
    return result;
}

std::string
HIRToCpp::mangle_generic_name(const std::string &base_name,
                              const std::vector<HIRType> &generic_args) {
    std::string result = base_name;
    if (!generic_args.empty()) {
        result += "_";
        for (const auto &arg : generic_args) {
            result += generate_type(arg);
        }
    }
    return result;
}

} // namespace codegen
} // namespace cb
