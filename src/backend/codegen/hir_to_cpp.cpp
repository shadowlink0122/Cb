// v0.14.0: HIR to C++ Transpiler Implementation
// HIRからC++コードを生成するバックエンド

#include "hir_to_cpp.h"
#include <algorithm>
#include <iostream>
#include <set>

namespace cb {
namespace codegen {

using namespace ir::hir;

HIRToCpp::HIRToCpp() {}

HIRToCpp::~HIRToCpp() {}

// メインの生成関数
std::string HIRToCpp::generate(const HIRProgram &program) {
    output.str("");
    output.clear();
    indent_level = 0;
    current_program = &program; // プログラム参照を保存

    // ヘッダーコメント
    emit_line("// Generated by Cb Compiler v0.14.0");
    emit_line("// HIR → C++ Transpiler");
    emit_line("");

    // 必要なインクルード
    emit_line("#include <iostream>");
    emit_line("#include <string>");
    emit_line("#include <memory>");
    emit_line("#include <vector>");
    emit_line("#include <functional>");
    emit_line("#include <variant>   // For union types");
    emit_line("#include <cmath>     // For FFI math functions");
    emit_line("#include <cstdlib>   // For FFI C functions");
    emit_line("#include <cassert>   // For assert statements");
    emit_line("");

    // 標準ライブラリのエイリアス
    emit_line("// Cb standard types");
    emit_line("using string = std::string;");
    emit_line("template<typename T> using vector = std::vector<T>;");
    emit_line("");

    // 組み込み関数のマクロ定義
    emit_line("// Cb built-in functions");
    emit_line("#define println(...) cb_println(__VA_ARGS__)");
    emit_line("#define print(...) cb_print(__VA_ARGS__)");
    emit_line("");

    // 組み込み関数の実装
    emit_line("// Built-in function implementations");
    emit_line("template<typename... Args>");
    emit_line("void cb_println(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("    std::cout << std::endl;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename... Args>");
    emit_line("void cb_print(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("}");
    emit_line("");

    // ヘルパー関数の宣言
    emit_line("// Helper functions for low-level operations");
    emit_line("template<typename T>");
    emit_line("void CB_HIR_array_set(void* ptr, int index, T value) {");
    emit_line("    ((T*)ptr)[index] = value;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename T>");
    emit_line("T CB_HIR_array_get(void* ptr, int index) {");
    emit_line("    return ((T*)ptr)[index];");
    emit_line("}");
    emit_line("");
    emit_line("// Helper for string interpolation - converts value to string");
    emit_line("template<typename T>");
    emit_line("std::string CB_HIR_to_string_helper(const T& value) {");
    emit_line("    if constexpr (std::is_same_v<T, std::string>) {");
    emit_line("        return value;");
    emit_line("    } else {");
    emit_line("        return std::to_string(value);");
    emit_line("    }");
    emit_line("}");
    emit_line("");
    emit_line("// Specialization for std::variant - uses std::visit to convert");
    emit_line("template<typename... Ts>");
    emit_line("std::string CB_HIR_to_string_helper(const std::variant<Ts...>& value) {");
    emit_line("    return std::visit([](const auto& v) -> std::string {");
    emit_line("        using T = std::decay_t<decltype(v)>;");
    emit_line("        if constexpr (std::is_same_v<T, std::string>) {");
    emit_line("            return v;");
    emit_line("        } else if constexpr (std::is_same_v<T, bool>) {");
    emit_line("            return v ? \"true\" : \"false\";");
    emit_line("        } else if constexpr (std::is_same_v<T, char>) {");
    emit_line("            return std::string(1, v);");
    emit_line("        } else if constexpr (std::is_arithmetic_v<T>) {");
    emit_line("            return std::to_string(v);");
    emit_line("        } else {");
    emit_line("            return \"[complex type]\";");
    emit_line("        }");
    emit_line("    }, value);");
    emit_line("}");
    emit_line("");

    // インポート処理
    generate_imports(program);

    // Typedef
    generate_typedefs(program.typedefs);

    // FFI関数宣言
    generate_foreign_functions(program.foreign_functions);

    // 前方宣言
    generate_forward_declarations(program);

    // Enum定義
    generate_enums(program.enums);

    // Union定義
    generate_unions(program.unions);

    // インターフェース定義（抽象クラスとして）- 構造体の前に配置
    generate_interfaces(program.interfaces);

    // 構造体定義
    generate_structs(program.structs);

    // グローバル変数
    generate_global_vars(program.global_vars);

    // 関数定義
    generate_functions(program.functions);

    // Impl定義（メソッド実装）
    generate_impls(program.impls);
    
    // プリミティブ型のModel特殊化を生成
    generate_primitive_type_specializations(program);

    return output.str();
}

// === ヘルパーメソッド ===

void HIRToCpp::emit(const std::string &code) { output << code; }

void HIRToCpp::emit_line(const std::string &code) {
    emit_indent();
    output << code << "\n";
}

void HIRToCpp::emit_indent() {
    for (int i = 0; i < indent_level; i++) {
        output << "    ";
    }
}

void HIRToCpp::increase_indent() { indent_level++; }

void HIRToCpp::decrease_indent() {
    if (indent_level > 0) {
        indent_level--;
    }
}

// v0.14.0: HIR変数名にプレフィックスを追加して名前衝突を防ぐ
std::string HIRToCpp::add_hir_prefix(const std::string &name) {
    // 既にプレフィックスが付いている場合はそのまま返す
    if (name.find("CB_HIR_") == 0) {
        return name;
    }
    // main関数は特別扱い
    if (name == "main") {
        return name;
    }
    // 修飾名(::を含む)はそのまま返す
    if (name.find("::") != std::string::npos) {
        return name;
    }
    // 組み込み関数やC++標準ライブラリの関数はプレフィックスを付けない
    if (name == "println" || name == "print" || name == "std" ||
        name == "assert" || name == "sizeof" || name == "malloc" ||
        name == "free" || name == "realloc" || name == "memcpy" ||
        name == "memset" || name == "memmove" || name == "strlen" ||
        name == "strcpy" || name == "strcmp" || name == "printf" ||
        name == "fprintf" || name == "sprintf" || name == "abs" ||
        name == "sqrt" || name == "pow" || name == "sin" || name == "cos" ||
        name == "tan") {
        return name;
    }
    return "CB_HIR_" + name;
}

// 多次元配列のベース型と次元を取得
void HIRToCpp::get_array_base_type_and_dimensions(
    const HIRType &type, const HIRType **base_type,
    std::vector<int> &dimensions) {
    if (type.kind == HIRType::TypeKind::Array) {
        dimensions.push_back(type.array_size);
        if (type.inner_type &&
            type.inner_type->kind == HIRType::TypeKind::Array) {
            // 再帰的に内側の配列を処理
            get_array_base_type_and_dimensions(*type.inner_type, base_type,
                                               dimensions);
        } else if (type.inner_type) {
            *base_type = type.inner_type.get();
        }
    } else {
        *base_type = &type;
    }
}

// 多次元配列の次元文字列を生成（例: "[2][3][4]"）
std::string HIRToCpp::generate_array_dimensions(const HIRType &type) {
    const HIRType *base_type = nullptr;
    std::vector<int> dimensions;
    get_array_base_type_and_dimensions(type, &base_type, dimensions);

    std::string result;
    for (int dim : dimensions) {
        if (dim > 0) {
            result += "[" + std::to_string(dim) + "]";
        } else if (dim == -1) {
            // VLA - use the name stored in the type
            result += "[" + add_hir_prefix(type.name) + "]";
        }
    }
    return result;
}

// === トップレベル定義の生成 ===

void HIRToCpp::generate_imports(const HIRProgram &program) {
    if (program.imports.empty()) {
        return;
    }

    emit_line("// Imports");
    for (const auto &import : program.imports) {
        emit_line("// import " + import.module_path);
    }
    emit_line("");
}

void HIRToCpp::generate_typedefs(const std::vector<HIRTypedef> &typedefs) {
    if (typedefs.empty()) {
        return;
    }

    emit_line("// Type aliases");
    for (const auto &typedef_def : typedefs) {
        // 関数ポインタ型の場合は特別な構文を使用
        if (typedef_def.target_type.kind == HIRType::TypeKind::Function) {
            emit("using " + typedef_def.name + " = ");
            
            // 戻り値型
            if (typedef_def.target_type.return_type) {
                emit(generate_type(*typedef_def.target_type.return_type));
            } else {
                emit("void");
            }
            
            emit(" (*)(");
            
            // パラメータ型
            for (size_t i = 0; i < typedef_def.target_type.param_types.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit(generate_type(typedef_def.target_type.param_types[i]));
            }
            
            emit(");\n");
        } else {
            // 通常の型エイリアス
            std::string base_type = generate_type(typedef_def.target_type);
            emit("using " + typedef_def.name + " = ");
            emit(base_type);
            emit(";\n");
        }
    }
    emit_line("");
}

void HIRToCpp::generate_foreign_functions(
    const std::vector<HIRForeignFunction> &foreign_funcs) {
    if (foreign_funcs.empty()) {
        return;
    }

    emit_line("// FFI (Foreign Function Interface) declarations");
    emit_line("extern \"C\" {");
    increase_indent();

    for (const auto &ffi : foreign_funcs) {
        emit_indent();
        emit(generate_type(ffi.return_type));
        // FFI関数にプレフィックスを追加して衝突を回避
        emit(" CB_FFI_" + ffi.module_name + "_" + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = ffi.parameters[i];
            emit(generate_type(param.type));
            if (!param.name.empty()) {
                emit(" " + param.name);
            }
        }

        emit(");\n");
    }

    decrease_indent();
    emit_line("}");
    emit_line("");

    // FFI関数のラッパー生成（モジュール修飾名対応）
    emit_line("// FFI wrapper functions (for qualified calls)");
    for (const auto &ffi : foreign_funcs) {
        emit_indent();
        emit("inline ");
        emit(generate_type(ffi.return_type));
        emit(" " + ffi.module_name + "_" + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = ffi.parameters[i];
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        // ラッパーはCB_FFI_付きの関数を呼び出す
        emit(") { return CB_FFI_" + ffi.module_name + "_" + ffi.function_name +
             "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            emit(ffi.parameters[i].name);
        }

        emit("); }\n");
    }
    emit_line("");
}

void HIRToCpp::generate_forward_declarations(const HIRProgram &program) {
    if (program.structs.empty() && program.interfaces.empty()) {
        return;
    }

    emit_line("// Forward declarations");

    for (const auto &struct_def : program.structs) {
        // Handle generic structs
        if (!struct_def.generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < struct_def.generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + struct_def.generic_params[i]);
            }
            emit("> ");
        }
        emit_line("struct " + struct_def.name + ";");
    }

    for (const auto &interface : program.interfaces) {
        // Handle generic interfaces
        if (!interface.generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < interface.generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + interface.generic_params[i]);
            }
            emit("> ");
        }
        emit_line("class " + interface.name + ";");
    }

    emit_line("");
}

void HIRToCpp::generate_structs(const std::vector<HIRStruct> &structs) {
    for (const auto &struct_def : structs) {
        generate_struct(struct_def);
    }
}

void HIRToCpp::generate_enums(const std::vector<HIREnum> &enums) {
    for (const auto &enum_def : enums) {
        generate_enum(enum_def);
    }
}

void HIRToCpp::generate_interfaces(
    const std::vector<HIRInterface> &interfaces) {
    for (const auto &interface : interfaces) {
        // ポインタベースinterface生成（既存）
        generate_pointer_interface(interface);

        // 値型interface生成（新規）
        if (interface.generate_value_type) {
            generate_value_interface(interface);
        }
    }
}

void HIRToCpp::generate_pointer_interface(const HIRInterface &interface) {
    emit_line("// Interface (pointer-based): " + interface.name);

    // Add template parameters if generic
    if (!interface.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < interface.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + interface.generic_params[i]);
        }
        emit(">\n");
    }

    emit_line("class " + interface.name + " {");
    emit_line("public:");
    increase_indent();

    emit_line("virtual ~" + interface.name + "() = default;");
    emit_line("");

    for (const auto &method : interface.methods) {
        emit("virtual ");
        emit(generate_type(method.return_type));
        emit(" " + method.name + "(");

        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");
            std::string param_type = generate_type(param.type);
            emit(param_type);
            emit(" " + param.name);
        }

        emit(") = 0;\n");
    }

    decrease_indent();
    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_value_interface(const HIRInterface &interface) {
    std::string value_class_name = interface.name + "_Value";

    emit_line("// Interface (value-based, type erasure): " + interface.name);

    // テンプレートパラメータ
    if (!interface.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < interface.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + interface.generic_params[i]);
        }
        emit(">\n");
    }

    emit_line("class " + value_class_name + " {");
    emit_line("private:");
    increase_indent();

    // Concept（内部インターフェース）
    emit_line("struct Concept {");
    increase_indent();

    for (const auto &method : interface.methods) {
        emit("virtual ");
        emit(generate_type(method.return_type));
        emit(" " + method.name + "(");

        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        emit(") = 0;\n");
    }

    emit_line("virtual std::unique_ptr<Concept> clone() const = 0;");
    emit_line("virtual ~Concept() = default;");

    decrease_indent();
    emit_line("};");
    emit_line("");

    // Model（テンプレート実装）
    emit_line("template<typename T>");
    emit_line("struct Model : Concept {");
    increase_indent();

    emit_line("T data;");
    emit_line("");
    emit_line("Model(T d) : data(std::move(d)) {}");
    emit_line("");

    for (const auto &method : interface.methods) {
        emit(generate_type(method.return_type));
        emit(" " + method.name + "(");

        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        emit(") override {\n");
        increase_indent();

        emit("return data." + method.name + "(");
        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            emit(method.parameters[i].name);
        }
        emit(");\n");

        decrease_indent();
        emit_line("}");
    }

    emit_line("");
    emit_line("std::unique_ptr<Concept> clone() const override {");
    increase_indent();
    emit_line("return std::make_unique<Model<T>>(data);");
    decrease_indent();
    emit_line("}");

    decrease_indent();
    emit_line("};");
    emit_line("");

    // メンバ変数
    emit_line("std::unique_ptr<Concept> ptr_;");
    emit_line("");

    decrease_indent();
    emit_line("public:");
    increase_indent();

    // コンストラクタ
    emit_line("template<typename T>");
    emit_line(value_class_name + "(T obj)");
    increase_indent();
    emit_line(": ptr_(std::make_unique<Model<T>>(std::move(obj))) {}");
    decrease_indent();
    emit_line("");

    // コピーコンストラクタ
    emit_line(value_class_name + "(const " + value_class_name + "& other)");
    increase_indent();
    emit_line(": ptr_(other.ptr_ ? other.ptr_->clone() : nullptr) {}");
    decrease_indent();
    emit_line("");

    // ムーブコンストラクタ
    emit_line(value_class_name + "(" + value_class_name +
              "&& other) = default;");
    emit_line("");

    // コピー代入演算子
    emit_line(value_class_name + "& operator=(const " + value_class_name +
              "& other) {");
    increase_indent();
    emit_line("if (this != &other) {");
    increase_indent();
    emit_line("ptr_ = other.ptr_ ? other.ptr_->clone() : nullptr;");
    decrease_indent();
    emit_line("}");
    emit_line("return *this;");
    decrease_indent();
    emit_line("}");
    emit_line("");

    // ムーブ代入演算子
    emit_line(value_class_name + "& operator=(" + value_class_name +
              "&& other) = default;");
    emit_line("");

    // メソッド
    for (const auto &method : interface.methods) {
        emit(generate_type(method.return_type));
        emit(" " + method.name + "(");

        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        emit(") {\n");
        increase_indent();

        emit("return ptr_->" + method.name + "(");
        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            emit(method.parameters[i].name);
        }
        emit(");\n");

        decrease_indent();
        emit_line("}");
    }

    decrease_indent();
    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_global_vars(const std::vector<HIRGlobalVar> &globals) {
    if (globals.empty()) {
        return;
    }

    emit_line("// Global variables");
    for (const auto &global : globals) {
        if (global.is_const)
            emit("const ");
        emit(generate_type(global.type));
        emit(" " + add_hir_prefix(global.name));

        if (global.init_expr) {
            emit(" = ");
            emit(generate_expr(*global.init_expr));
        }

        emit(";\n");
    }
    emit_line("");
}

void HIRToCpp::generate_functions(const std::vector<HIRFunction> &functions) {
    for (const auto &func : functions) {
        generate_function(func);
    }
}

void HIRToCpp::generate_impls(const std::vector<HIRImpl> &impls) {
    for (const auto &impl : impls) {
        generate_impl(impl);
    }
}

void HIRToCpp::generate_primitive_type_specializations(const HIRProgram &program) {
    emit_line("// Model specializations for primitive types");
    emit_line("");
    
    // プリミティブ型のリスト（すべての型を含む）
    std::vector<std::string> primitive_types = {
        // 符号付き整数型
        "int", "long", "short", "tiny", 
        // 符号なし整数型
        "unsigned", "unsigned long", "unsigned short", "unsigned tiny",
        // その他
        "char", "bool", "float", "double", "string"
    };
    
    // 各interfaceについて、プリミティブ型のimplがあるか確認
    for (const auto &interface : program.interfaces) {
        if (!interface.generate_value_type) {
            continue;
        }
        
        std::string value_class_name = interface.name + "_Value";
        
        // このinterfaceに対するimplを探す
        for (const auto &impl : program.impls) {
            if (impl.interface_name != interface.name) {
                continue;
            }
            
            // プリミティブ型かチェック
            bool is_primitive = false;
            for (const auto &prim : primitive_types) {
                if (impl.struct_name == prim) {
                    is_primitive = true;
                    break;
                }
            }
            
            if (!is_primitive) {
                continue;
            }
            
            // Model特殊化を生成
            emit_line("// Model specialization for " + impl.struct_name);
            emit_line("template<>");
            emit_line("struct " + value_class_name + "::Model<" + impl.struct_name + "> : " + value_class_name + "::Concept {");
            increase_indent();
            
            emit_line(impl.struct_name + " data;");
            emit_line("");
            emit_line("Model(" + impl.struct_name + " d) : data(d) {}");
            emit_line("");
            
            // 各メソッドの実装を生成
            for (const auto &method : impl.methods) {
                emit_indent();
                emit(generate_type(method.return_type));
                emit(" " + method.name + "(");
                
                for (size_t i = 0; i < method.parameters.size(); i++) {
                    if (i > 0) emit(", ");
                    const auto &param = method.parameters[i];
                    if (param.is_const) emit("const ");
                    emit(generate_type(param.type));
                    emit(" " + add_hir_prefix(param.name));
                }
                
                emit(") override {\n");
                increase_indent();
                
                // メソッド本体を生成
                // selfをdataに置き換えて生成
                if (method.body) {
                    // 一時的にコンテキストを設定
                    bool old_is_primitive = current_impl_is_for_primitive;
                    current_impl_is_for_primitive = true;
                    
                    generate_stmt(*method.body);
                    
                    current_impl_is_for_primitive = old_is_primitive;
                }
                
                decrease_indent();
                emit_line("}");
                emit_line("");
            }
            
            // clone()メソッド
            emit_line("std::unique_ptr<" + value_class_name + "::Concept> clone() const override {");
            increase_indent();
            emit_line("return std::make_unique<Model<" + impl.struct_name + ">>(data);");
            decrease_indent();
            emit_line("}");
            
            decrease_indent();
            emit_line("};");
            emit_line("");
        }
    }
}

// === 個別の定義生成 ===

void HIRToCpp::generate_struct(const HIRStruct &struct_def) {
    emit_line("// Struct: " + struct_def.name);

    // ジェネリック対応
    if (!struct_def.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < struct_def.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + struct_def.generic_params[i]);
        }
        emit(">\n");
    }

    // Check if this struct implements any interfaces
    std::vector<std::string> implemented_interfaces;
    std::vector<const HIRImpl *> struct_impls;

    if (current_program && !current_program->impls.empty()) {
        for (const auto &impl : current_program->impls) {
            // Extract base name from impl.struct_name (e.g., "Vector<T>" ->
            // "Vector")
            std::string impl_base_name = impl.struct_name;
            size_t angle_pos = impl_base_name.find('<');
            if (angle_pos != std::string::npos) {
                impl_base_name = impl_base_name.substr(0, angle_pos);
            }

            if (impl_base_name == struct_def.name) {
                struct_impls.push_back(&impl);
                if (!impl.interface_name.empty()) {
                    // Extract base name from impl.interface_name
                    std::string interface_base = impl.interface_name;
                    size_t iface_angle = interface_base.find('<');
                    if (iface_angle != std::string::npos) {
                        interface_base = interface_base.substr(0, iface_angle);
                    }

                    // Build interface name with template parameters
                    std::string interface_ref = interface_base;
                    if (!struct_def.generic_params.empty()) {
                        interface_ref += "<";
                        for (size_t i = 0; i < struct_def.generic_params.size();
                             i++) {
                            if (i > 0)
                                interface_ref += ", ";
                            interface_ref += struct_def.generic_params[i];
                        }
                        interface_ref += ">";
                    }
                    // Check for duplicates
                    if (std::find(implemented_interfaces.begin(),
                                  implemented_interfaces.end(),
                                  interface_ref) ==
                        implemented_interfaces.end()) {
                        implemented_interfaces.push_back(interface_ref);
                    }
                }
            }
        }
    }

    // Struct declaration with interface inheritance
    emit("struct " + struct_def.name);
    if (!implemented_interfaces.empty()) {
        emit(" : ");
        for (size_t i = 0; i < implemented_interfaces.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("public " + implemented_interfaces[i]);
        }
    }
    emit(" {\n");

    // フィールド
    if (!struct_def.fields.empty()) {
        for (const auto &field : struct_def.fields) {
            emit_indent();
            if (field.is_private) {
                // TODO: privateフィールドのサポート
            }
            emit(generate_type(field.type));
            emit(" " + field.name + ";\n");
        }
    }

    // Add default constructor
    emit_line("");
    emit_line("// Default constructor");
    emit_indent();
    emit(struct_def.name + "() = default;\n");

    // If implementing interfaces, add field initialization constructor
    if (!implemented_interfaces.empty() && !struct_def.fields.empty()) {
        emit_line("");
        emit_line("// Field initialization constructor");
        emit_indent();
        emit(struct_def.name + "(");
        for (size_t i = 0; i < struct_def.fields.size(); i++) {
            if (i > 0) emit(", ");
            const auto &field = struct_def.fields[i];
            emit(generate_type(field.type) + " _" + field.name);
        }
        emit(")");
        if (!struct_def.fields.empty()) {
            emit(" : ");
            for (size_t i = 0; i < struct_def.fields.size(); i++) {
                if (i > 0) emit(", ");
                const auto &field = struct_def.fields[i];
                emit(field.name + "(_" + field.name + ")");
            }
        }
        emit(" {}\n");
    }

    // Add method declarations from impls
    std::set<std::string>
        declared_methods; // Track declared methods to avoid duplicates
    if (!struct_impls.empty()) {
        for (const auto *impl_ptr : struct_impls) {
            // Find the corresponding interface for this specific impl
            const HIRInterface *interface_ptr = nullptr;
            if (current_program && !impl_ptr->interface_name.empty()) {
                std::string interface_base = impl_ptr->interface_name;
                size_t angle = interface_base.find('<');
                if (angle != std::string::npos) {
                    interface_base = interface_base.substr(0, angle);
                }
                for (const auto &iface : current_program->interfaces) {
                    if (iface.name == interface_base) {
                        interface_ptr = &iface;
                        break;
                    }
                }
            }

            if (!impl_ptr->methods.empty()) {
                emit_line("");
                emit_line("// Methods");
                for (const auto &method : impl_ptr->methods) {
                    // Try to find corresponding interface method for correct
                    // types
                    const HIRInterface::MethodSignature *interface_method =
                        nullptr;
                    if (interface_ptr) {
                        for (const auto &iface_method :
                             interface_ptr->methods) {
                            if (iface_method.name == method.name) {
                                interface_method = &iface_method;
                                break;
                            }
                        }
                    }

                    // Create method signature to check for duplicates
                    std::string method_sig = method.name + "(";
                    for (size_t i = 0; i < method.parameters.size(); i++) {
                        if (i > 0)
                            method_sig += ",";
                        method_sig += generate_type(method.parameters[i].type);
                    }
                    method_sig += ")";

                    // Skip if already declared
                    if (declared_methods.find(method_sig) !=
                        declared_methods.end()) {
                        continue;
                    }
                    declared_methods.insert(method_sig);

                    emit_indent();
                    // Add virtual keyword if implementing an interface
                    if (!impl_ptr->interface_name.empty() && interface_method) {
                        emit("virtual ");
                    }
                    // Use interface return type if available, otherwise impl's
                    std::string return_type;
                    if (interface_method) {
                        return_type =
                            generate_type(interface_method->return_type);
                    } else {
                        return_type = generate_type(method.return_type);
                    }
                    emit(return_type);
                    emit(" " + method.name + "(");

                    for (size_t i = 0; i < method.parameters.size(); i++) {
                        if (i > 0)
                            emit(", ");
                        const auto &param = method.parameters[i];
                        if (param.is_const)
                            emit("const ");

                        // Use interface parameter type if available, otherwise
                        // impl's
                        std::string param_type;
                        if (interface_method &&
                            i < interface_method->parameters.size()) {
                            param_type = generate_type(
                                interface_method->parameters[i].type);
                        } else {
                            param_type = generate_type(param.type);
                        }
                        emit(param_type);
                        emit(" " +
                             param.name); // Don't add prefix to parameters
                    }

                    emit(")");
                    // Only add override if this method exists in the interface
                    if (!impl_ptr->interface_name.empty() && interface_method) {
                        emit(" override");
                    }
                    emit(";\n");
                }
            }
        }
    }

    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_enum(const HIREnum &enum_def) {
    emit_line("// Enum: " + enum_def.name);
    // v0.14.0: unscopedなenumとして生成（intへの暗黙的変換を許可）
    emit_line("enum " + enum_def.name + " {");
    increase_indent();

    for (size_t i = 0; i < enum_def.variants.size(); i++) {
        const auto &variant = enum_def.variants[i];
        emit_indent();
        emit(variant.name);
        emit(" = " + std::to_string(variant.value));
        if (i < enum_def.variants.size() - 1) {
            emit(",");
        }
        emit("\n");
    }

    decrease_indent();
    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_unions(const std::vector<HIRUnion> &unions) {
    for (const auto &union_def : unions) {
        generate_union(union_def);
    }
}

void HIRToCpp::generate_union(const HIRUnion &union_def) {
    emit_line("// Union type: " + union_def.name);

    // Build typedef resolution map from current program
    std::unordered_map<std::string, std::string> typedef_map;
    if (current_program) {
        for (const auto &td : current_program->typedefs) {
            std::string base_type = generate_type(td.target_type);
            typedef_map[td.name] = base_type;
        }
    }

    // Helper lambda to resolve typedefs to their base types
    auto resolve_typedef = [&typedef_map](const std::string &type_str) -> std::string {
        std::string resolved = type_str;
        // Keep resolving until we hit a non-typedef
        for (int i = 0; i < 10; i++) { // Max 10 levels of typedef nesting
            auto it = typedef_map.find(resolved);
            if (it == typedef_map.end()) {
                break;
            }
            resolved = it->second;
        }
        return resolved;
    };

    // Collect type names for std::variant
    std::vector<std::string> type_names;
    bool has_literals = false;

    for (const auto &variant : union_def.variants) {
        switch (variant.kind) {
        case HIRUnion::Variant::Kind::LiteralInt:
        case HIRUnion::Variant::Kind::LiteralBool:
            if (!has_literals) {
                // Add int once for literal integers/bools
                bool found = false;
                for (const auto &t : type_names) {
                    if (t == "int") {
                        found = true;
                        break;
                    }
                }
                if (!found)
                    type_names.push_back("int");
                has_literals = true;
            }
            break;
        case HIRUnion::Variant::Kind::LiteralString: {
            bool found = false;
            for (const auto &t : type_names) {
                if (t == "std::string") {
                    found = true;
                    break;
                }
            }
            if (!found)
                type_names.push_back("std::string");
            break;
        }
        case HIRUnion::Variant::Kind::Type: {
            std::string type_str = generate_type(variant.type);
            // Resolve typedefs to their base types
            std::string resolved_type = resolve_typedef(type_str);
            // Avoid duplicates using resolved type
            bool found = false;
            for (const auto &t : type_names) {
                if (t == resolved_type) {
                    found = true;
                    break;
                }
            }
            if (!found)
                type_names.push_back(resolved_type);
            break;
        }
        }
    }

    // Generate std::variant typedef
    if (type_names.empty()) {
        // Empty union, use int as default
        emit_line("using " + union_def.name + " = int;");
    } else if (type_names.size() == 1) {
        // Single type, use direct alias
        emit_line("using " + union_def.name + " = " + type_names[0] + ";");
    } else {
        // Multiple types, use std::variant
        emit("using " + union_def.name + " = std::variant<");
        for (size_t i = 0; i < type_names.size(); i++) {
            if (i > 0)
                emit(", ");
            emit(type_names[i]);
        }
        emit(">;\n");
    }
    emit_line("");
}

void HIRToCpp::generate_function(const HIRFunction &func) {
    emit_line("// Function: " + func.name);

    // ジェネリック対応
    if (!func.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < func.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + func.generic_params[i]);
        }
        emit(">\n");
    }

    // 戻り値の型
    emit_indent();
    // main関数は常にintを返す
    if (func.name == "main") {
        emit("int");
    } else {
        emit(generate_type(func.return_type));
    }
    emit(" " + add_hir_prefix(func.name) + "(");

    // パラメータ
    for (size_t i = 0; i < func.parameters.size(); i++) {
        if (i > 0)
            emit(", ");
        const auto &param = func.parameters[i];
        if (param.is_const)
            emit("const ");
        emit(generate_type(param.type));
        emit(" " + add_hir_prefix(param.name));
    }

    emit(") {\n");

    // 関数パラメータの型を記録（ポインタアクセス判定用）
    current_function_params.clear();
    for (const auto &param : func.parameters) {
        current_function_params[param.name] = param.type;
    }

    // 現在の関数の情報を記録（async関数のreturn文処理用）
    // Check if return type is Future<T> by checking the type name
    current_function_is_async =
        (func.return_type.kind == HIRType::TypeKind::Struct &&
         func.return_type.name.find("Future<") == 0);
    current_function_return_type = func.return_type;

    // 関数本体
    if (func.body) {
        increase_indent();
        generate_stmt(*func.body);
        decrease_indent();
    }

    emit_line("}");
    emit_line("");

    // パラメータマップをクリア
    current_function_params.clear();
}

void HIRToCpp::generate_impl(const HIRImpl &impl) {
    emit_line("// Impl for: " + impl.struct_name);

    if (!impl.interface_name.empty()) {
        emit_line("// implements: " + impl.interface_name);
    }

    // Check if implementing for a primitive type (すべてのプリミティブ型を含む)
    bool is_primitive_type = (impl.struct_name == "int" || 
                             impl.struct_name == "long" ||
                             impl.struct_name == "short" ||
                             impl.struct_name == "tiny" ||
                             impl.struct_name == "unsigned" ||
                             impl.struct_name == "unsigned long" ||
                             impl.struct_name == "unsigned short" ||
                             impl.struct_name == "unsigned tiny" ||
                             impl.struct_name == "char" ||
                             impl.struct_name == "bool" ||
                             impl.struct_name == "float" ||
                             impl.struct_name == "double" ||
                             impl.struct_name == "string");
    
    // プリミティブ型でinterfaceを実装している場合はスキップ
    // (Model特殊化で処理される)
    if (is_primitive_type && !impl.interface_name.empty()) {
        emit_line("// Skipped: Will be generated as Model specialization");
        emit_line("");
        return;
    }

    // メソッドを生成
    for (const auto &method : impl.methods) {
        emit_line("// Method: " + method.name);

        // ジェネリック対応: implのgeneric_paramsかmethodのgeneric_paramsを使う
        std::vector<std::string> generic_params = impl.generic_params;
        if (!method.generic_params.empty()) {
            generic_params = method.generic_params;
        }

        // If generic_params is empty but struct_name contains <T>, extract it
        if (generic_params.empty() &&
            impl.struct_name.find('<') != std::string::npos) {
            size_t start = impl.struct_name.find('<');
            size_t end = impl.struct_name.find('>');
            if (start != std::string::npos && end != std::string::npos &&
                end > start) {
                std::string params_str =
                    impl.struct_name.substr(start + 1, end - start - 1);
                // カンマで分割して複数のパラメータに対応
                size_t pos = 0;
                while (pos < params_str.length()) {
                    size_t comma_pos = params_str.find(',', pos);
                    if (comma_pos == std::string::npos) {
                        // 最後のパラメータ
                        std::string param = params_str.substr(pos);
                        // 前後の空白を削除
                        size_t first = param.find_first_not_of(' ');
                        size_t last = param.find_last_not_of(' ');
                        if (first != std::string::npos) {
                            generic_params.push_back(
                                param.substr(first, last - first + 1));
                        }
                        break;
                    } else {
                        std::string param =
                            params_str.substr(pos, comma_pos - pos);
                        // 前後の空白を削除
                        size_t first = param.find_first_not_of(' ');
                        size_t last = param.find_last_not_of(' ');
                        if (first != std::string::npos) {
                            generic_params.push_back(
                                param.substr(first, last - first + 1));
                        }
                        pos = comma_pos + 1;
                    }
                }
            }
        }

        if (!generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + generic_params[i]);
            }
            emit(">\n");
        }

        // 戻り値の型
        emit_indent();
        emit(generate_type(method.return_type));
        
        // For primitive types, generate as free functions
        if (is_primitive_type) {
            // Free function: impl_struct_method(self, params...)
            std::string func_name = "CB_IMPL_" + impl.struct_name + "_" + method.name;
            emit(" " + func_name + "(");
            
            // First parameter is always 'self'
            emit(impl.struct_name + " CB_HIR_self");
            
            // Add other parameters
            if (!method.parameters.empty()) {
                emit(", ");
            }
        } else {
            // Member function: Struct::method(params...)
            emit(" " + impl.struct_name + "::" + method.name + "(");
        }

        // パラメータ - ジェネリック型の場合は型パラメータ名を使用
        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");

            // 型がUnknownの場合で、ジェネリックパラメータがある場合は、それを使用
            std::string param_type;
            if (param.type.kind == HIRType::TypeKind::Unknown &&
                !generic_params.empty()) {
                // 最初のジェネリックパラメータをデフォルトで使用
                param_type = generic_params[0];
            } else if (param.type.kind == HIRType::TypeKind::Generic) {
                // Generic型の場合は型名をそのまま使用
                param_type = param.type.name;
            } else {
                param_type = generate_type(param.type);
            }

            emit(param_type);
            emit(" " + add_hir_prefix(param.name));
        }

        emit(") {\n");

        // ジェネリックパラメータをコンテキストに設定
        current_generic_params = generic_params;
        
        // プリミティブ型implのコンテキストを設定
        current_impl_is_for_primitive = is_primitive_type;

        // 関数本体
        if (method.body) {
            increase_indent();
            generate_stmt(*method.body);
            decrease_indent();
        }

        // コンテキストをクリア
        current_generic_params.clear();
        current_impl_is_for_primitive = false;

        emit_line("}");
        emit_line("");
    }
}

// === 文の生成 ===

void HIRToCpp::generate_stmt(const HIRStmt &stmt) {
    switch (stmt.kind) {
    case HIRStmt::StmtKind::VarDecl:
        generate_var_decl(stmt);
        break;
    case HIRStmt::StmtKind::Assignment:
        generate_assignment(stmt);
        break;
    case HIRStmt::StmtKind::ExprStmt:
        emit_indent();
        emit(generate_expr(*stmt.expr));
        emit(";\n");
        break;
    case HIRStmt::StmtKind::If:
        generate_if(stmt);
        break;
    case HIRStmt::StmtKind::While:
        generate_while(stmt);
        break;
    case HIRStmt::StmtKind::For:
        generate_for(stmt);
        break;
    case HIRStmt::StmtKind::Return:
        generate_return(stmt);
        break;
    case HIRStmt::StmtKind::Break:
        emit_line("break;");
        break;
    case HIRStmt::StmtKind::Continue:
        emit_line("continue;");
        break;
    case HIRStmt::StmtKind::Block:
        generate_block(stmt);
        break;
    case HIRStmt::StmtKind::Switch:
        generate_switch(stmt);
        break;
    case HIRStmt::StmtKind::Defer:
        generate_defer(stmt);
        break;
    case HIRStmt::StmtKind::Delete:
        generate_delete(stmt);
        break;
    case HIRStmt::StmtKind::Try:
        generate_try_catch(stmt);
        break;
    case HIRStmt::StmtKind::Throw:
        emit_indent();
        emit("throw ");
        if (stmt.throw_expr) {
            emit(generate_expr(*stmt.throw_expr));
        }
        emit(";\n");
        break;
    case HIRStmt::StmtKind::Assert:
        generate_assert(stmt);
        break;
    default:
        emit_line("// TODO: Unsupported statement");
        break;
    }
}

void HIRToCpp::generate_var_decl(const HIRStmt &stmt) {
    emit_indent();
    if (stmt.is_const) {
        emit("const ");
    }

    // Special handling for arrays (including multidimensional)
    if (stmt.var_type.kind == HIRType::TypeKind::Array) {
        // Get base type and all dimensions
        const HIRType *base_type = nullptr;
        std::vector<int> dimensions;
        get_array_base_type_and_dimensions(stmt.var_type, &base_type,
                                           dimensions);

        // Check if we're in a function that returns an array
        // OR if initializer is a function call that returns array
        // v0.14.0: Always use std::array for fixed-size arrays to support union assignment
        bool use_std_array = true;

        if (!dimensions.empty() && dimensions[0] > 0 && use_std_array) {
            // Use std::array when in a function returning array or initialized
            // by function call
            emit(generate_type(stmt.var_type));
            emit(" " + add_hir_prefix(stmt.var_name));
        } else if (stmt.var_type.array_size == -1 &&
                   !stmt.var_type.name.empty()) {
            // VLA: int[size] -> int array_name[size_expr]
            if (stmt.var_type.inner_type) {
                emit(generate_type(*stmt.var_type.inner_type));
            } else {
                emit("int"); // fallback
            }
            emit(" " + add_hir_prefix(stmt.var_name));
            emit("[" + add_hir_prefix(stmt.var_type.name) + "]");
        } else {
            // Dynamic array without size - use std::vector
            emit(generate_type(stmt.var_type));
            emit(" " + add_hir_prefix(stmt.var_name));
        }
    } else {
        emit(generate_type(stmt.var_type));
        emit(" " + add_hir_prefix(stmt.var_name));
    }

    if (stmt.init_expr) {
        emit(" = ");

        // Type-based cast insertion
        std::string var_type_str = generate_type(stmt.var_type);
        std::string init_expr_str = generate_expr(*stmt.init_expr);

        // void**への代入の場合、キャストを追加
        if (var_type_str == "void**") {
            emit("(void**)");
        }
        // int64_tなど整数型への代入で、式がvoid*キャストを含む場合
        else if ((var_type_str == "int64_t" || var_type_str == "long long" ||
                  var_type_str == "int" || var_type_str == "long") &&
                 init_expr_str.find("(void*)") != std::string::npos) {
            // void*からの変換が必要な場合、明示的にキャスト
            emit("(" + var_type_str + ")");
        }
        // v0.14.0: enum型への代入で、初期化式が整数リテラルの場合はキャスト
        else if (stmt.var_type.kind == HIRType::TypeKind::Enum &&
                 stmt.init_expr->kind == HIRExpr::ExprKind::Literal) {
            emit("static_cast<" + var_type_str + ">(");
            emit(init_expr_str);
            emit(")");
            goto skip_normal_emit;
        }

        emit(init_expr_str);
    skip_normal_emit:;
    } else if (stmt.var_type.kind != HIRType::TypeKind::Array) {
        // No initializer - use default initialization {} (only for non-arrays)
        // Arrays with VLA or fixed size don't need initialization
        emit("{}");
    }

    emit(";\n");
}

void HIRToCpp::generate_assignment(const HIRStmt &stmt) {
    emit_indent();
    emit(generate_expr(*stmt.lhs));
    emit(" = ");
    emit(generate_expr(*stmt.rhs));
    emit(";\n");
}

void HIRToCpp::generate_if(const HIRStmt &stmt) {
    emit_indent();
    emit("if (");
    emit(remove_outer_parens(generate_expr(*stmt.condition)));
    emit(") {\n");

    increase_indent();
    if (stmt.then_body) {
        generate_stmt(*stmt.then_body);
    }
    decrease_indent();

    if (stmt.else_body) {
        emit_line("} else {");
        increase_indent();
        generate_stmt(*stmt.else_body);
        decrease_indent();
    }

    emit_line("}");
}

void HIRToCpp::generate_while(const HIRStmt &stmt) {
    emit_indent();
    emit("while (");
    emit(remove_outer_parens(generate_expr(*stmt.condition)));
    emit(") {\n");

    increase_indent();
    if (stmt.body) {
        generate_stmt(*stmt.body);
    }
    decrease_indent();

    emit_line("}");
}

void HIRToCpp::generate_for(const HIRStmt &stmt) {
    emit_indent();
    emit("for (");

    // init
    if (stmt.init) {
        // セミコロンなしで生成
        if (stmt.init->kind == HIRStmt::StmtKind::VarDecl) {
            if (stmt.init->is_const)
                emit("const ");
            emit(generate_type(stmt.init->var_type));
            emit(" " + add_hir_prefix(stmt.init->var_name));
            if (stmt.init->init_expr) {
                emit(" = ");
                emit(generate_expr(*stmt.init->init_expr));
            }
        } else if (stmt.init->kind == HIRStmt::StmtKind::Assignment) {
            if (stmt.init->lhs && stmt.init->rhs) {
                emit(generate_expr(*stmt.init->lhs));
                emit(" = ");
                emit(generate_expr(*stmt.init->rhs));
            }
        } else if (stmt.init->kind == HIRStmt::StmtKind::ExprStmt) {
            if (stmt.init->expr) {
                emit(generate_expr(*stmt.init->expr));
            }
        }
    }
    emit("; ");

    // condition
    if (stmt.condition) {
        emit(remove_outer_parens(generate_expr(*stmt.condition)));
    }
    emit("; ");

    // update
    if (stmt.update) {
        if (stmt.update->kind == HIRStmt::StmtKind::Assignment) {
            if (stmt.update->lhs && stmt.update->rhs) {
                emit(generate_expr(*stmt.update->lhs));
                emit(" = ");
                emit(generate_expr(*stmt.update->rhs));
            }
        } else if (stmt.update->kind == HIRStmt::StmtKind::ExprStmt) {
            if (stmt.update->expr) {
                emit(generate_expr(*stmt.update->expr));
            }
        }
    }

    emit(") {\n");

    increase_indent();
    if (stmt.body) {
        generate_stmt(*stmt.body);
    }
    decrease_indent();

    emit_line("}");
}

void HIRToCpp::generate_return(const HIRStmt &stmt) {
    if (current_function_is_async && stmt.return_expr) {
        // async関数の場合、Future<T>を構築して返す
        // Extract inner type from Future<T>
        std::string inner_type = "int"; // default
        if (current_function_return_type.kind == HIRType::TypeKind::Struct &&
            current_function_return_type.name.find("Future<") == 0) {
            size_t start = current_function_return_type.name.find('<');
            size_t end = current_function_return_type.name.rfind('>');
            if (start != std::string::npos && end != std::string::npos &&
                end > start) {
                inner_type = current_function_return_type.name.substr(
                    start + 1, end - start - 1);
            }
        }

        emit_indent();
        emit("{\n");
        increase_indent();
        emit_indent();
        emit(generate_type(current_function_return_type));
        emit(" __future;\n");
        emit_indent();
        emit("__future.value = ");
        emit(generate_expr(*stmt.return_expr));
        emit(";\n");
        emit_indent();
        emit("__future.is_ready = true;\n");
        emit_indent();
        emit("return __future;\n");
        decrease_indent();
        emit_indent();
        emit("}\n");
    } else {
        // 通常の関数
        emit_indent();
        emit("return");
        if (stmt.return_expr) {
            std::string return_expr_str = generate_expr(*stmt.return_expr);

            emit(" ");
            // void*式を含む場合、reinterpret_castを使用
            // これはvoid*をint等に変換する際の型エラーを防ぐ
            if (return_expr_str.find("(void*)") != std::string::npos) {
                // void*を含む式は、通常ポインタ演算の結果
                // intptr_t経由で安全にキャスト
                emit("(intptr_t)(");
                emit(return_expr_str);
                emit(")");
            } else {
                emit(return_expr_str);
            }
        }
        emit(";\n");
    }
}

void HIRToCpp::generate_block(const HIRStmt &stmt) {
    // デバッグ: ブロック内の文の種類を確認
    if (stmt.block_stmts.empty()) {
        // 空のブロックの場合は何も出力しない（ただし、デバッグのためコメントを残す）
        emit_line("// Empty block");
        return;
    }

    // 変数宣言のみのブロックの場合、中括弧を省略して直接展開
    bool all_var_decls = !stmt.block_stmts.empty();
    for (const auto &s : stmt.block_stmts) {
        if (s.kind != HIRStmt::StmtKind::VarDecl) {
            all_var_decls = false;
            break;
        }
    }

    if (all_var_decls) {
        // 変数宣言のみなので、中括弧なしで直接出力
        for (const auto &s : stmt.block_stmts) {
            generate_stmt(s);
        }
    } else {
        // 通常のブロック
        emit_line("{");
        increase_indent();

        for (const auto &s : stmt.block_stmts) {
            generate_stmt(s);
        }

        decrease_indent();
        emit_line("}");
    }
}

// v0.14.0: OR式から値を再帰的に収集するヘルパー関数
void HIRToCpp::collect_or_values(const HIRExpr *expr,
                                 std::vector<const HIRExpr *> &values) {
    if (!expr)
        return;

    // OR演算子の場合は再帰的に左右を収集
    if (expr->kind == HIRExpr::ExprKind::BinaryOp && expr->op == "||") {
        collect_or_values(expr->left.get(), values);
        collect_or_values(expr->right.get(), values);
    } else {
        // OR演算子以外は値として追加
        values.push_back(expr);
    }
}

void HIRToCpp::generate_switch(const HIRStmt &stmt) {
    emit_indent();
    emit("switch (");
    emit(generate_expr(*stmt.switch_expr));
    emit(") {\n");

    increase_indent();

    for (const auto &case_item : stmt.switch_cases) {
        if (case_item.case_value) {
            // v0.14.0: 範囲式の場合は複数のcaseラベルを生成
            if (case_item.case_value->kind == HIRExpr::ExprKind::Range) {
                // 範囲の開始と終了を取得（整数リテラルと仮定）
                if (case_item.case_value->range_start &&
                    case_item.case_value->range_end) {
                    int start = std::stoi(
                        case_item.case_value->range_start->literal_value);
                    int end = std::stoi(
                        case_item.case_value->range_end->literal_value);
                    // 範囲の各値に対してcaseラベルを生成
                    for (int i = start; i <= end; i++) {
                        emit_indent();
                        emit("case " + std::to_string(i) + ":\n");
                    }
                }
            }
            // v0.14.0: OR条件の場合は複数のcaseラベルを生成（ネスト対応）
            else if (case_item.case_value->kind ==
                         HIRExpr::ExprKind::BinaryOp &&
                     case_item.case_value->op == "||") {
                // OR式からすべての値を収集
                std::vector<const HIRExpr *> or_values;
                collect_or_values(case_item.case_value.get(), or_values);
                // 各値に対してcaseラベルを生成
                for (const auto *val : or_values) {
                    emit_indent();
                    emit("case ");
                    emit(generate_expr(*val));
                    emit(":\n");
                }
            } else {
                emit_indent();
                emit("case ");
                emit(generate_expr(*case_item.case_value));
                emit(":\n");
            }
        } else {
            emit_line("default:");
        }

        increase_indent();
        for (const auto &case_stmt : case_item.case_body) {
            generate_stmt(case_stmt);
        }
        // v0.14.0: bodyが空の場合はfall-throughなのでbreakを生成しない
        if (!case_item.case_body.empty()) {
            emit_line("break;");
        }
        decrease_indent();
    }

    decrease_indent();
    emit_line("}");
}

void HIRToCpp::generate_defer(const HIRStmt &stmt) {
    // C++でdeferを実装するにはRAIIラッパーが必要
    emit_line("// TODO: defer statement");
    if (stmt.defer_stmt) {
        generate_stmt(*stmt.defer_stmt);
    }
}

void HIRToCpp::generate_delete(const HIRStmt &stmt) {
    emit_indent();
    emit("delete ");
    emit(generate_expr(*stmt.delete_expr));
    emit(";\n");
}

void HIRToCpp::generate_try_catch(const HIRStmt &stmt) {
    emit_line("try {");
    increase_indent();

    for (const auto &s : stmt.try_block) {
        generate_stmt(s);
    }

    decrease_indent();
    emit_line("}");

    for (const auto &catch_clause : stmt.catch_clauses) {
        emit_indent();
        emit("catch (");
        emit(generate_type(catch_clause.exception_type));
        emit(" " + catch_clause.exception_var + ") {\n");

        increase_indent();
        for (const auto &s : catch_clause.catch_body) {
            generate_stmt(s);
        }
        decrease_indent();

        emit_line("}");
    }

    if (!stmt.finally_block.empty()) {
        emit_line("// finally block (executed via RAII)");
        for (const auto &s : stmt.finally_block) {
            generate_stmt(s);
        }
    }
}

// === 式の生成 ===

std::string HIRToCpp::generate_expr(const HIRExpr &expr) {
    switch (expr.kind) {
    case HIRExpr::ExprKind::Literal:
        return generate_literal(expr);
    case HIRExpr::ExprKind::Variable:
        return generate_variable(expr);
    case HIRExpr::ExprKind::BinaryOp:
        return generate_binary_op(expr);
    case HIRExpr::ExprKind::UnaryOp:
        return generate_unary_op(expr);
    case HIRExpr::ExprKind::FunctionCall:
        return generate_function_call(expr);
    case HIRExpr::ExprKind::MethodCall:
        return generate_method_call(expr);
    case HIRExpr::ExprKind::MemberAccess:
        return generate_member_access(expr);
    case HIRExpr::ExprKind::ArrayAccess:
        return generate_array_access(expr);
    case HIRExpr::ExprKind::Cast:
        return generate_cast(expr);
    case HIRExpr::ExprKind::Ternary:
        return generate_ternary(expr);
    case HIRExpr::ExprKind::Lambda:
        return generate_lambda(expr);
    case HIRExpr::ExprKind::StructLiteral:
        return generate_struct_literal(expr);
    case HIRExpr::ExprKind::ArrayLiteral:
        return generate_array_literal(expr);
    case HIRExpr::ExprKind::AddressOf:
        return generate_address_of(expr);
    case HIRExpr::ExprKind::Dereference:
        return generate_dereference(expr);
    case HIRExpr::ExprKind::SizeOf:
        return generate_sizeof(expr);
    case HIRExpr::ExprKind::New:
        return generate_new(expr);
    case HIRExpr::ExprKind::Await:
        return generate_await(expr);
    case HIRExpr::ExprKind::PreIncDec:
        return generate_pre_incdec(expr);
    case HIRExpr::ExprKind::PostIncDec:
        return generate_post_incdec(expr);
    default:
        return "/* unsupported expr */";
    }
}

std::string HIRToCpp::generate_literal(const HIRExpr &expr) {
    // 文字列リテラルはエスケープ処理
    if (expr.literal_type.kind == HIRType::TypeKind::String) {
        return "\"" + escape_string(expr.literal_value) + "\"";
    }
    return expr.literal_value;
}

std::string HIRToCpp::generate_variable(const HIRExpr &expr) {
    // Convert 'self' to appropriate representation
    if (expr.var_name == "self") {
        if (current_impl_is_for_primitive) {
            // For primitive type impl Model specialization, use 'data'
            return "data";
        } else {
            // For struct impls, use (*this)
            return "(*this)";
        }
    }
    return add_hir_prefix(expr.var_name);
}

std::string HIRToCpp::generate_binary_op(const HIRExpr &expr) {
    // Helper lambda to check if a type name is a union
    auto is_union_type = [this](const std::string &type_name) -> bool {
        if (!current_program || type_name.empty()) return false;
        for (const auto &union_def : current_program->unions) {
            if (union_def.name == type_name) {
                return true;
            }
        }
        return false;
    };

    // Helper lambda to get type name for an expression
    auto get_expr_type_name = [this](const HIRExpr *e) -> std::string {
        if (!e || !current_program) return "";

        // Check direct type info
        if (!e->type.name.empty()) {
            return e->type.name;
        }

        // For MemberAccess, look up the struct field type
        if (e->kind == HIRExpr::ExprKind::MemberAccess && e->object) {
            // Get the object's struct type
            std::string struct_name;

            // Check object's type name
            if (!e->object->type.name.empty()) {
                struct_name = e->object->type.name;
            }
            // For Variable, look up from function parameters
            else if (e->object->kind == HIRExpr::ExprKind::Variable) {
                auto it = current_function_params.find(e->object->var_name);
                if (it != current_function_params.end()) {
                    struct_name = it->second.name;
                }
            }

            // Look up the struct and find the field type
            if (!struct_name.empty()) {
                for (const auto &s : current_program->structs) {
                    if (s.name == struct_name) {
                        for (const auto &field : s.fields) {
                            if (field.name == e->member_name) {
                                return field.type.name;
                            }
                        }
                        break;
                    }
                }
            }

            // Fallback: search all structs for the field name
            // This handles local variables where type info is not available
            if (!e->member_name.empty()) {
                for (const auto &s : current_program->structs) {
                    for (const auto &field : s.fields) {
                        if (field.name == e->member_name && !field.type.name.empty()) {
                            // Check if this field type is a union
                            for (const auto &union_def : current_program->unions) {
                                if (union_def.name == field.type.name) {
                                    return field.type.name;
                                }
                            }
                        }
                    }
                }
            }
        }

        return "";
    };

    // Union型の算術演算の特殊処理
    // 左辺がUnion型で算術演算の場合、std::get<int>()でラップ
    if (expr.left && expr.right && current_program) {
        std::string left_type_name = get_expr_type_name(expr.left.get());
        std::string right_type_name = get_expr_type_name(expr.right.get());

        bool left_is_union = is_union_type(left_type_name);
        bool right_is_union = is_union_type(right_type_name);

        // 算術演算子かチェック
        bool is_arithmetic = (expr.op == "+" || expr.op == "-" ||
                              expr.op == "*" || expr.op == "/" || expr.op == "%");

        if ((left_is_union || right_is_union) && is_arithmetic) {
            std::string result = "(";
            if (left_is_union) {
                result += "std::get<int>(" + generate_expr(*expr.left) + ")";
            } else {
                result += generate_expr(*expr.left);
            }
            result += " " + expr.op + " ";
            if (right_is_union) {
                result += "std::get<int>(" + generate_expr(*expr.right) + ")";
            } else {
                result += generate_expr(*expr.right);
            }
            result += ")";
            return result;
        }
    }

    // ポインタ演算の特殊処理: + or - は全てchar*経由で行う（void*対応のため）
    // 型情報が不完全な場合があるため、全ての+/-に適用
    // ポインタ演算の特別処理
    if ((expr.op == "+" || expr.op == "-") && expr.left && expr.right) {
        // 型情報ベースの判定を最優先
        bool is_pointer_arithmetic = false;

        // 文字列連結を除外: 左辺が文字列リテラル、または右辺が文字列型の場合
        bool is_string_concat = false;
        if (expr.left->kind == HIRExpr::ExprKind::Literal &&
            expr.left->type.kind == HIRType::TypeKind::String) {
            is_string_concat = true;
        }
        // 右辺が関数呼び出し(to_string_helper等)または文字列型の場合も文字列連結
        if (expr.right->kind == HIRExpr::ExprKind::FunctionCall ||
            expr.right->type.kind == HIRType::TypeKind::String) {
            is_string_concat = true;
        }

        if (is_string_concat) {
            // 文字列連結は通常のBinaryOpとして処理
            std::string result = "(";
            result += generate_expr(*expr.left);
            result += " " + expr.op + " ";
            result += generate_expr(*expr.right);
            result += ")";
            return result;
        }

        // 1. 左辺の型情報が利用可能な場合
        if (expr.left->type.kind == HIRType::TypeKind::Pointer) {
            is_pointer_arithmetic = true;
        }
        // 2. MemberAccessの場合、型をチェック
        else if (expr.left->kind == HIRExpr::ExprKind::MemberAccess) {
            if (expr.left->type.kind == HIRType::TypeKind::Pointer) {
                is_pointer_arithmetic = true;
            }
        }

        // 3. 型情報が不十分な場合、名前ベースのヒューリスティック
        if (!is_pointer_arithmetic) {
            std::string left_expr_str = generate_expr(*expr.left);

            // 関数呼び出しを最初にチェック（最優先で除外）
            // 括弧があればほぼ関数呼び出し（malloc以外）
            bool has_paren = left_expr_str.find("(") != std::string::npos;
            bool is_malloc = left_expr_str.find("malloc") != std::string::npos;
            bool is_explicit_cast =
                left_expr_str.find("(void*)") != std::string::npos ||
                left_expr_str.find("(char*)") != std::string::npos ||
                left_expr_str.find("(int)") != std::string::npos;

            if (has_paren && !is_malloc && !is_explicit_cast) {
                // 関数呼び出しまたは(*this)などの式
                // ただし、.front/.backは明確にポインタメンバー
                if (left_expr_str.find(".front") != std::string::npos ||
                    left_expr_str.find(".back") != std::string::npos) {
                    is_pointer_arithmetic = true;
                } else {
                    // 関数呼び出しの結果は整数として扱う
                    is_pointer_arithmetic = false;
                }
            }
            // mallocやキャストは明確なポインタ
            else if (is_malloc || is_explicit_cast) {
                is_pointer_arithmetic = true;
            }
            // _ptr, _node, _array などの命名規則
            else if (left_expr_str.find("CB_HIR_current") !=
                     std::string::npos) {
                is_pointer_arithmetic = true;
            } else if ((left_expr_str.find("_ptr") != std::string::npos &&
                        left_expr_str.find("ptr_size") == std::string::npos) ||
                       (left_expr_str.find("_node") != std::string::npos &&
                        left_expr_str.find("node_count") ==
                            std::string::npos) ||
                       (left_expr_str.find("_array") != std::string::npos &&
                        left_expr_str.find("array_size") ==
                            std::string::npos)) {
                is_pointer_arithmetic = true;
            }
            // .front, .back などのポインタメンバー（括弧なしの場合）
            else if (left_expr_str.find(".front") != std::string::npos ||
                     left_expr_str.find(".back") != std::string::npos) {
                is_pointer_arithmetic = true;
            }

            if (is_pointer_arithmetic) {
                // すでに生成した文字列を再利用
                std::string right_expr = generate_expr(*expr.right);
                std::string result = "((void*)((char*)";
                result += left_expr_str;
                result += " " + expr.op + " ";
                result += right_expr;
                result += "))";
                return result;
            }
        } else {
            // 型情報から判定した場合は新たに生成
            std::string left_expr = generate_expr(*expr.left);
            std::string right_expr = generate_expr(*expr.right);

            std::string result = "((void*)((char*)";
            result += left_expr;
            result += " " + expr.op + " ";
            result += right_expr;
            result += "))";
            return result;
        }
    }

    std::string result = "(";
    result += generate_expr(*expr.left);
    result += " " + expr.op + " ";
    result += generate_expr(*expr.right);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_unary_op(const HIRExpr &expr) {
    std::string result = "(";

    // Handle special operators that need conversion
    if (expr.op == "ADDRESS_OF") {
        result += "&";
    } else if (expr.op == "DEREFERENCE") {
        result += "*";
    } else {
        result += expr.op;
    }

    result += generate_expr(*expr.operand);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_function_call(const HIRExpr &expr) {
    // call_function_pointerの特別処理
    if (expr.func_name == "call_function_pointer" &&
        expr.arguments.size() >= 1) {
        // 関数ポインタ呼び出し: ((RetType(*)(Args...))fn_ptr)(args...)
        // ジェネリックコンテキストでは T を使用
        std::string fn_ptr = generate_expr(expr.arguments[0]);
        std::string result = "((int(*)(";

        // ジェネリック型パラメータがあれば使用
        if (!current_generic_params.empty()) {
            for (size_t i = 1; i < expr.arguments.size(); i++) {
                if (i > 1)
                    result += ", ";
                result += current_generic_params[0]; // 全引数を T として扱う
            }
        } else {
            // パラメータ型が不明な場合はvoidに
            for (size_t i = 1; i < expr.arguments.size(); i++) {
                if (i > 1)
                    result += ", ";
                result += "int"; // デフォルトはint
            }
        }

        result += "))" + fn_ptr + ")(";

        // 引数を追加（最初の引数は関数ポインタなのでスキップ）
        for (size_t i = 1; i < expr.arguments.size(); i++) {
            if (i > 1)
                result += ", ";
            result += generate_expr(expr.arguments[i]);
        }

        result += ")";
        return result;
    }

    // FFI関数呼び出しの処理（module.function形式）
    std::string func_name = expr.func_name;
    if (func_name.find('.') != std::string::npos) {
        // module.function -> module_function (ラッパー関数を使用)
        size_t dot_pos = func_name.find('.');
        std::string module = func_name.substr(0, dot_pos);
        std::string function = func_name.substr(dot_pos + 1);
        func_name = module + "_" + function;
    } else {
        func_name = add_hir_prefix(func_name);
    }

    std::string result = func_name;

    // CB_HIR_array_getの場合、ジェネリック型パラメータを明示的に指定
    if (expr.func_name == "array_get" && !current_generic_params.empty()) {
        result += "<" + current_generic_params[0] + ">";
    }

    result += "(";

    for (size_t i = 0; i < expr.arguments.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.arguments[i]);
    }

    result += ")";
    return result;
}

std::string HIRToCpp::generate_method_call(const HIRExpr &expr) {
    // FFI module call check: module.function(args)
    // If receiver is a simple variable (module name), treat as FFI call
    // IMPORTANT: Only treat as FFI if receiver is explicitly a known FFI module
    // For now, we disable this heuristic and rely on explicit FFI syntax
    /*
    if (expr.receiver && expr.receiver->kind == HIRExpr::ExprKind::Variable) {
        // Check if this looks like an FFI call (receiver is module name)
        // FFI modules are typically short lowercase names like 'm', 'c', etc.
        std::string receiver_name = expr.receiver->var_name;

        // If the receiver is not prefixed and looks like a module name,
        // treat as FFI call: module.function -> module_function
        // Skip if receiver name looks like a regular variable (longer names, or has CB_HIR_ prefix)
        if (receiver_name.find("CB_HIR_") == std::string::npos &&
            receiver_name.length() <= 2 &&  // Changed from 3 to 2 - only single letter modules
            std::islower(receiver_name[0])) { // Must start with lowercase
            std::string result = receiver_name + "_" + expr.method_name + "(";
            for (size_t i = 0; i < expr.arguments.size(); i++) {
                if (i > 0)
                    result += ", ";
                result += generate_expr(expr.arguments[i]);
            }
            result += ")";
            return result;
        }
    }
    */

    // Determine if we should use -> or .
    bool use_arrow = expr.is_arrow ||
                     (expr.receiver &&
                      expr.receiver->type.kind == HIRType::TypeKind::Pointer);

    // Also check if the receiver is a variable in the current function's
    // parameters
    if (!use_arrow && expr.receiver &&
        expr.receiver->kind == HIRExpr::ExprKind::Variable) {
        if (!current_function_params.empty()) {
            auto it = current_function_params.find(expr.receiver->var_name);
            if (it != current_function_params.end() &&
                it->second.kind == HIRType::TypeKind::Pointer) {
                use_arrow = true;
            }
        }
    }

    // Generate the receiver expression
    std::string result = generate_expr(*expr.receiver);
    result += (use_arrow ? "->" : ".") + expr.method_name + "(";

    for (size_t i = 0; i < expr.arguments.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.arguments[i]);
    }

    result += ")";
    return result;
}

std::string HIRToCpp::generate_member_access(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.object);
    result += expr.is_arrow ? "->" : ".";
    result += expr.member_name;
    return result;
}

std::string HIRToCpp::generate_array_access(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.array);
    result += "[";
    result += generate_expr(*expr.index);
    result += "]";
    return result;
}

std::string HIRToCpp::generate_cast(const HIRExpr &expr) {
    // キャスト式が空または無効な場合、C形式のキャストにフォールバック
    if (!expr.cast_expr) {
        // キャスト対象がない場合は型のデフォルト値を生成
        // This should not happen in valid code
        std::string type_str = generate_type(expr.cast_type);
        return "/* CAST ERROR: no cast_expr */ " + type_str + "{}";
    }

    std::string cast_value = generate_expr(*expr.cast_expr);

    // 生成された式が空の場合、エラーメッセージを含める
    if (cast_value.empty() || cast_value == "/* unsupported expr */") {
        std::string type_str = generate_type(expr.cast_type);
        // Instead of returning empty {}, use C-style cast with a warning
        return "/* CAST ERROR: empty cast_value */ (" + type_str + ")nullptr";
    }

    // 通常のキャスト - C-style castを使用（互換性のため）
    std::string result = "(";
    result += generate_type(expr.cast_type);
    result += ")";
    result += cast_value;
    return result;
}

std::string HIRToCpp::generate_ternary(const HIRExpr &expr) {
    std::string result = "(";
    result += generate_expr(*expr.condition);
    result += " ? ";
    result += generate_expr(*expr.then_expr);
    result += " : ";
    result += generate_expr(*expr.else_expr);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_lambda(const HIRExpr &expr) {
    std::string result = "[](";

    // パラメータ
    for (size_t i = 0; i < expr.lambda_params.size(); i++) {
        if (i > 0)
            result += ", ";
        const auto &param = expr.lambda_params[i];
        if (param.is_const)
            result += "const ";
        result += generate_type(param.type);
        result += " " + add_hir_prefix(param.name);
    }

    result += ") -> ";
    result += generate_type(expr.lambda_return_type);
    result += " { /* lambda body */ }";

    return result;
}

std::string HIRToCpp::generate_struct_literal(const HIRExpr &expr) {
    std::string result = expr.struct_type_name + "{";

    // Check if we have named fields (designated initializers)
    bool use_named = !expr.field_names.empty() &&
                     expr.field_names.size() == expr.field_values.size();

    for (size_t i = 0; i < expr.field_values.size(); i++) {
        if (i > 0)
            result += ", ";

        if (use_named && !expr.field_names[i].empty()) {
            // C++20 designated initializer: .field = value
            result += "." + expr.field_names[i] + " = ";
        }
        result += generate_expr(expr.field_values[i]);
    }

    result += "}";
    return result;
}

std::string HIRToCpp::generate_array_literal(const HIRExpr &expr) {
    // 多次元配列かどうかチェック（最初の要素がArrayLiteralかどうか）
    bool is_multidim = false;
    if (!expr.array_elements.empty() && 
        expr.array_elements[0].kind == HIRExpr::ExprKind::ArrayLiteral) {
        is_multidim = true;
    }
    
    std::string result = "{";
    
    // 多次元配列の場合、外側の{}を追加
    if (is_multidim) {
        result = "{{";
    }

    for (size_t i = 0; i < expr.array_elements.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.array_elements[i]);
    }

    result += "}";
    
    // 多次元配列の場合、外側の}を追加
    if (is_multidim) {
        result += "}";
    }
    
    return result;
}

std::string HIRToCpp::generate_address_of(const HIRExpr &expr) {
    return "&(" + generate_expr(*expr.operand) + ")";
}

std::string HIRToCpp::generate_dereference(const HIRExpr &expr) {
    return "*(" + generate_expr(*expr.operand) + ")";
}

std::string HIRToCpp::generate_sizeof(const HIRExpr &expr) {
    if (expr.sizeof_expr) {
        return "sizeof(" + generate_expr(*expr.sizeof_expr) + ")";
    } else {
        return "sizeof(" + generate_type(expr.sizeof_type) + ")";
    }
}

std::string HIRToCpp::generate_new(const HIRExpr &expr) {
    std::string result = "new " + generate_type(expr.new_type);

    if (!expr.new_args.empty()) {
        result += "(";
        for (size_t i = 0; i < expr.new_args.size(); i++) {
            if (i > 0)
                result += ", ";
            result += generate_expr(expr.new_args[i]);
        }
        result += ")";
    }

    return result;
}

std::string HIRToCpp::generate_await(const HIRExpr &expr) {
    // Cb's await just accesses the value field of the Future
    return "(" + generate_expr(*expr.operand) + ").value";
}

std::string HIRToCpp::generate_pre_incdec(const HIRExpr &expr) {
    return expr.op + generate_expr(*expr.operand);
}

std::string HIRToCpp::generate_post_incdec(const HIRExpr &expr) {
    return generate_expr(*expr.operand) + expr.op;
}

void HIRToCpp::generate_assert(const HIRStmt &stmt) {
    emit_indent();
    emit("assert(");
    if (stmt.assert_expr) {
        emit(generate_expr(*stmt.assert_expr));
    } else {
        // If no expression, use false to trigger assertion failure
        emit("false && \"assertion failed\"");
    }
    emit(")");
    if (!stmt.assert_message.empty()) {
        emit(" /* " + stmt.assert_message + " */");
    }
    emit(";\n");
}

// === 型の生成 ===

std::string HIRToCpp::generate_type(const HIRType &type) {
    std::string result;
    
    // static修飾子
    if (type.is_static) {
        result += "static ";
    }
    
    // const修飾子（値型の場合）
    if (type.is_const && type.kind != HIRType::TypeKind::Pointer) {
        result += "const ";
    }
    
    // 基本型
    switch (type.kind) {
    case HIRType::TypeKind::Void:
        result += "void";
        break;
    case HIRType::TypeKind::Tiny:
        result += "int8_t";
        break;
    case HIRType::TypeKind::Short:
        result += "int16_t";
        break;
    case HIRType::TypeKind::Int:
        result += "int";
        break;
    case HIRType::TypeKind::Long:
        result += "int64_t";
        break;
    case HIRType::TypeKind::UnsignedTiny:
        result += "uint8_t";
        break;
    case HIRType::TypeKind::UnsignedShort:
        result += "uint16_t";
        break;
    case HIRType::TypeKind::UnsignedInt:
        result += "unsigned";
        break;
    case HIRType::TypeKind::UnsignedLong:
        result += "uint64_t";
        break;
    case HIRType::TypeKind::Char:
        result += "char";
        break;
    case HIRType::TypeKind::String:
        result += "std::string";
        break;
    case HIRType::TypeKind::Bool:
        result += "bool";
        break;
    case HIRType::TypeKind::Float:
        result += "float";
        break;
    case HIRType::TypeKind::Double:
        result += "double";
        break;
    case HIRType::TypeKind::Struct:
    case HIRType::TypeKind::Enum:
    case HIRType::TypeKind::Interface:
        result += type.name;
        break;
    case HIRType::TypeKind::Pointer:
        return generate_pointer_type(type);
    case HIRType::TypeKind::Reference:
        return generate_reference_type(type);
    case HIRType::TypeKind::RvalueReference:
        return generate_rvalue_reference_type(type);
    case HIRType::TypeKind::Array:
        return generate_array_type(type);
    case HIRType::TypeKind::Function:
        return generate_function_type(type);
    case HIRType::TypeKind::Generic:
        result += type.name;
        break;
    case HIRType::TypeKind::Nullptr:
        result += "std::nullptr_t";
        break;
    case HIRType::TypeKind::Unknown:
        // ジェネリック型パラメータがある場合は最初のものを使用
        if (!current_generic_params.empty()) {
            result += current_generic_params[0];
        } else {
            result += "/* unknown type */";
        }
        break;
    default:
        result += "/* unknown type */";
        break;
    }
    
    return result;
}

std::string HIRToCpp::generate_basic_type(const HIRType &type) {
    return generate_type(type);
}

std::string HIRToCpp::generate_pointer_type(const HIRType &type) {
    std::string result;
    
    // const T* (pointer to const)
    if (type.is_pointee_const && type.inner_type) {
        result = "const " + generate_type(*type.inner_type) + "*";
    } else if (type.inner_type) {
        result = generate_type(*type.inner_type) + "*";
    } else if (!type.name.empty()) {
        // If name contains "*", it's already a pointer type with the * in the name
        if (type.name.back() == '*') {
            result = type.name;
        } else {
            result = type.name + "*";
        }
    } else {
        result = "void*";
    }
    
    // T* const (const pointer)
    if (type.is_pointer_const) {
        result += " const";
    }
    
    return result;
}

std::string HIRToCpp::generate_reference_type(const HIRType &type) {
    if (type.inner_type) {
        return generate_type(*type.inner_type) + "&";
    }
    return type.name + "&";
}

std::string HIRToCpp::generate_rvalue_reference_type(const HIRType &type) {
    if (type.inner_type) {
        return generate_type(*type.inner_type) + "&&";
    }
    return type.name + "&&";
}

std::string HIRToCpp::generate_array_type(const HIRType &type) {
    if (!type.inner_type) {
        return "std::vector<int>"; // fallback
    }
    
    // 多次元配列のサポート
    if (!type.array_dimensions.empty()) {
        std::string result = generate_type(*type.inner_type);
        
        // 各次元に対してstd::arrayまたはstd::vectorでラップ
        for (auto it = type.array_dimensions.rbegin(); it != type.array_dimensions.rend(); ++it) {
            int size = *it;
            if (size > 0) {
                // 固定長配列
                result = "std::array<" + result + ", " + std::to_string(size) + ">";
            } else {
                // 動的配列
                result = "std::vector<" + result + ">";
            }
        }
        
        return result;
    }
    
    // 1次元配列（後方互換性）
    if (type.array_size > 0) {
        // 固定長配列
        return "std::array<" + generate_type(*type.inner_type) + ", " +
               std::to_string(type.array_size) + ">";
    } else {
        // 動的配列
        return "std::vector<" + generate_type(*type.inner_type) + ">";
    }
}

std::string HIRToCpp::generate_function_type(const HIRType &type) {
    std::string result = "std::function<";

    if (type.return_type) {
        result += generate_type(*type.return_type);
    } else {
        result += "void";
    }

    result += "(";
    for (size_t i = 0; i < type.param_types.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_type(type.param_types[i]);
    }
    result += ")>";

    return result;
}

// === ユーティリティ ===

std::string HIRToCpp::escape_string(const std::string &str) {
    std::string result;
    for (char c : str) {
        switch (c) {
        case '\n':
            result += "\\n";
            break;
        case '\t':
            result += "\\t";
            break;
        case '\r':
            result += "\\r";
            break;
        case '\\':
            result += "\\\\";
            break;
        case '"':
            result += "\\\"";
            break;
        default:
            result += c;
            break;
        }
    }
    return result;
}

std::string HIRToCpp::remove_outer_parens(const std::string &expr) {
    // Remove outermost parentheses if they wrap the entire expression
    if (expr.size() >= 2 && expr.front() == '(' && expr.back() == ')') {
        // Check if these are matching outermost parentheses
        int depth = 0;
        for (size_t i = 0; i < expr.size() - 1; i++) {
            if (expr[i] == '(')
                depth++;
            else if (expr[i] == ')') {
                depth--;
                if (depth == 0) {
                    // Found closing paren before the end, not outermost
                    return expr;
                }
            }
        }
        // These are outermost parentheses
        return expr.substr(1, expr.size() - 2);
    }
    return expr;
}

std::string
HIRToCpp::mangle_generic_name(const std::string &base_name,
                              const std::vector<HIRType> &generic_args) {
    std::string result = base_name;
    if (!generic_args.empty()) {
        result += "_";
        for (const auto &arg : generic_args) {
            result += generate_type(arg);
        }
    }
    return result;
}

} // namespace codegen
} // namespace cb
