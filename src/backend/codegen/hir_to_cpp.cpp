// v0.14.0: HIR to C++ Transpiler Implementation
// HIRからC++コードを生成するバックエンド

#include "hir_to_cpp.h"
#include "../../common/debug.h"
#include <algorithm>
#include <iostream>
#include <set>

namespace cb {
namespace codegen {

using namespace ir::hir;

HIRToCpp::HIRToCpp() {}

HIRToCpp::~HIRToCpp() {}

// メインの生成関数
std::string HIRToCpp::generate(const HIRProgram &program) {
    debug_msg(DebugMsgId::CODEGEN_CPP_START);
    debug_msg(DebugMsgId::CODEGEN_CPP_PROGRAM,
              static_cast<int>(program.structs.size()),
              static_cast<int>(program.functions.size()));

    output.str("");
    output.clear();
    indent_level = 0;
    current_program = &program; // プログラム参照を保存

    debug_msg(DebugMsgId::CODEGEN_CPP_HEADER);

    // ヘッダーコメント
    emit_line("// Generated by Cb Compiler v0.14.0");
    emit_line("// HIR → C++ Transpiler");
    emit_line("");

    // 必要なインクルード
    emit_line("#include <iostream>");
    emit_line("#include <string>");
    emit_line("#include <sstream>");
    emit_line("#include <memory>");
    emit_line("#include <vector>");
    emit_line("#include <functional>");
    emit_line("#include <variant>   // For union types");
    emit_line("#include <cmath>     // For FFI math functions");
    emit_line("#include <cstdlib>   // For FFI C functions");
    emit_line("#include <cassert>   // For assert statements");
    emit_line("");

    // 標準ライブラリのエイリアス
    emit_line("// Cb standard types");
    emit_line("using string = std::string;");
    emit_line("template<typename T> using vector = std::vector<T>;");
    emit_line("");

    // 組み込み関数のマクロ定義
    emit_line("// Cb built-in functions");
    emit_line("#define println(...) cb_println(__VA_ARGS__)");
    emit_line("#define print(...) cb_print(__VA_ARGS__)");
    emit_line("#define hex(x) cb_hex(x)");
    emit_line("");

    // 組み込み関数の実装
    emit_line("// Built-in function implementations");
    emit_line("template<typename... Args>");
    emit_line("void cb_println(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("    std::cout << std::endl;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename... Args>");
    emit_line("void cb_print(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("}");
    emit_line("");
    emit_line("// Hexadecimal formatting function");
    emit_line("template<typename T>");
    emit_line("std::string cb_hex(T value) {");
    emit_line("    std::stringstream ss;");
    emit_line("    ss << \"0x\" << std::hex << (uintptr_t)value;");
    emit_line("    return ss.str();");
    emit_line("}");
    emit_line("");

    // ヘルパー関数の宣言
    emit_line("// Helper functions for low-level operations");
    emit_line("template<typename T>");
    emit_line("void CB_HIR_array_set(void* ptr, int index, T value) {");
    emit_line("    ((T*)ptr)[index] = value;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename T>");
    emit_line("T CB_HIR_array_get(void* ptr, int index) {");
    emit_line("    return ((T*)ptr)[index];");
    emit_line("}");
    emit_line("");

    // double型専用のヘルパー関数（FFIやstdlib互換性のため）
    emit_line("// Double-specific array helper functions");
    emit_line("inline void CB_HIR_array_set_double(void* ptr, int index, "
              "double value) {");
    emit_line("    ((double*)ptr)[index] = value;");
    emit_line("}");
    emit_line("");
    emit_line("inline double CB_HIR_array_get_double(void* ptr, int index) {");
    emit_line("    return ((double*)ptr)[index];");
    emit_line("}");
    emit_line("");

    // Option and Result types for error handling
    emit_line("// Option<T> type implementation");
    emit_line("template<typename T>");
    emit_line("struct Option {");
    emit_line("    enum class Tag { None, Some };");
    emit_line("    Tag tag;");
    emit_line("    union {");
    emit_line("        char none_placeholder;");
    emit_line("        T some_value;");
    emit_line("    };");
    emit_line("");
    emit_line("    // Constructors");
    emit_line("    Option() : tag(Tag::None), none_placeholder(0) {}");
    emit_line("    Option(T value) : tag(Tag::Some), some_value(value) {}");
    emit_line("");
    emit_line("    // Static constructors");
    emit_line("    static Option Some(T value) { return Option(value); }");
    emit_line("    static Option None() { return Option(); }");
    emit_line("");
    emit_line("    // Check if is Some");
    emit_line("    bool is_some() const { return tag == Tag::Some; }");
    emit_line("    bool is_none() const { return tag == Tag::None; }");
    emit_line("");
    emit_line("    // Destructor");
    emit_line("    ~Option() {");
    emit_line("        if (tag == Tag::Some) {");
    emit_line("            some_value.~T();");
    emit_line("        }");
    emit_line("    }");
    emit_line("};");
    emit_line("");
    emit_line("// None constant for Option");
    emit_line("struct None_t {};");
    emit_line("constexpr None_t None{};");
    emit_line("");

    emit_line("// Result<T, E> type implementation");
    emit_line("template<typename T, typename E>");
    emit_line("struct Result {");
    emit_line("    enum class Tag { Ok, Err };");
    emit_line("    Tag tag;");
    emit_line("    union {");
    emit_line("        T ok_value;");
    emit_line("        E err_value;");
    emit_line("    };");
    emit_line("");
    emit_line("    // Constructors");
    emit_line("    Result(T value) : tag(Tag::Ok), ok_value(value) {}");
    emit_line("    Result(E error, bool) : tag(Tag::Err), err_value(error) {}");
    emit_line("");
    emit_line("    // Static constructors");
    emit_line("    static Result Ok(T value) { return Result(value); }");
    emit_line("    static Result Err(E error) { return Result(error, true); }");
    emit_line("");
    emit_line("    // Check if is Ok or Err");
    emit_line("    bool is_ok() const { return tag == Tag::Ok; }");
    emit_line("    bool is_err() const { return tag == Tag::Err; }");
    emit_line("");
    emit_line("    // Destructor");
    emit_line("    ~Result() {");
    emit_line("        if (tag == Tag::Ok) {");
    emit_line("            ok_value.~T();");
    emit_line("        } else {");
    emit_line("            err_value.~E();");
    emit_line("        }");
    emit_line("    }");
    emit_line("};");
    emit_line("");

    emit_line("// Helper for string interpolation - converts value to string");
    emit_line("template<typename T>");
    emit_line("std::string CB_HIR_to_string_helper(const T& value) {");
    emit_line("    if constexpr (std::is_same_v<T, std::string>) {");
    emit_line("        return value;");
    emit_line("    } else {");
    emit_line("        return std::to_string(value);");
    emit_line("    }");
    emit_line("}");
    emit_line("");
    emit_line(
        "// Specialization for std::variant - uses std::visit to convert");
    emit_line("template<typename... Ts>");
    emit_line("std::string CB_HIR_to_string_helper(const std::variant<Ts...>& "
              "value) {");
    emit_line("    return std::visit([](const auto& v) -> std::string {");
    emit_line("        using T = std::decay_t<decltype(v)>;");
    emit_line("        if constexpr (std::is_same_v<T, std::string>) {");
    emit_line("            return v;");
    emit_line("        } else if constexpr (std::is_same_v<T, bool>) {");
    emit_line("            return v ? \"true\" : \"false\";");
    emit_line("        } else if constexpr (std::is_same_v<T, char>) {");
    emit_line("            return std::string(1, v);");
    emit_line("        } else if constexpr (std::is_arithmetic_v<T>) {");
    emit_line("            return std::to_string(v);");
    emit_line("        } else {");
    emit_line("            return \"[complex type]\";");
    emit_line("        }");
    emit_line("    }, value);");
    emit_line("}");
    emit_line("");

    // インポート処理
    generate_imports(program);

    // Typedef
    generate_typedefs(program.typedefs);

    // FFI関数宣言
    generate_foreign_functions(program.foreign_functions);

    // 前方宣言
    generate_forward_declarations(program);

    // Enum定義
    generate_enums(program.enums);

    // Union定義
    generate_unions(program.unions);

    // インターフェース定義（抽象クラスとして）- 構造体の前に配置
    generate_interfaces(program.interfaces);

    // 構造体定義
    generate_structs(program.structs);

    // グローバル変数
    generate_global_vars(program.global_vars);

    // 関数定義
    generate_functions(program.functions);

    // Impl定義（メソッド実装）
    generate_impls(program.impls);

    // プリミティブ型のModel特殊化を生成
    generate_primitive_type_specializations(program);

    std::string result = output.str();
    int line_count = std::count(result.begin(), result.end(), '\n');
    debug_msg(DebugMsgId::CODEGEN_CPP_COMPLETE, line_count);

    return result;
}

// === ヘルパーメソッド ===

void HIRToCpp::emit(const std::string &code) { output << code; }

void HIRToCpp::emit_line(const std::string &code) {
    emit_indent();
    output << code << "\n";
}

void HIRToCpp::emit_indent() {
    for (int i = 0; i < indent_level; i++) {
        output << "    ";
    }
}

void HIRToCpp::increase_indent() { indent_level++; }

void HIRToCpp::decrease_indent() {
    if (indent_level > 0) {
        indent_level--;
    }
}

// v0.14.0: HIR変数名にプレフィックスを追加して名前衝突を防ぐ
std::string HIRToCpp::add_hir_prefix(const std::string &name) {
    // 既にプレフィックスが付いている場合はそのまま返す
    if (name.find("CB_HIR_") == 0) {
        return name;
    }
    // main関数は特別扱い
    if (name == "main") {
        return name;
    }
    // 破棄変数(_)は毎回ユニークな名前を生成
    if (name == "_") {
        return "CB_HIR__discard_" + std::to_string(discard_variable_counter++);
    }
    // 修飾名(::を含む)はそのまま返す
    if (name.find("::") != std::string::npos) {
        return name;
    }
    // 組み込み関数やC++標準ライブラリの関数はプレフィックスを付けない
    if (name == "println" || name == "print" || name == "std" ||
        name == "assert" || name == "sizeof" || name == "malloc" ||
        name == "free" || name == "realloc" || name == "memcpy" ||
        name == "memset" || name == "memmove" || name == "strlen" ||
        name == "strcpy" || name == "strcmp" || name == "printf" ||
        name == "fprintf" || name == "sprintf" || name == "abs" ||
        name == "sqrt" || name == "pow" || name == "sin" || name == "cos" ||
        name == "tan") {
        return name;
    }
    return "CB_HIR_" + name;
}

// 多次元配列のベース型と次元を取得
void HIRToCpp::get_array_base_type_and_dimensions(
    const HIRType &type, const HIRType **base_type,
    std::vector<int> &dimensions) {
    if (type.kind == HIRType::TypeKind::Array) {
        dimensions.push_back(type.array_size);
        if (type.inner_type &&
            type.inner_type->kind == HIRType::TypeKind::Array) {
            // 再帰的に内側の配列を処理
            get_array_base_type_and_dimensions(*type.inner_type, base_type,
                                               dimensions);
        } else if (type.inner_type) {
            *base_type = type.inner_type.get();
        }
    } else {
        *base_type = &type;
    }
}

// 多次元配列の次元文字列を生成（例: "[2][3][4]"）
std::string HIRToCpp::generate_array_dimensions(const HIRType &type) {
    const HIRType *base_type = nullptr;
    std::vector<int> dimensions;
    get_array_base_type_and_dimensions(type, &base_type, dimensions);

    std::string result;
    for (int dim : dimensions) {
        if (dim > 0) {
            result += "[" + std::to_string(dim) + "]";
        } else if (dim == -1) {
            // VLA - use the name stored in the type
            result += "[" + add_hir_prefix(type.name) + "]";
        }
    }
    return result;
}

// === トップレベル定義の生成 ===

// === 個別の定義生成 ===

// === 文の生成 ===

// v0.14.0: OR式から値を再帰的に収集するヘルパー関数

// === 式の生成 ===

// === 型の生成 ===

// === ユーティリティ ===

std::string HIRToCpp::escape_string(const std::string &str) {
    std::string result;
    for (char c : str) {
        switch (c) {
        case '\n':
            result += "\\n";
            break;
        case '\t':
            result += "\\t";
            break;
        case '\r':
            result += "\\r";
            break;
        case '\\':
            result += "\\\\";
            break;
        case '"':
            result += "\\\"";
            break;
        default:
            result += c;
            break;
        }
    }
    return result;
}

std::string HIRToCpp::remove_outer_parens(const std::string &expr) {
    // Remove outermost parentheses if they wrap the entire expression
    if (expr.size() >= 2 && expr.front() == '(' && expr.back() == ')') {
        // Check if these are matching outermost parentheses
        int depth = 0;
        for (size_t i = 0; i < expr.size() - 1; i++) {
            if (expr[i] == '(')
                depth++;
            else if (expr[i] == ')') {
                depth--;
                if (depth == 0) {
                    // Found closing paren before the end, not outermost
                    return expr;
                }
            }
        }
        // These are outermost parentheses
        return expr.substr(1, expr.size() - 2);
    }
    return expr;
}

std::string
HIRToCpp::mangle_generic_name(const std::string &base_name,
                              const std::vector<HIRType> &generic_args) {
    std::string result = base_name;
    if (!generic_args.empty()) {
        result += "_";
        for (const auto &arg : generic_args) {
            result += generate_type(arg);
        }
    }
    return result;
}

} // namespace codegen
} // namespace cb
