// v0.14.0: HIR to C++ Transpiler Implementation
// HIRからC++コードを生成するバックエンド

#include "hir_to_cpp.h"
#include <algorithm>
#include <iostream>
#include <set>

namespace cb {
namespace codegen {

using namespace ir::hir;

HIRToCpp::HIRToCpp() {}

HIRToCpp::~HIRToCpp() {}

// メインの生成関数
std::string HIRToCpp::generate(const HIRProgram &program) {
    output.str("");
    output.clear();
    indent_level = 0;
    current_program = &program; // プログラム参照を保存

    // ヘッダーコメント
    emit_line("// Generated by Cb Compiler v0.14.0");
    emit_line("// HIR → C++ Transpiler");
    emit_line("");

    // 必要なインクルード
    emit_line("#include <iostream>");
    emit_line("#include <string>");
    emit_line("#include <memory>");
    emit_line("#include <vector>");
    emit_line("#include <functional>");
    emit_line("#include <cmath>     // For FFI math functions");
    emit_line("#include <cstdlib>   // For FFI C functions");
    emit_line("#include <cassert>   // For assert statements");
    emit_line("");

    // 標準ライブラリのエイリアス
    emit_line("// Cb standard types");
    emit_line("using string = std::string;");
    emit_line("template<typename T> using vector = std::vector<T>;");
    emit_line("");

    // 組み込み関数のマクロ定義
    emit_line("// Cb built-in functions");
    emit_line("#define println(...) cb_println(__VA_ARGS__)");
    emit_line("#define print(...) cb_print(__VA_ARGS__)");
    emit_line("");

    // 組み込み関数の実装
    emit_line("// Built-in function implementations");
    emit_line("template<typename... Args>");
    emit_line("void cb_println(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("    std::cout << std::endl;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename... Args>");
    emit_line("void cb_print(Args... args) {");
    emit_line("    ((std::cout << args << \" \"), ...);");
    emit_line("}");
    emit_line("");

    // ヘルパー関数の宣言
    emit_line("// Helper functions for low-level operations");
    emit_line("template<typename T>");
    emit_line("void CB_HIR_array_set(void* ptr, int index, T value) {");
    emit_line("    ((T*)ptr)[index] = value;");
    emit_line("}");
    emit_line("");
    emit_line("template<typename T>");
    emit_line("T CB_HIR_array_get(void* ptr, int index) {");
    emit_line("    return ((T*)ptr)[index];");
    emit_line("}");
    emit_line("");

    // インポート処理
    generate_imports(program);

    // Typedef
    generate_typedefs(program.typedefs);

    // FFI関数宣言
    generate_foreign_functions(program.foreign_functions);

    // 前方宣言
    generate_forward_declarations(program);

    // Enum定義
    generate_enums(program.enums);

    // インターフェース定義（抽象クラスとして）- 構造体の前に配置
    generate_interfaces(program.interfaces);

    // 構造体定義
    generate_structs(program.structs);

    // グローバル変数
    generate_global_vars(program.global_vars);

    // 関数定義
    generate_functions(program.functions);

    // Impl定義（メソッド実装）
    generate_impls(program.impls);

    return output.str();
}

// === ヘルパーメソッド ===

void HIRToCpp::emit(const std::string &code) { output << code; }

void HIRToCpp::emit_line(const std::string &code) {
    emit_indent();
    output << code << "\n";
}

void HIRToCpp::emit_indent() {
    for (int i = 0; i < indent_level; i++) {
        output << "    ";
    }
}

void HIRToCpp::increase_indent() { indent_level++; }

void HIRToCpp::decrease_indent() {
    if (indent_level > 0) {
        indent_level--;
    }
}

// v0.14.0: HIR変数名にプレフィックスを追加して名前衝突を防ぐ
std::string HIRToCpp::add_hir_prefix(const std::string &name) {
    // 既にプレフィックスが付いている場合はそのまま返す
    if (name.find("CB_HIR_") == 0) {
        return name;
    }
    // main関数は特別扱い
    if (name == "main") {
        return name;
    }
    // 修飾名(::を含む)はそのまま返す
    if (name.find("::") != std::string::npos) {
        return name;
    }
    // 組み込み関数やC++標準ライブラリの関数はプレフィックスを付けない
    if (name == "println" || name == "print" || name == "std" ||
        name == "assert" || name == "sizeof" || name == "malloc" ||
        name == "free" || name == "realloc" || name == "memcpy" ||
        name == "memset" || name == "memmove" || name == "strlen" ||
        name == "strcpy" || name == "strcmp" || name == "printf" ||
        name == "fprintf" || name == "sprintf" || name == "abs" ||
        name == "sqrt" || name == "pow" || name == "sin" || name == "cos" ||
        name == "tan") {
        return name;
    }
    return "CB_HIR_" + name;
}

// === トップレベル定義の生成 ===

void HIRToCpp::generate_imports(const HIRProgram &program) {
    if (program.imports.empty()) {
        return;
    }

    emit_line("// Imports");
    for (const auto &import : program.imports) {
        emit_line("// import " + import.module_path);
    }
    emit_line("");
}

void HIRToCpp::generate_typedefs(const std::vector<HIRTypedef> &typedefs) {
    if (typedefs.empty()) {
        return;
    }

    emit_line("// Type aliases");
    for (const auto &typedef_def : typedefs) {
        emit("using " + typedef_def.name + " = ");
        emit(generate_type(typedef_def.target_type));
        emit(";\n");
    }
    emit_line("");
}

void HIRToCpp::generate_foreign_functions(
    const std::vector<HIRForeignFunction> &foreign_funcs) {
    if (foreign_funcs.empty()) {
        return;
    }

    emit_line("// FFI (Foreign Function Interface) declarations");
    emit_line("extern \"C\" {");
    increase_indent();

    for (const auto &ffi : foreign_funcs) {
        emit_indent();
        emit(generate_type(ffi.return_type));
        emit(" " + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = ffi.parameters[i];
            emit(generate_type(param.type));
            if (!param.name.empty()) {
                emit(" " + param.name);
            }
        }

        emit(");\n");
    }

    decrease_indent();
    emit_line("}");
    emit_line("");

    // FFI関数のラッパー生成（モジュール修飾名対応）
    emit_line("// FFI wrapper functions (for qualified calls)");
    for (const auto &ffi : foreign_funcs) {
        emit_indent();
        emit("inline ");
        emit(generate_type(ffi.return_type));
        emit(" " + ffi.module_name + "_" + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = ffi.parameters[i];
            emit(generate_type(param.type));
            emit(" " + param.name);
        }

        emit(") { return " + ffi.function_name + "(");

        for (size_t i = 0; i < ffi.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            emit(ffi.parameters[i].name);
        }

        emit("); }\n");
    }
    emit_line("");
}

void HIRToCpp::generate_forward_declarations(const HIRProgram &program) {
    if (program.structs.empty() && program.interfaces.empty()) {
        return;
    }

    emit_line("// Forward declarations");

    for (const auto &struct_def : program.structs) {
        // Handle generic structs
        if (!struct_def.generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < struct_def.generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + struct_def.generic_params[i]);
            }
            emit("> ");
        }
        emit_line("struct " + struct_def.name + ";");
    }

    for (const auto &interface : program.interfaces) {
        // Handle generic interfaces
        if (!interface.generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < interface.generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + interface.generic_params[i]);
            }
            emit("> ");
        }
        emit_line("class " + interface.name + ";");
    }

    emit_line("");
}

void HIRToCpp::generate_structs(const std::vector<HIRStruct> &structs) {
    for (const auto &struct_def : structs) {
        generate_struct(struct_def);
    }
}

void HIRToCpp::generate_enums(const std::vector<HIREnum> &enums) {
    for (const auto &enum_def : enums) {
        generate_enum(enum_def);
    }
}

void HIRToCpp::generate_interfaces(
    const std::vector<HIRInterface> &interfaces) {
    for (const auto &interface : interfaces) {
        emit_line("// Interface: " + interface.name);

        // Add template parameters if generic
        if (!interface.generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < interface.generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + interface.generic_params[i]);
            }
            emit(">\n");
        }

        emit_line("class " + interface.name + " {");
        emit_line("public:");
        increase_indent();

        emit_line("virtual ~" + interface.name + "() = default;");
        emit_line("");

        for (const auto &method : interface.methods) {
            emit("virtual ");
            emit(generate_type(method.return_type));
            emit(" " + method.name + "(");

            for (size_t i = 0; i < method.parameters.size(); i++) {
                if (i > 0)
                    emit(", ");
                const auto &param = method.parameters[i];
                if (param.is_const)
                    emit("const ");
                std::string param_type = generate_type(param.type);
                emit(param_type);
                emit(" " + param.name);
            }

            emit(") = 0;\n");
        }

        decrease_indent();
        emit_line("};");
        emit_line("");
    }
}

void HIRToCpp::generate_global_vars(const std::vector<HIRGlobalVar> &globals) {
    if (globals.empty()) {
        return;
    }

    emit_line("// Global variables");
    for (const auto &global : globals) {
        if (global.is_const)
            emit("const ");
        emit(generate_type(global.type));
        emit(" " + add_hir_prefix(global.name));

        if (global.init_expr) {
            emit(" = ");
            emit(generate_expr(*global.init_expr));
        }

        emit(";\n");
    }
    emit_line("");
}

void HIRToCpp::generate_functions(const std::vector<HIRFunction> &functions) {
    for (const auto &func : functions) {
        generate_function(func);
    }
}

void HIRToCpp::generate_impls(const std::vector<HIRImpl> &impls) {
    for (const auto &impl : impls) {
        generate_impl(impl);
    }
}

// === 個別の定義生成 ===

void HIRToCpp::generate_struct(const HIRStruct &struct_def) {
    emit_line("// Struct: " + struct_def.name);

    // ジェネリック対応
    if (!struct_def.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < struct_def.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + struct_def.generic_params[i]);
        }
        emit(">\n");
    }

    // Check if this struct implements any interfaces
    std::vector<std::string> implemented_interfaces;
    std::vector<const HIRImpl *> struct_impls;

    if (current_program && !current_program->impls.empty()) {
        for (const auto &impl : current_program->impls) {
            // Extract base name from impl.struct_name (e.g., "Vector<T>" ->
            // "Vector")
            std::string impl_base_name = impl.struct_name;
            size_t angle_pos = impl_base_name.find('<');
            if (angle_pos != std::string::npos) {
                impl_base_name = impl_base_name.substr(0, angle_pos);
            }

            if (impl_base_name == struct_def.name) {
                struct_impls.push_back(&impl);
                if (!impl.interface_name.empty()) {
                    // Extract base name from impl.interface_name
                    std::string interface_base = impl.interface_name;
                    size_t iface_angle = interface_base.find('<');
                    if (iface_angle != std::string::npos) {
                        interface_base = interface_base.substr(0, iface_angle);
                    }

                    // Build interface name with template parameters
                    std::string interface_ref = interface_base;
                    if (!struct_def.generic_params.empty()) {
                        interface_ref += "<";
                        for (size_t i = 0; i < struct_def.generic_params.size();
                             i++) {
                            if (i > 0)
                                interface_ref += ", ";
                            interface_ref += struct_def.generic_params[i];
                        }
                        interface_ref += ">";
                    }
                    // Check for duplicates
                    if (std::find(implemented_interfaces.begin(),
                                  implemented_interfaces.end(),
                                  interface_ref) ==
                        implemented_interfaces.end()) {
                        implemented_interfaces.push_back(interface_ref);
                    }
                }
            }
        }
    }

    // Struct declaration with interface inheritance
    emit("struct " + struct_def.name);
    if (!implemented_interfaces.empty()) {
        emit(" : ");
        for (size_t i = 0; i < implemented_interfaces.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("public " + implemented_interfaces[i]);
        }
    }
    emit(" {\n");

    // フィールド
    if (!struct_def.fields.empty()) {
        for (const auto &field : struct_def.fields) {
            emit_indent();
            if (field.is_private) {
                // TODO: privateフィールドのサポート
            }
            emit(generate_type(field.type));
            emit(" " + field.name + ";\n");
        }
    }

    // Add method declarations from impls
    std::set<std::string>
        declared_methods; // Track declared methods to avoid duplicates
    if (!struct_impls.empty()) {
        // Find the corresponding interface for type lookup
        const HIRInterface *interface_ptr = nullptr;
        if (current_program && !implemented_interfaces.empty()) {
            std::string interface_base = implemented_interfaces[0];
            size_t angle = interface_base.find('<');
            if (angle != std::string::npos) {
                interface_base = interface_base.substr(0, angle);
            }
            for (const auto &iface : current_program->interfaces) {
                if (iface.name == interface_base) {
                    interface_ptr = &iface;
                    break;
                }
            }
        }

        for (const auto *impl_ptr : struct_impls) {
            if (!impl_ptr->methods.empty()) {
                emit_line("");
                emit_line("// Methods");
                for (const auto &method : impl_ptr->methods) {
                    // Try to find corresponding interface method for correct
                    // types
                    const HIRInterface::MethodSignature *interface_method =
                        nullptr;
                    if (interface_ptr) {
                        for (const auto &iface_method :
                             interface_ptr->methods) {
                            if (iface_method.name == method.name) {
                                interface_method = &iface_method;
                                break;
                            }
                        }
                    }

                    // Create method signature to check for duplicates
                    std::string method_sig = method.name + "(";
                    for (size_t i = 0; i < method.parameters.size(); i++) {
                        if (i > 0)
                            method_sig += ",";
                        method_sig += generate_type(method.parameters[i].type);
                    }
                    method_sig += ")";

                    // Skip if already declared
                    if (declared_methods.find(method_sig) !=
                        declared_methods.end()) {
                        continue;
                    }
                    declared_methods.insert(method_sig);

                    emit_indent();
                    // Use interface return type if available, otherwise impl's
                    std::string return_type;
                    if (interface_method) {
                        return_type =
                            generate_type(interface_method->return_type);
                    } else {
                        return_type = generate_type(method.return_type);
                    }
                    emit(return_type);
                    emit(" " + method.name + "(");

                    for (size_t i = 0; i < method.parameters.size(); i++) {
                        if (i > 0)
                            emit(", ");
                        const auto &param = method.parameters[i];
                        if (param.is_const)
                            emit("const ");

                        // Use interface parameter type if available, otherwise
                        // impl's
                        std::string param_type;
                        if (interface_method &&
                            i < interface_method->parameters.size()) {
                            param_type = generate_type(
                                interface_method->parameters[i].type);
                        } else {
                            param_type = generate_type(param.type);
                        }
                        emit(param_type);
                        emit(" " +
                             param.name); // Don't add prefix to parameters
                    }

                    emit(")");
                    // Only add override if this method exists in the interface
                    if (!impl_ptr->interface_name.empty() && interface_method) {
                        emit(" override");
                    }
                    emit(";\n");
                }
            }
        }
    }

    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_enum(const HIREnum &enum_def) {
    emit_line("// Enum: " + enum_def.name);
    emit_line("enum class " + enum_def.name + " {");
    increase_indent();

    for (size_t i = 0; i < enum_def.variants.size(); i++) {
        const auto &variant = enum_def.variants[i];
        emit_indent();
        emit(variant.name);
        emit(" = " + std::to_string(variant.value));
        if (i < enum_def.variants.size() - 1) {
            emit(",");
        }
        emit("\n");
    }

    decrease_indent();
    emit_line("};");
    emit_line("");
}

void HIRToCpp::generate_function(const HIRFunction &func) {
    emit_line("// Function: " + func.name);

    // ジェネリック対応
    if (!func.generic_params.empty()) {
        emit("template<");
        for (size_t i = 0; i < func.generic_params.size(); i++) {
            if (i > 0)
                emit(", ");
            emit("typename " + func.generic_params[i]);
        }
        emit(">\n");
    }

    // 戻り値の型
    emit_indent();
    // main関数は常にintを返す
    if (func.name == "main") {
        emit("int");
    } else {
        emit(generate_type(func.return_type));
    }
    emit(" " + add_hir_prefix(func.name) + "(");

    // パラメータ
    for (size_t i = 0; i < func.parameters.size(); i++) {
        if (i > 0)
            emit(", ");
        const auto &param = func.parameters[i];
        if (param.is_const)
            emit("const ");
        emit(generate_type(param.type));
        emit(" " + add_hir_prefix(param.name));
    }

    emit(") {\n");

    // 関数パラメータの型を記録（ポインタアクセス判定用）
    current_function_params.clear();
    for (const auto &param : func.parameters) {
        current_function_params[param.name] = param.type;
    }

    // 現在の関数の情報を記録（async関数のreturn文処理用）
    // Check if return type is Future<T> by checking the type name
    current_function_is_async =
        (func.return_type.kind == HIRType::TypeKind::Struct &&
         func.return_type.name.find("Future<") == 0);
    current_function_return_type = func.return_type;

    // 関数本体
    if (func.body) {
        increase_indent();
        generate_stmt(*func.body);
        decrease_indent();
    }

    emit_line("}");
    emit_line("");

    // パラメータマップをクリア
    current_function_params.clear();
}

void HIRToCpp::generate_impl(const HIRImpl &impl) {
    emit_line("// Impl for: " + impl.struct_name);

    if (!impl.interface_name.empty()) {
        emit_line("// implements: " + impl.interface_name);
    }

    // メソッドを生成（メソッド名にstruct名をプレフィックス）
    for (const auto &method : impl.methods) {
        emit_line("// Method: " + method.name);

        // ジェネリック対応: implのgeneric_paramsかmethodのgeneric_paramsを使う
        std::vector<std::string> generic_params = impl.generic_params;
        if (!method.generic_params.empty()) {
            generic_params = method.generic_params;
        }

        // If generic_params is empty but struct_name contains <T>, extract it
        if (generic_params.empty() &&
            impl.struct_name.find('<') != std::string::npos) {
            size_t start = impl.struct_name.find('<');
            size_t end = impl.struct_name.find('>');
            if (start != std::string::npos && end != std::string::npos &&
                end > start) {
                std::string params_str =
                    impl.struct_name.substr(start + 1, end - start - 1);
                // カンマで分割して複数のパラメータに対応
                size_t pos = 0;
                while (pos < params_str.length()) {
                    size_t comma_pos = params_str.find(',', pos);
                    if (comma_pos == std::string::npos) {
                        // 最後のパラメータ
                        std::string param = params_str.substr(pos);
                        // 前後の空白を削除
                        size_t first = param.find_first_not_of(' ');
                        size_t last = param.find_last_not_of(' ');
                        if (first != std::string::npos) {
                            generic_params.push_back(
                                param.substr(first, last - first + 1));
                        }
                        break;
                    } else {
                        std::string param =
                            params_str.substr(pos, comma_pos - pos);
                        // 前後の空白を削除
                        size_t first = param.find_first_not_of(' ');
                        size_t last = param.find_last_not_of(' ');
                        if (first != std::string::npos) {
                            generic_params.push_back(
                                param.substr(first, last - first + 1));
                        }
                        pos = comma_pos + 1;
                    }
                }
            }
        }

        if (!generic_params.empty()) {
            emit("template<");
            for (size_t i = 0; i < generic_params.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("typename " + generic_params[i]);
            }
            emit(">\n");
        }

        // 戻り値の型
        emit_indent();
        emit(generate_type(method.return_type));
        emit(" " + impl.struct_name + "::" + method.name + "(");

        // パラメータ - ジェネリック型の場合は型パラメータ名を使用
        for (size_t i = 0; i < method.parameters.size(); i++) {
            if (i > 0)
                emit(", ");
            const auto &param = method.parameters[i];
            if (param.is_const)
                emit("const ");

            // 型がUnknownの場合で、ジェネリックパラメータがある場合は、それを使用
            std::string param_type;
            if (param.type.kind == HIRType::TypeKind::Unknown &&
                !generic_params.empty()) {
                // 最初のジェネリックパラメータをデフォルトで使用
                param_type = generic_params[0];
            } else if (param.type.kind == HIRType::TypeKind::Generic) {
                // Generic型の場合は型名をそのまま使用
                param_type = param.type.name;
            } else {
                param_type = generate_type(param.type);
            }

            emit(param_type);
            emit(" " + add_hir_prefix(param.name));
        }

        emit(") {\n");

        // ジェネリックパラメータをコンテキストに設定
        current_generic_params = generic_params;

        // 関数本体
        if (method.body) {
            increase_indent();
            generate_stmt(*method.body);
            decrease_indent();
        }

        // コンテキストをクリア
        current_generic_params.clear();

        emit_line("}");
        emit_line("");
    }
}

// === 文の生成 ===

void HIRToCpp::generate_stmt(const HIRStmt &stmt) {
    switch (stmt.kind) {
    case HIRStmt::StmtKind::VarDecl:
        generate_var_decl(stmt);
        break;
    case HIRStmt::StmtKind::Assignment:
        generate_assignment(stmt);
        break;
    case HIRStmt::StmtKind::ExprStmt:
        emit_indent();
        emit(generate_expr(*stmt.expr));
        emit(";\n");
        break;
    case HIRStmt::StmtKind::If:
        generate_if(stmt);
        break;
    case HIRStmt::StmtKind::While:
        generate_while(stmt);
        break;
    case HIRStmt::StmtKind::For:
        generate_for(stmt);
        break;
    case HIRStmt::StmtKind::Return:
        generate_return(stmt);
        break;
    case HIRStmt::StmtKind::Break:
        emit_line("break;");
        break;
    case HIRStmt::StmtKind::Continue:
        emit_line("continue;");
        break;
    case HIRStmt::StmtKind::Block:
        generate_block(stmt);
        break;
    case HIRStmt::StmtKind::Switch:
        generate_switch(stmt);
        break;
    case HIRStmt::StmtKind::Defer:
        generate_defer(stmt);
        break;
    case HIRStmt::StmtKind::Delete:
        generate_delete(stmt);
        break;
    case HIRStmt::StmtKind::Try:
        generate_try_catch(stmt);
        break;
    case HIRStmt::StmtKind::Throw:
        emit_indent();
        emit("throw ");
        if (stmt.throw_expr) {
            emit(generate_expr(*stmt.throw_expr));
        }
        emit(";\n");
        break;
    case HIRStmt::StmtKind::Assert:
        generate_assert(stmt);
        break;
    default:
        emit_line("// TODO: Unsupported statement");
        break;
    }
}

void HIRToCpp::generate_var_decl(const HIRStmt &stmt) {
    emit_indent();
    if (stmt.is_const) {
        emit("const ");
    }
    emit(generate_type(stmt.var_type));
    emit(" " + add_hir_prefix(stmt.var_name));

    if (stmt.init_expr) {
        emit(" = ");

        // Type-based cast insertion
        std::string var_type_str = generate_type(stmt.var_type);
        std::string init_expr_str = generate_expr(*stmt.init_expr);

        // void**への代入の場合、キャストを追加
        if (var_type_str == "void**") {
            emit("(void**)");
        }
        // int64_tなど整数型への代入で、式がvoid*キャストを含む場合
        else if ((var_type_str == "int64_t" || var_type_str == "long long" ||
                  var_type_str == "int" || var_type_str == "long") &&
                 init_expr_str.find("(void*)") != std::string::npos) {
            // void*からの変換が必要な場合、明示的にキャスト
            emit("(" + var_type_str + ")");
        }

        emit(init_expr_str);
    }

    emit(";\n");
}

void HIRToCpp::generate_assignment(const HIRStmt &stmt) {
    emit_indent();
    emit(generate_expr(*stmt.lhs));
    emit(" = ");
    emit(generate_expr(*stmt.rhs));
    emit(";\n");
}

void HIRToCpp::generate_if(const HIRStmt &stmt) {
    emit_indent();
    emit("if (");
    emit(generate_expr(*stmt.condition));
    emit(") {\n");

    increase_indent();
    if (stmt.then_body) {
        generate_stmt(*stmt.then_body);
    }
    decrease_indent();

    if (stmt.else_body) {
        emit_line("} else {");
        increase_indent();
        generate_stmt(*stmt.else_body);
        decrease_indent();
    }

    emit_line("}");
}

void HIRToCpp::generate_while(const HIRStmt &stmt) {
    emit_indent();
    emit("while (");
    emit(generate_expr(*stmt.condition));
    emit(") {\n");

    increase_indent();
    if (stmt.body) {
        generate_stmt(*stmt.body);
    }
    decrease_indent();

    emit_line("}");
}

void HIRToCpp::generate_for(const HIRStmt &stmt) {
    emit_indent();
    emit("for (");

    // init
    if (stmt.init) {
        // セミコロンなしで生成
        if (stmt.init->kind == HIRStmt::StmtKind::VarDecl) {
            if (stmt.init->is_const)
                emit("const ");
            emit(generate_type(stmt.init->var_type));
            emit(" " + add_hir_prefix(stmt.init->var_name));
            if (stmt.init->init_expr) {
                emit(" = ");
                emit(generate_expr(*stmt.init->init_expr));
            }
        } else if (stmt.init->kind == HIRStmt::StmtKind::Assignment) {
            if (stmt.init->lhs && stmt.init->rhs) {
                emit(generate_expr(*stmt.init->lhs));
                emit(" = ");
                emit(generate_expr(*stmt.init->rhs));
            }
        } else if (stmt.init->kind == HIRStmt::StmtKind::ExprStmt) {
            if (stmt.init->expr) {
                emit(generate_expr(*stmt.init->expr));
            }
        }
    }
    emit("; ");

    // condition
    if (stmt.condition) {
        emit(generate_expr(*stmt.condition));
    }
    emit("; ");

    // update
    if (stmt.update) {
        if (stmt.update->kind == HIRStmt::StmtKind::Assignment) {
            if (stmt.update->lhs && stmt.update->rhs) {
                emit(generate_expr(*stmt.update->lhs));
                emit(" = ");
                emit(generate_expr(*stmt.update->rhs));
            }
        } else if (stmt.update->kind == HIRStmt::StmtKind::ExprStmt) {
            if (stmt.update->expr) {
                emit(generate_expr(*stmt.update->expr));
            }
        }
    }

    emit(") {\n");

    increase_indent();
    if (stmt.body) {
        generate_stmt(*stmt.body);
    }
    decrease_indent();

    emit_line("}");
}

void HIRToCpp::generate_return(const HIRStmt &stmt) {
    if (current_function_is_async && stmt.return_expr) {
        // async関数の場合、Future<T>を構築して返す
        // Extract inner type from Future<T>
        std::string inner_type = "int"; // default
        if (current_function_return_type.kind == HIRType::TypeKind::Struct &&
            current_function_return_type.name.find("Future<") == 0) {
            size_t start = current_function_return_type.name.find('<');
            size_t end = current_function_return_type.name.rfind('>');
            if (start != std::string::npos && end != std::string::npos &&
                end > start) {
                inner_type = current_function_return_type.name.substr(
                    start + 1, end - start - 1);
            }
        }

        emit_indent();
        emit("{\n");
        increase_indent();
        emit_indent();
        emit(generate_type(current_function_return_type));
        emit(" __future;\n");
        emit_indent();
        emit("__future.value = ");
        emit(generate_expr(*stmt.return_expr));
        emit(";\n");
        emit_indent();
        emit("__future.is_ready = true;\n");
        emit_indent();
        emit("return __future;\n");
        decrease_indent();
        emit_indent();
        emit("}\n");
    } else {
        // 通常の関数
        emit_indent();
        emit("return");
        if (stmt.return_expr) {
            std::string return_expr_str = generate_expr(*stmt.return_expr);

            emit(" ");
            // void*式を含む場合、reinterpret_castを使用
            // これはvoid*をint等に変換する際の型エラーを防ぐ
            if (return_expr_str.find("(void*)") != std::string::npos) {
                // void*を含む式は、通常ポインタ演算の結果
                // intptr_t経由で安全にキャスト
                emit("(intptr_t)(");
                emit(return_expr_str);
                emit(")");
            } else {
                emit(return_expr_str);
            }
        }
        emit(";\n");
    }
}

void HIRToCpp::generate_block(const HIRStmt &stmt) {
    // デバッグ: ブロック内の文の種類を確認
    if (stmt.block_stmts.empty()) {
        // 空のブロックの場合は何も出力しない（ただし、デバッグのためコメントを残す）
        emit_line("// Empty block");
        return;
    }

    // 変数宣言のみのブロックの場合、中括弧を省略して直接展開
    bool all_var_decls = !stmt.block_stmts.empty();
    for (const auto &s : stmt.block_stmts) {
        if (s.kind != HIRStmt::StmtKind::VarDecl) {
            all_var_decls = false;
            break;
        }
    }

    if (all_var_decls) {
        // 変数宣言のみなので、中括弧なしで直接出力
        for (const auto &s : stmt.block_stmts) {
            generate_stmt(s);
        }
    } else {
        // 通常のブロック
        emit_line("{");
        increase_indent();

        for (const auto &s : stmt.block_stmts) {
            generate_stmt(s);
        }

        decrease_indent();
        emit_line("}");
    }
}

void HIRToCpp::generate_switch(const HIRStmt &stmt) {
    emit_indent();
    emit("switch (");
    emit(generate_expr(*stmt.switch_expr));
    emit(") {\n");

    increase_indent();

    for (const auto &case_item : stmt.switch_cases) {
        if (case_item.case_value) {
            emit_indent();
            emit("case ");
            emit(generate_expr(*case_item.case_value));
            emit(":\n");
        } else {
            emit_line("default:");
        }

        increase_indent();
        for (const auto &case_stmt : case_item.case_body) {
            generate_stmt(case_stmt);
        }
        emit_line("break;");
        decrease_indent();
    }

    decrease_indent();
    emit_line("}");
}

void HIRToCpp::generate_defer(const HIRStmt &stmt) {
    // C++でdeferを実装するにはRAIIラッパーが必要
    emit_line("// TODO: defer statement");
    if (stmt.defer_stmt) {
        generate_stmt(*stmt.defer_stmt);
    }
}

void HIRToCpp::generate_delete(const HIRStmt &stmt) {
    emit_indent();
    emit("delete ");
    emit(generate_expr(*stmt.delete_expr));
    emit(";\n");
}

void HIRToCpp::generate_try_catch(const HIRStmt &stmt) {
    emit_line("try {");
    increase_indent();

    for (const auto &s : stmt.try_block) {
        generate_stmt(s);
    }

    decrease_indent();
    emit_line("}");

    for (const auto &catch_clause : stmt.catch_clauses) {
        emit_indent();
        emit("catch (");
        emit(generate_type(catch_clause.exception_type));
        emit(" " + catch_clause.exception_var + ") {\n");

        increase_indent();
        for (const auto &s : catch_clause.catch_body) {
            generate_stmt(s);
        }
        decrease_indent();

        emit_line("}");
    }

    if (!stmt.finally_block.empty()) {
        emit_line("// finally block (executed via RAII)");
        for (const auto &s : stmt.finally_block) {
            generate_stmt(s);
        }
    }
}

// === 式の生成 ===

std::string HIRToCpp::generate_expr(const HIRExpr &expr) {
    switch (expr.kind) {
    case HIRExpr::ExprKind::Literal:
        return generate_literal(expr);
    case HIRExpr::ExprKind::Variable:
        return generate_variable(expr);
    case HIRExpr::ExprKind::BinaryOp:
        return generate_binary_op(expr);
    case HIRExpr::ExprKind::UnaryOp:
        return generate_unary_op(expr);
    case HIRExpr::ExprKind::FunctionCall:
        return generate_function_call(expr);
    case HIRExpr::ExprKind::MethodCall:
        return generate_method_call(expr);
    case HIRExpr::ExprKind::MemberAccess:
        return generate_member_access(expr);
    case HIRExpr::ExprKind::ArrayAccess:
        return generate_array_access(expr);
    case HIRExpr::ExprKind::Cast:
        return generate_cast(expr);
    case HIRExpr::ExprKind::Ternary:
        return generate_ternary(expr);
    case HIRExpr::ExprKind::Lambda:
        return generate_lambda(expr);
    case HIRExpr::ExprKind::StructLiteral:
        return generate_struct_literal(expr);
    case HIRExpr::ExprKind::ArrayLiteral:
        return generate_array_literal(expr);
    case HIRExpr::ExprKind::AddressOf:
        return generate_address_of(expr);
    case HIRExpr::ExprKind::Dereference:
        return generate_dereference(expr);
    case HIRExpr::ExprKind::SizeOf:
        return generate_sizeof(expr);
    case HIRExpr::ExprKind::New:
        return generate_new(expr);
    case HIRExpr::ExprKind::Await:
        return generate_await(expr);
    case HIRExpr::ExprKind::PreIncDec:
        return generate_pre_incdec(expr);
    case HIRExpr::ExprKind::PostIncDec:
        return generate_post_incdec(expr);
    default:
        return "/* unsupported expr */";
    }
}

std::string HIRToCpp::generate_literal(const HIRExpr &expr) {
    // 文字列リテラルはエスケープ処理
    if (expr.literal_type.kind == HIRType::TypeKind::String) {
        return "\"" + escape_string(expr.literal_value) + "\"";
    }
    return expr.literal_value;
}

std::string HIRToCpp::generate_variable(const HIRExpr &expr) {
    // Convert 'self' to '(*this)'
    if (expr.var_name == "self") {
        return "(*this)";
    }
    return add_hir_prefix(expr.var_name);
}

std::string HIRToCpp::generate_binary_op(const HIRExpr &expr) {
    // ポインタ演算の特殊処理: + or - は全てchar*経由で行う（void*対応のため）
    // 型情報が不完全な場合があるため、全ての+/-に適用
    if ((expr.op == "+" || expr.op == "-") && expr.left && expr.right) {
        // 右辺が数値リテラルっぽい場合はポインタ演算と判断
        // （完全な判定は難しいが、sizeof等の結果もカバーするため広めに適用）
        std::string left_expr = generate_expr(*expr.left);
        std::string right_expr = generate_expr(*expr.right);

        // sizeやcountなどの単純な整数変数は除外（ただしキャストが含まれる場合は除外しない）
        bool has_cast = (left_expr.find("(void*)") != std::string::npos ||
                         left_expr.find("(char*)") != std::string::npos ||
                         left_expr.find("static_cast") != std::string::npos);
        bool is_simple_int_var =
            !has_cast && (left_expr.find("_size") != std::string::npos ||
                          left_expr.find("_count") != std::string::npos ||
                          left_expr.find("sizeof") != std::string::npos);

        if (!is_simple_int_var) {
            // leftに ptr, node, current などポインタ関連の名前が含まれる場合
            // または既にvoid*キャストが含まれる場合（ネストされた演算）
            bool looks_like_pointer =
                (left_expr.find("_ptr") != std::string::npos &&
                 left_expr.find("ptr_") == std::string::npos) ||
                (left_expr.find("_node") != std::string::npos &&
                 left_expr.find("node_") == std::string::npos) ||
                (left_expr.find("_array") != std::string::npos &&
                 left_expr.find("array_") == std::string::npos) ||
                left_expr.find("CB_HIR_current") != std::string::npos ||
                left_expr.find("front") != std::string::npos ||
                left_expr.find("back") != std::string::npos ||
                left_expr.find("malloc") != std::string::npos ||
                // 既にラップされたポインタ式を検出
                (left_expr.find("(void*)") != std::string::npos &&
                 left_expr.find("(char*)") != std::string::npos);

            if (looks_like_pointer) {
                // ポインタ演算として処理
                std::string result = "((void*)((char*)";
                result += left_expr;
                result += " " + expr.op + " ";
                result += right_expr;
                result += "))";
                return result;
            }
        }
    }

    std::string result = "(";
    result += generate_expr(*expr.left);
    result += " " + expr.op + " ";
    result += generate_expr(*expr.right);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_unary_op(const HIRExpr &expr) {
    std::string result = "(";

    // Handle special operators that need conversion
    if (expr.op == "ADDRESS_OF") {
        result += "&";
    } else if (expr.op == "DEREFERENCE") {
        result += "*";
    } else {
        result += expr.op;
    }

    result += generate_expr(*expr.operand);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_function_call(const HIRExpr &expr) {
    // call_function_pointerの特別処理
    if (expr.func_name == "call_function_pointer" &&
        expr.arguments.size() >= 1) {
        // 関数ポインタ呼び出し: ((RetType(*)(Args...))fn_ptr)(args...)
        // ジェネリックコンテキストでは T を使用
        std::string fn_ptr = generate_expr(expr.arguments[0]);
        std::string result = "((int(*)(";

        // ジェネリック型パラメータがあれば使用
        if (!current_generic_params.empty()) {
            for (size_t i = 1; i < expr.arguments.size(); i++) {
                if (i > 1)
                    result += ", ";
                result += current_generic_params[0]; // 全引数を T として扱う
            }
        } else {
            // パラメータ型が不明な場合はvoidに
            for (size_t i = 1; i < expr.arguments.size(); i++) {
                if (i > 1)
                    result += ", ";
                result += "int"; // デフォルトはint
            }
        }

        result += "))" + fn_ptr + ")(";

        // 引数を追加（最初の引数は関数ポインタなのでスキップ）
        for (size_t i = 1; i < expr.arguments.size(); i++) {
            if (i > 1)
                result += ", ";
            result += generate_expr(expr.arguments[i]);
        }

        result += ")";
        return result;
    }

    std::string result = add_hir_prefix(expr.func_name);

    // CB_HIR_array_getの場合、ジェネリック型パラメータを明示的に指定
    if (expr.func_name == "array_get" && !current_generic_params.empty()) {
        result += "<" + current_generic_params[0] + ">";
    }

    result += "(";

    for (size_t i = 0; i < expr.arguments.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.arguments[i]);
    }

    result += ")";
    return result;
}

std::string HIRToCpp::generate_method_call(const HIRExpr &expr) {
    // Determine if we should use -> or .
    bool use_arrow = expr.is_arrow ||
                     (expr.receiver &&
                      expr.receiver->type.kind == HIRType::TypeKind::Pointer);

    // Also check if the receiver is a variable in the current function's
    // parameters
    if (!use_arrow && expr.receiver &&
        expr.receiver->kind == HIRExpr::ExprKind::Variable) {
        if (!current_function_params.empty()) {
            auto it = current_function_params.find(expr.receiver->var_name);
            if (it != current_function_params.end() &&
                it->second.kind == HIRType::TypeKind::Pointer) {
                use_arrow = true;
            }
        }
    }

    // Generate the receiver expression
    std::string result = generate_expr(*expr.receiver);
    result += (use_arrow ? "->" : ".") + expr.method_name + "(";

    for (size_t i = 0; i < expr.arguments.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.arguments[i]);
    }

    result += ")";
    return result;
}

std::string HIRToCpp::generate_member_access(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.object);
    result += expr.is_arrow ? "->" : ".";
    result += expr.member_name;
    return result;
}

std::string HIRToCpp::generate_array_access(const HIRExpr &expr) {
    std::string result = generate_expr(*expr.array);
    result += "[";
    result += generate_expr(*expr.index);
    result += "]";
    return result;
}

std::string HIRToCpp::generate_cast(const HIRExpr &expr) {
    // キャスト式が空または無効な場合、C形式のキャストにフォールバック
    if (!expr.cast_expr) {
        // キャスト対象がない場合は型のデフォルト値を生成
        // This should not happen in valid code
        std::string type_str = generate_type(expr.cast_type);
        return "/* CAST ERROR: no cast_expr */ " + type_str + "{}";
    }

    std::string cast_value = generate_expr(*expr.cast_expr);

    // 生成された式が空の場合、エラーメッセージを含める
    if (cast_value.empty() || cast_value == "/* unsupported expr */") {
        std::string type_str = generate_type(expr.cast_type);
        // Instead of returning empty {}, use C-style cast with a warning
        return "/* CAST ERROR: empty cast_value */ (" + type_str + ")nullptr";
    }

    // 通常のキャスト - C-style castを使用（互換性のため）
    std::string result = "(";
    result += generate_type(expr.cast_type);
    result += ")";
    result += cast_value;
    return result;
}

std::string HIRToCpp::generate_ternary(const HIRExpr &expr) {
    std::string result = "(";
    result += generate_expr(*expr.condition);
    result += " ? ";
    result += generate_expr(*expr.then_expr);
    result += " : ";
    result += generate_expr(*expr.else_expr);
    result += ")";
    return result;
}

std::string HIRToCpp::generate_lambda(const HIRExpr &expr) {
    std::string result = "[](";

    // パラメータ
    for (size_t i = 0; i < expr.lambda_params.size(); i++) {
        if (i > 0)
            result += ", ";
        const auto &param = expr.lambda_params[i];
        if (param.is_const)
            result += "const ";
        result += generate_type(param.type);
        result += " " + add_hir_prefix(param.name);
    }

    result += ") -> ";
    result += generate_type(expr.lambda_return_type);
    result += " { /* lambda body */ }";

    return result;
}

std::string HIRToCpp::generate_struct_literal(const HIRExpr &expr) {
    std::string result = expr.struct_type_name + "{";

    for (size_t i = 0; i < expr.field_values.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.field_values[i]);
    }

    result += "}";
    return result;
}

std::string HIRToCpp::generate_array_literal(const HIRExpr &expr) {
    std::string result = "{";

    for (size_t i = 0; i < expr.array_elements.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_expr(expr.array_elements[i]);
    }

    result += "}";
    return result;
}

std::string HIRToCpp::generate_address_of(const HIRExpr &expr) {
    return "&(" + generate_expr(*expr.operand) + ")";
}

std::string HIRToCpp::generate_dereference(const HIRExpr &expr) {
    return "*(" + generate_expr(*expr.operand) + ")";
}

std::string HIRToCpp::generate_sizeof(const HIRExpr &expr) {
    if (expr.sizeof_expr) {
        return "sizeof(" + generate_expr(*expr.sizeof_expr) + ")";
    } else {
        return "sizeof(" + generate_type(expr.sizeof_type) + ")";
    }
}

std::string HIRToCpp::generate_new(const HIRExpr &expr) {
    std::string result = "new " + generate_type(expr.new_type);

    if (!expr.new_args.empty()) {
        result += "(";
        for (size_t i = 0; i < expr.new_args.size(); i++) {
            if (i > 0)
                result += ", ";
            result += generate_expr(expr.new_args[i]);
        }
        result += ")";
    }

    return result;
}

std::string HIRToCpp::generate_await(const HIRExpr &expr) {
    // Cb's await just accesses the value field of the Future
    return "(" + generate_expr(*expr.operand) + ").value";
}

std::string HIRToCpp::generate_pre_incdec(const HIRExpr &expr) {
    return expr.op + generate_expr(*expr.operand);
}

std::string HIRToCpp::generate_post_incdec(const HIRExpr &expr) {
    return generate_expr(*expr.operand) + expr.op;
}

void HIRToCpp::generate_assert(const HIRStmt &stmt) {
    emit_indent();
    emit("assert(");
    if (stmt.assert_expr) {
        emit(generate_expr(*stmt.assert_expr));
    } else {
        // If no expression, use false to trigger assertion failure
        emit("false && \"assertion failed\"");
    }
    emit(")");
    if (!stmt.assert_message.empty()) {
        emit(" /* " + stmt.assert_message + " */");
    }
    emit(";\n");
}

// === 型の生成 ===

std::string HIRToCpp::generate_type(const HIRType &type) {
    switch (type.kind) {
    case HIRType::TypeKind::Void:
        return "void";
    case HIRType::TypeKind::Tiny:
        return "int8_t";
    case HIRType::TypeKind::Short:
        return "int16_t";
    case HIRType::TypeKind::Int:
        return "int";
    case HIRType::TypeKind::Long:
        return "int64_t";
    case HIRType::TypeKind::Char:
        return "char";
    case HIRType::TypeKind::String:
        return "std::string";
    case HIRType::TypeKind::Bool:
        return "bool";
    case HIRType::TypeKind::Float:
        return "float";
    case HIRType::TypeKind::Double:
        return "double";
    case HIRType::TypeKind::Struct:
    case HIRType::TypeKind::Enum:
    case HIRType::TypeKind::Interface:
        return type.name;
    case HIRType::TypeKind::Pointer:
        return generate_pointer_type(type);
    case HIRType::TypeKind::Reference:
        return generate_reference_type(type);
    case HIRType::TypeKind::Array:
        return generate_array_type(type);
    case HIRType::TypeKind::Function:
        return generate_function_type(type);
    case HIRType::TypeKind::Generic:
        return type.name;
    case HIRType::TypeKind::Nullptr:
        return "std::nullptr_t";
    case HIRType::TypeKind::Unknown:
        // ジェネリック型パラメータがある場合は最初のものを使用
        if (!current_generic_params.empty()) {
            return current_generic_params[0];
        }
        return "/* unknown type */";
    default:
        return "/* unknown type */";
    }
}

std::string HIRToCpp::generate_basic_type(const HIRType &type) {
    return generate_type(type);
}

std::string HIRToCpp::generate_pointer_type(const HIRType &type) {
    if (type.inner_type) {
        return generate_type(*type.inner_type) + "*";
    }
    // If name contains "*", it's already a pointer type with the * in the name
    // Example: "TestResult*" or "void*" or "MapNode<K, V>*"
    if (!type.name.empty()) {
        // Check if name already has * at the end
        if (type.name.back() == '*') {
            return type.name;
        }
        // Otherwise add *
        return type.name + "*";
    }
    // Default to void* if type name is missing
    return "void*";
}

std::string HIRToCpp::generate_reference_type(const HIRType &type) {
    if (type.inner_type) {
        return generate_type(*type.inner_type) + "&";
    }
    return type.name + "&";
}

std::string HIRToCpp::generate_array_type(const HIRType &type) {
    if (type.inner_type) {
        if (type.array_size > 0) {
            // 固定長配列
            return "std::array<" + generate_type(*type.inner_type) + ", " +
                   std::to_string(type.array_size) + ">";
        } else {
            // 動的配列
            return "std::vector<" + generate_type(*type.inner_type) + ">";
        }
    }
    return "std::vector<int>"; // fallback
}

std::string HIRToCpp::generate_function_type(const HIRType &type) {
    std::string result = "std::function<";

    if (type.return_type) {
        result += generate_type(*type.return_type);
    } else {
        result += "void";
    }

    result += "(";
    for (size_t i = 0; i < type.param_types.size(); i++) {
        if (i > 0)
            result += ", ";
        result += generate_type(type.param_types[i]);
    }
    result += ")>";

    return result;
}

// === ユーティリティ ===

std::string HIRToCpp::escape_string(const std::string &str) {
    std::string result;
    for (char c : str) {
        switch (c) {
        case '\n':
            result += "\\n";
            break;
        case '\t':
            result += "\\t";
            break;
        case '\r':
            result += "\\r";
            break;
        case '\\':
            result += "\\\\";
            break;
        case '"':
            result += "\\\"";
            break;
        default:
            result += c;
            break;
        }
    }
    return result;
}

std::string
HIRToCpp::mangle_generic_name(const std::string &base_name,
                              const std::vector<HIRType> &generic_args) {
    std::string result = base_name;
    if (!generic_args.empty()) {
        result += "_";
        for (const auto &arg : generic_args) {
            result += generate_type(arg);
        }
    }
    return result;
}

} // namespace codegen
} // namespace cb
