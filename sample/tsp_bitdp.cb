// 巡回セールスマン問題 (TSP) - ビット演算DP解法
// 都市を巡回して元の都市に戻る最短経路を求める

// 最小値を返す関数
int min(int a, int b) {
    return (a < b) ? a : b;
}

// ビットが立っているかチェックする関数
bool has_bit(int mask, int i) {
    return (mask & (1 << i)) != 0;
}

int main() {
    int n = 4;  // 都市数
    int inf_val = 999999;  // 大きな値
    
    // 距離行列を宣言して初期化
    int[4][4] dist = [
        [0, 10, 15, 20],
        [10, 0, 35, 25],
        [15, 35, 0, 30],
        [20, 25, 30, 0]
    ];
    
    // DPテーブル
    int[16][4] dp;
    
    println("=== 巡回セールスマン問題 (ビットDP) ===");
    
    // 距離行列を表示
    println("距離行列:");
    int i = 0;
    while (i < n) {
        print("都市");
        print(i);
        print(": ");
        int j = 0;
        while (j < n) {
            print(dist[i][j]);
            if (j < n - 1) {
                print(" ");
            }
            j = j + 1;
        }
        println("");
        i = i + 1;
    }
    println("");
    
    // DPテーブルを初期化
    int mask = 0;
    while (mask < 16) {
        int city = 0;
        while (city < n) {
            dp[mask][city] = inf_val;
            city = city + 1;
        }
        mask = mask + 1;
    }
    
    // 開始点（都市0）を設定
    dp[1][0] = 0;  // mask=1 は都市0のみを訪問した状態
    
    // ビットDP実行
    mask = 1;
    while (mask < 16) {
        int from = 0;
        while (from < n) {
            if (!has_bit(mask, from) || dp[mask][from] == inf_val) {
                from = from + 1;
                continue;
            }
            
            int to = 0;
            while (to < n) {
                if (!has_bit(mask, to)) {
                    int new_mask = mask | (1 << to);
                    int new_cost = dp[mask][from] + dist[from][to];
                    dp[new_mask][to] = min(dp[new_mask][to], new_cost);
                }
                to = to + 1;
            }
            from = from + 1;
        }
        mask = mask + 1;
    }
    
    // 全都市を訪問して都市0に戻る最短距離を計算
    int full_mask = 15;  // 1111 = 15
    int ans = inf_val;
    int last = 1;
    while (last < n) {
        if (dp[full_mask][last] != inf_val) {
            ans = min(ans, dp[full_mask][last] + dist[last][0]);
        }
        last = last + 1;
    }
    
    // 結果表示
    println("計算過程 (一部):");
    mask = 1;
    while (mask <= 7) {
        print("状態 ");
        print(mask);
        print(": ");
        
        int city = 0;
        while (city < n) {
            if (dp[mask][city] != inf_val) {
                print("都市");
                print(city);
                print("=");
                print(dp[mask][city]);
                print(" ");
            }
            city = city + 1;
        }
        println("");
        mask = mask + 1;
    }
    
    println("");
    print("最短経路の距離: ");
    println(ans);
    
    // ビット演算の説明
    println("");
    println("=== ビット演算の使用例 ===");
    int example_mask = (1 << 0) | (1 << 2);  // 都市0,2を訪問
    print("都市0,2を訪問済み: ");
    println(example_mask);
    
    example_mask = example_mask | (1 << 1);  // 都市1を追加
    print("都市1を追加: ");
    println(example_mask);
    
    print("都市2が訪問済みか: ");
    println(has_bit(example_mask, 2) ? 1 : 0);
}