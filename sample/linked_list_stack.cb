// 連結リストで実装したスタック（Stack）
// ノードを個別変数として管理（配列のアドレス取得制限の回避）

struct StackNode {
    int value;
    StackNode* next;
};

struct Stack {
    StackNode* top;
    int size;
};

// スタックの初期化
void stack_init(Stack& s) {
    s.top = nullptr;
    s.size = 0;
}

// スタックが空かどうか
bool stack_is_empty(Stack& s) {
    return s.top == nullptr;
}

// スタックのサイズ
int stack_size(Stack& s) {
    return s.size;
}

// スタックの内容を表示（簡易版）
void stack_print(Stack& s) {
    if (stack_is_empty(s)) {
        println("  (empty)");
        return;
    }
    
    // 最初の数個を表示
    println("  Stack (size=%d, showing top 5):", s.size);
    StackNode* current = s.top;
    int count = 0;
    
    while (current != nullptr && count < 5) {
        int node_value = (*current).value;
        println("    [%d] %d", count, node_value);
        current = (*current).next;
        count = count + 1;
    }
    
    if (current != nullptr) {
        println("    ...");
    }
}

void main() {
    println("=== Stack Implementation with Linked List ===\n");
    
    // 注意: 構造体配列の要素のアドレス取得に制限があるため、
    // 個別の変数として20個のノードを定義
    StackNode n0;
    StackNode n1;
    StackNode n2;
    StackNode n3;
    StackNode n4;
    StackNode n5;
    StackNode n6;
    StackNode n7;
    StackNode n8;
    StackNode n9;
    StackNode n10;
    StackNode n11;
    StackNode n12;
    StackNode n13;
    StackNode n14;
    StackNode n15;
    StackNode n16;
    StackNode n17;
    StackNode n18;
    StackNode n19;
    
    // スタックの初期化
    Stack myStack;
    stack_init(myStack);
    
    println("=== 1. Basic Stack Operations ===");
    println("Initial state:");
    println("  Size: %d", stack_size(myStack));
    println("  Empty: %d", stack_is_empty(myStack));
    
    // Push操作（手動実装）
    println("\nPushing values: 10, 20, 30, 40, 50");
    
    // Push 10
    n0.value = 10;
    n0.next = myStack.top;
    myStack.top = &n0;
    myStack.size = myStack.size + 1;
    
    // Push 20
    n1.value = 20;
    n1.next = myStack.top;
    myStack.top = &n1;
    myStack.size = myStack.size + 1;
    
    // Push 30
    n2.value = 30;
    n2.next = myStack.top;
    myStack.top = &n2;
    myStack.size = myStack.size + 1;
    
    // Push 40
    n3.value = 40;
    n3.next = myStack.top;
    myStack.top = &n3;
    myStack.size = myStack.size + 1;
    
    // Push 50
    n4.value = 50;
    n4.next = myStack.top;
    myStack.top = &n4;
    myStack.size = myStack.size + 1;
    
    println("\nStack after pushing:");
    stack_print(myStack);
    
    // Peek操作
    if (myStack.top != nullptr) {
        int peek_value = (*myStack.top).value;
        println("\nPeek (top value): %d", peek_value);
    }
    
    // Pop操作
    println("\n=== 2. Pop Operations ===");
    for (int i = 0; i < 3; i++) {
        if (myStack.top != nullptr) {
            int value = (*myStack.top).value;
            StackNode* next_node = (*myStack.top).next;
            myStack.top = next_node;
            myStack.size = myStack.size - 1;
            
            println("Popped: %d", value);
        }
    }
    
    println("\nStack after popping:");
    stack_print(myStack);
    println("  Size: %d", stack_size(myStack));
    
    // 追加のPush操作
    println("\n=== 3. Additional Pushes ===");
    println("Pushing: 60, 70, 80");
    
    // Push 60
    n5.value = 60;
    n5.next = myStack.top;
    myStack.top = &n5;
    myStack.size = myStack.size + 1;
    
    // Push 70
    n6.value = 70;
    n6.next = myStack.top;
    myStack.top = &n6;
    myStack.size = myStack.size + 1;
    
    // Push 80
    n7.value = 80;
    n7.next = myStack.top;
    myStack.top = &n7;
    myStack.size = myStack.size + 1;
    
    println("\nStack after pushing:");
    stack_print(myStack);
    
    // 全要素をPop
    println("\n=== 4. Pop All Elements ===");
    int pop_count = 0;
    while (myStack.top != nullptr) {
        int value = (*myStack.top).value;
        StackNode* next_node = (*myStack.top).next;
        myStack.top = next_node;
        myStack.size = myStack.size - 1;
        
        println("  Pop %d: %d", pop_count, value);
        pop_count = pop_count + 1;
    }
    
    println("\nFinal state:");
    println("  Size: %d", stack_size(myStack));
    println("  Empty: %d", stack_is_empty(myStack));
    
    // 実用例: 括弧のバランスチェック
    println("\n=== 5. Practical Example: Balanced Parentheses ===");
    
    Stack paren_stack;
    stack_init(paren_stack);
    
    // テスト式: (()())(()) - バランスが取れている
    // 1=開き括弧 '('、0=閉じ括弧 ')'
    int[10] expression;
    expression[0] = 1;  // (
    expression[1] = 1;  // (
    expression[2] = 0;  // )
    expression[3] = 1;  // (
    expression[4] = 0;  // )
    expression[5] = 0;  // )
    expression[6] = 1;  // (
    expression[7] = 1;  // (
    expression[8] = 0;  // )
    expression[9] = 0;  // )
    
    // この式は: (()()) と (()) の2つのグループ = 合計10文字
    // (=4個, )=4個 だが、並びがおかしい場合にエラーになる
    
    print("Expression: ");
    for (int i = 0; i < 10; i++) {
        if (expression[i] == 1) {
            print("(");
        } else {
            print(")");
        }
    }
    println("");
    
    // 括弧のバランスをチェック
    bool balanced = true;
    int push_idx = 0;
    
    for (int i = 0; i < 10; i++) {
        if (expression[i] == 1) {
            // 開き括弧: スタックにプッシュ
            if (push_idx == 0) {
                n10.value = 1;
                n10.next = paren_stack.top;
                paren_stack.top = &n10;
            } else if (push_idx == 1) {
                n11.value = 1;
                n11.next = paren_stack.top;
                paren_stack.top = &n11;
            } else if (push_idx == 2) {
                n12.value = 1;
                n12.next = paren_stack.top;
                paren_stack.top = &n12;
            } else if (push_idx == 3) {
                n13.value = 1;
                n13.next = paren_stack.top;
                paren_stack.top = &n13;
            } else if (push_idx == 4) {
                n14.value = 1;
                n14.next = paren_stack.top;
                paren_stack.top = &n14;
            }
            push_idx = push_idx + 1;
            paren_stack.size = paren_stack.size + 1;
        } else {
            // 閉じ括弧: スタックからポップ
            if (paren_stack.top == nullptr) {
                balanced = false;
                break;
            }
            StackNode* next_node = (*paren_stack.top).next;
            paren_stack.top = next_node;
            paren_stack.size = paren_stack.size - 1;
        }
    }
    
    // 最終的にスタックが空でなければアンバランス
    if (paren_stack.top != nullptr) {
        balanced = false;
    }
    
    if (balanced) {
        println("Result: Balanced!");
    } else {
        println("Result: NOT Balanced!");
    }
    
    println("\n=== スタックの実装完了 ===");
    println("注意: 現在の実装では構造体配列の要素のアドレス取得に");
    println("制限があるため、個別の変数として20個のノードを定義しています。");
}
