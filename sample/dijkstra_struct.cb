// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ダイクストラ法の実装 - 最短経路探索アルゴリズム
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// 【実装の特徴】
// - Interface/Implを使った優先度キューの実装
// - 構造体配列によるデータ管理
// - 関数ポインタを活用した抽象化
// - 経路の復元機能を実装
//
// 【構造体の説明】
// Node:   各ノードの情報（距離、訪問フラグ、前ノード）
// Edge:   グラフの辺（出発、到着、重み）
// Graph:  グラフ全体の情報（ノード数、エッジ数）
// PQNode: 優先度キューの要素（ノードIDと距離）
//
// 【Interface/Implの使用】
// PriorityQueue: 優先度キューのインターフェース
// MinHeapPQ: 最小ヒープによる実装
//
// 【アルゴリズムの流れ】
// 1. 開始ノードを優先度キューに追加
// 2. キューから最小距離のノードを取り出す
// 3. 隣接ノードの距離を更新
// 4. 更新したノードをキューに追加
// 5. キューが空になるまで2-4を繰り返す
//
// 【時間計算量】
// O((V+E) log V) - Vはノード数、Eはエッジ数
//
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ノードを表す構造体
struct Node {
    int id;              // ノードID
    int distance;        // 開始ノードからの距離
    bool visited;        // 訪問済みフラグ
    int prev_node;       // 前のノード（経路復元用）
};

// エッジ（辺）を表す構造体
struct Edge {
    int from;            // 出発ノード
    int to;              // 接続先のノード
    int weight;          // エッジの重み（距離・コスト）
};

// グラフを表す構造体
struct Graph {
    int node_count;      // ノード数
    int edge_count;      // エッジ数
    int max_edges;       // 最大エッジ数
};

// 優先度キューの要素
struct PQNode {
    int node_id;         // ノードID
    int distance;        // 距離
};

// 優先度キューのInterface
interface PriorityQueue {
    void push(int node_id, int distance);
    int pop();
    bool is_empty();
    int size();
    void clear();
};

// MinHeapPQ構造体（ダミー：実装はimplで定義）
struct MinHeapPQ {
    int dummy;  // 構造体には少なくとも1つのフィールドが必要
};

// 無限大を表す定数
const int INF = 999999;
const int MAX_NODES = 8;
const int MAX_EDGES = 30;

// グローバル変数でグラフデータを管理
Graph graph;
Node[8] nodes;           // ノード配列
Edge[30] edges;          // エッジ配列
int[64] adjacency_matrix; // 8x8の隣接行列（8*8=64）

// 最小ヒープ用のグローバル変数
PQNode[8] heap;
int heap_size = 0;

// 親インデックスを取得
int heap_parent(int i) {
    return (i - 1) / 2;
}

// 左の子インデックスを取得
int heap_left_child(int i) {
    return 2 * i + 1;
}

// 右の子インデックスを取得
int heap_right_child(int i) {
    return 2 * i + 2;
}

// ヒープの上向き修正
void heap_heapify_up(int idx) {
    while (idx > 0) {
        int parent_idx = heap_parent(idx);
        if (heap[idx].distance < heap[parent_idx].distance) {
            // スワップ
            int temp_id = heap[idx].node_id;
            int temp_dist = heap[idx].distance;
            heap[idx].node_id = heap[parent_idx].node_id;
            heap[idx].distance = heap[parent_idx].distance;
            heap[parent_idx].node_id = temp_id;
            heap[parent_idx].distance = temp_dist;
            idx = parent_idx;
        } else {
            break;
        }
    }
}

// ヒープの下向き修正
void heap_heapify_down(int idx) {
    while (true) {
        int smallest = idx;
        int left = heap_left_child(idx);
        int right = heap_right_child(idx);
        
        if (left < heap_size && heap[left].distance < heap[smallest].distance) {
            smallest = left;
        }
        if (right < heap_size && heap[right].distance < heap[smallest].distance) {
            smallest = right;
        }
        
        if (smallest != idx) {
            // スワップ
            int temp_id = heap[idx].node_id;
            int temp_dist = heap[idx].distance;
            heap[idx].node_id = heap[smallest].node_id;
            heap[idx].distance = heap[smallest].distance;
            heap[smallest].node_id = temp_id;
            heap[smallest].distance = temp_dist;
            idx = smallest;
        } else {
            break;
        }
    }
}

// 最小ヒープによる優先度キュー実装
impl PriorityQueue for MinHeapPQ {
    void push(int node_id, int distance) {
        if (heap_size >= MAX_NODES) return;
        
        heap[heap_size].node_id = node_id;
        heap[heap_size].distance = distance;
        heap_heapify_up(heap_size);
        heap_size = heap_size + 1;
    }
    
    int pop() {
        if (heap_size == 0) return -1;
        
        int min_node = heap[0].node_id;
        heap_size = heap_size - 1;
        
        if (heap_size > 0) {
            heap[0].node_id = heap[heap_size].node_id;
            heap[0].distance = heap[heap_size].distance;
            heap_heapify_down(0);
        }
        
        return min_node;
    }
    
    bool is_empty() {
        return heap_size == 0;
    }
    
    int size() {
        return heap_size;
    }
    
    void clear() {
        heap_size = 0;
    }
};

// グラフの初期化
void init_graph(int num_nodes) {
    graph.node_count = num_nodes;
    graph.edge_count = 0;
    graph.max_edges = MAX_EDGES;
    
    // ノードの初期化
    for (int i = 0; i < MAX_NODES; i++) {
        nodes[i].id = i;
        nodes[i].distance = INF;
        nodes[i].visited = false;
        nodes[i].prev_node = -1;
    }
    
    // 隣接行列を初期化（INFで埋める）
    for (int i = 0; i < 64; i++) {
        adjacency_matrix[i] = INF;
    }
    
    // 対角線要素は0（自分自身への距離）
    for (int i = 0; i < MAX_NODES; i++) {
        adjacency_matrix[i * MAX_NODES + i] = 0;
    }
}

// エッジの追加
void add_edge(int from, int to, int weight) {
    // 隣接行列に重みを設定
    adjacency_matrix[from * MAX_NODES + to] = weight;
    
    // エッジ配列にも記録
    int idx = graph.edge_count;
    edges[idx].from = from;
    edges[idx].to = to;
    edges[idx].weight = weight;
    graph.edge_count = graph.edge_count + 1;
}

// ノードの距離を更新
void update_node_distance(int node_id, int new_dist, int prev) {
    nodes[node_id].distance = new_dist;
    nodes[node_id].prev_node = prev;
}

// ノードの情報を表示
void print_node_info(int node_id) {
    println("  Node %d: distance=%d, visited=%d, prev=%d", 
            node_id, nodes[node_id].distance, 
            nodes[node_id].visited, nodes[node_id].prev_node);
}

// ダイクストラ法の実行（Interface/Implを使った優先度キュー版）
void dijkstra(int start, PriorityQueue& pq) {
    // 優先度キューをクリア
    pq.clear();
    
    // 開始ノードの距離を0に設定
    update_node_distance(start, 0, -1);
    
    println("\n=== Executing Dijkstra's Algorithm ===");
    println("Starting from node %d", start);
    println("Using Interface-based Priority Queue (Min-Heap)\n");
    
    // 優先度キューに開始ノードを追加
    pq.push(start, 0);
    
    int iteration = 0;
    
    // 優先度キューが空になるまで繰り返し
    while (!pq.is_empty()) {
        // 最小距離のノードを取り出す
        int current = pq.pop();
        
        if (current == -1) break;
        
        // 既に訪問済みならスキップ
        if (nodes[current].visited) continue;
        
        nodes[current].visited = true;
        iteration++;
        
        println("Iteration %d: Processing node %d (distance: %d, queue_size: %d)", 
                iteration, current, nodes[current].distance, pq.size());
        
        // 隣接ノードの距離を更新
        int updates = 0;
        for (int neighbor = 0; neighbor < graph.node_count; neighbor++) {
            int weight = adjacency_matrix[current * MAX_NODES + neighbor];
            
            if (!nodes[neighbor].visited && weight != INF) {
                int new_distance = nodes[current].distance + weight;
                
                if (new_distance < nodes[neighbor].distance) {
                    update_node_distance(neighbor, new_distance, current);
                    pq.push(neighbor, new_distance);
                    println("  -> Updated node %d: distance = %d (via node %d)", 
                            neighbor, new_distance, current);
                    updates++;
                }
            }
        }
        
        if (updates == 0) {
            println("  -> No updates for this node");
        }
    }
    
    println("\nAlgorithm completed in %d iterations", iteration);
}

// 経路の復元と表示
void print_path(int start, int end) {
    if (nodes[end].distance == INF) {
        println("No path exists from %d to %d", start, end);
        return;
    }
    
    println("Path from %d to %d (distance: %d):", start, end, nodes[end].distance);
    
    // 経路を配列に格納（逆順）
    int[8] path;
    int path_length = 0;
    int current = end;
    
    while (current != -1) {
        path[path_length] = current;
        path_length++;
        current = nodes[current].prev_node;
    }
    
    // 正順で表示
    print("  ");
    for (int i = path_length - 1; i >= 0; i--) {
        print("%d", path[i]);
        if (i > 0) print(" -> ");
    }
    println("");
}

// 結果の表示
void print_results(int start) {
    println("\n=== Dijkstra's Algorithm Results ===");
    println("Starting from node: %d", start);
    println("\nShortest distances:");
    
    for (int i = 0; i < graph.node_count; i++) {
        if (nodes[i].distance == INF) {
            println("Node %d: UNREACHABLE", i);
        } else {
            println("Node %d: distance = %d", i, nodes[i].distance);
        }
    }
    
    println("\nShortest paths:");
    for (int i = 0; i < graph.node_count; i++) {
        if (i != start && nodes[i].distance != INF) {
            print_path(start, i);
        }
    }
}

// グラフの構造を表示
void print_graph() {
    println("=== Graph Structure ===");
    println("Nodes: %d, Edges: %d", graph.node_count, graph.edge_count);
    println("\nEdge list:");
    
    for (int i = 0; i < graph.edge_count; i++) {
        println("  Edge %d: %d -> %d (weight: %d)", 
                i, edges[i].from, edges[i].to, edges[i].weight);
    }
    
    println("\nAdjacency information:");
    for (int i = 0; i < graph.node_count; i++) {
        print("Node %d connects to: ", i);
        bool has_edge = false;
        
        for (int j = 0; j < graph.node_count; j++) {
            int weight = adjacency_matrix[i * MAX_NODES + j];
            if (weight != INF && weight != 0) {
                if (has_edge) print(", ");
                print("%d(w:%d)", j, weight);
                has_edge = true;
            }
        }
        
        if (!has_edge) print("none");
        println("");
    }
    println("");
}

void main() {
    println("=== Dijkstra's Shortest Path Algorithm ===");
    println("Advanced implementation with Interface/Impl and Priority Queue\n");
    
    // グラフの初期化（7ノード）
    init_graph(7);
    
    // エッジの追加（より複雑なグラフ）
    // グラフの構造:
    //       2
    //      /|\
    //     1 | 3
    //    /  |  \
    //   0   5   4
    //    \     /
    //     \   /
    //       6
    
    println("Building graph...");
    add_edge(0, 1, 4);   // 0 -> 1: cost 4
    add_edge(0, 6, 7);   // 0 -> 6: cost 7
    add_edge(1, 2, 9);   // 1 -> 2: cost 9
    add_edge(1, 6, 11);  // 1 -> 6: cost 11
    add_edge(2, 3, 6);   // 2 -> 3: cost 6
    add_edge(2, 5, 2);   // 2 -> 5: cost 2
    add_edge(3, 4, 8);   // 3 -> 4: cost 8
    add_edge(4, 6, 5);   // 4 -> 6: cost 5
    add_edge(5, 3, 7);   // 5 -> 3: cost 7
    add_edge(5, 4, 4);   // 5 -> 4: cost 4
    add_edge(6, 5, 1);   // 6 -> 5: cost 1
    
    println("Graph created with %d nodes and %d edges\n", graph.node_count, graph.edge_count);
    
    // グラフ構造の表示
    print_graph();
    
    // Interface/Implを使った優先度キューの作成
    MinHeapPQ heap_impl;
    heap_impl.dummy = 0;
    PriorityQueue pq = heap_impl;
    pq.clear();
    
    // ダイクストラ法の実行
    int start_node = 0;
    dijkstra(start_node, pq);
    
    // 結果の表示
    print_results(start_node);
    
    // 統計情報
    println("\n=== Graph Statistics ===");
    int reachable = 0;
    for (int i = 0; i < graph.node_count; i++) {
        if (nodes[i].distance != INF) reachable++;
    }
    println("Reachable nodes: %d / %d", reachable, graph.node_count);
    println("Total edges: %d", graph.edge_count);
    
    // 最短経路と最長経路
    int shortest_dist = INF;
    int longest_dist = 0;
    int shortest_node = -1;
    int longest_node = -1;
    
    for (int i = 0; i < graph.node_count; i++) {
        if (i != start_node && nodes[i].distance != INF) {
            if (nodes[i].distance < shortest_dist) {
                shortest_dist = nodes[i].distance;
                shortest_node = i;
            }
            if (nodes[i].distance > longest_dist) {
                longest_dist = nodes[i].distance;
                longest_node = i;
            }
        }
    }
    
    if (shortest_node != -1) {
        println("Shortest path: to node %d (distance: %d)", shortest_node, shortest_dist);
        println("Longest path: to node %d (distance: %d)", longest_node, longest_dist);
    }
    
    // パフォーマンス情報
    println("\n=== Implementation Details ===");
    println("Data structures used:");
    println("  - Node struct: stores id, distance, visited flag, prev_node");
    println("  - Edge struct: stores from, to, weight");
    println("  - Graph struct: stores node_count, edge_count, max_edges");
    println("  - PQNode struct: priority queue element");
    println("\nInterface/Impl pattern:");
    println("  - PriorityQueue interface: defines queue operations");
    println("  - MinHeapPQ impl: min-heap based implementation");
    println("  - Operations: push, pop, is_empty, size, clear");
    println("\nAlgorithm: Dijkstra with Min-Heap Priority Queue");
    println("Time Complexity: O((V+E) log V) with binary heap");
    println("Space Complexity: O(V^2) for adjacency matrix + O(E) for edges + O(V) for heap");
    println("\nHeap operations:");
    println("  - Insert: O(log V) with heapify_up");
    println("  - Extract-Min: O(log V) with heapify_down");
    println("  - Build-Heap: O(V) amortized");
}
