// Vector<T, A: Allocator> - Dynamic array with custom allocator
// Demo file for stdlib/collections/vector.cb
//
// This demonstrates the Vector implementation with dynamic memory management

// Allocator interface
interface Allocator {
    void* allocate(int size);
    void deallocate(void* ptr);
}

struct SystemAllocator {
    int allocation_count;
};

impl Allocator for SystemAllocator {
    void* allocate(int size) {
        println("[SystemAllocator] Allocate {size} bytes");
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        println("[SystemAllocator] Deallocate");
    }
}

// Vector structure
struct Vector<T, A: Allocator> {
    int capacity;
    int length;
    void* data;
};

// VectorOps interface
interface VectorOps {
    void init(int initial_capacity);
    void push(int value);
    int pop();
    void resize(int new_capacity);
    void info();
    int get_length();
    int get_capacity();
    bool is_empty();
    void destroy();
}

// Implementation for Vector<int, SystemAllocator>
impl VectorOps for Vector<int, SystemAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        self.data = new int[initial_capacity];
        println("[Vector<int, SystemAllocator>] Initialized with capacity={initial_capacity}");
        println("[Vector] Allocated memory at {hex(self.data)}");
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            println("[Vector] Error: Capacity full! (size={self.length}, capacity={self.capacity})");
            println("[Vector] Please call resize() before push");
            return;
        }
        
        array_set_int(self.data, self.length, value);
        self.length = self.length + 1;
        println("[Vector] Pushed value={value} at index={self.length - 1}");
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector] Empty! Cannot pop");
            return 0;
        }
        
        self.length = self.length - 1;
        int value = array_get_int(self.data, self.length);
        println("[Vector] Popped value={value} from index={self.length}");
        return value;
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector] New capacity {new_capacity} <= current {self.capacity}, no resize needed");
            return;
        }
        
        println("[Vector] Resizing from capacity={self.capacity} to {new_capacity}");
        
        void* new_data = new int[new_capacity];
        int copy_size = self.length * sizeof(int);
        memcpy(new_data, self.data, copy_size);
        println("[Vector] Copied {self.length} elements ({copy_size} bytes)");
        
        delete self.data;
        self.data = new_data;
        self.capacity = new_capacity;
        println("[Vector] Resize complete (new capacity={new_capacity}, memory at {hex(self.data)})");
    }
    
    void info() {
        println("[Vector] length={self.length}, capacity={self.capacity}, data={hex(self.data)}");
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void destroy() {
        if (self.data != nullptr) {
            println("[Vector] destroy(): Freeing memory at {hex(self.data)}");
            delete self.data;
            self.data = nullptr;
            self.length = 0;
            self.capacity = 0;
        }
    }
}

// Destructor
impl Vector<int, SystemAllocator> {
    ~self() {
        if (self.data != nullptr) {
            println("[Vector<int, SystemAllocator>] Destructor: Freeing memory at {hex(self.data)}");
            delete self.data;
        }
    }
}

void test_vector_basic() {
    println("\n=== Testing Vector Basic Operations ===");
    
    Vector<int, SystemAllocator> vec;
    vec.init(5);
    vec.info();
    
    println("\n--- Push operations ---");
    vec.push(10);
    vec.push(20);
    vec.push(30);
    vec.info();
    
    println("\n--- Pop operations ---");
    int val1 = vec.pop();
    int val2 = vec.pop();
    vec.info();
    
    println("\nVector basic test complete");
}

void test_vector_resize() {
    println("\n=== Testing Vector Resize ===");
    
    Vector<int, SystemAllocator> vec;
    vec.init(3);
    vec.info();
    
    println("\n--- Filling to capacity ---");
    vec.push(1);
    vec.push(2);
    vec.push(3);
    vec.info();
    
    println("\n--- Manual resize ---");
    vec.resize(6);
    vec.info();
    
    println("\n--- Push more elements ---");
    vec.push(4);
    vec.push(5);
    vec.info();
    
    println("\nVector resize test complete");
}

void test_vector_destructor() {
    println("\n=== Testing Vector Automatic Destructor ===");
    
    {
        Vector<int, SystemAllocator> vec;
        vec.init(5);
        vec.push(10);
        vec.push(20);
        vec.push(30);
        vec.info();
        println("Exiting scope... destructor should be called automatically");
    }
    println("Scope exited - destructor was called");
    
    println("\nAutomatic destructor test complete");
}

void main() {
    println("╔════════════════════════════════════════════════════════════╗");
    println("║  Vector Demo - Dynamic Memory Management                  ║");
    println("╚════════════════════════════════════════════════════════════╝");
    
    test_vector_basic();
    test_vector_resize();
    test_vector_destructor();
    
    println("\n╔════════════════════════════════════════════════════════════╗");
    println("║  All Vector tests completed successfully!                 ║");
    println("╚════════════════════════════════════════════════════════════╝");
}
