// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ダイクストラ法の実装 - interfaceとimplを使った実装
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// 【実装の特徴】
// - interface/implパターンで優先度キューを実装
// - 抽象化されたデータ構造
// - より柔軟で拡張性の高い設計
//
// 【interfaceの説明】
// PriorityQueue: 優先度キューの操作を定義
//   - push(int, int): 要素を追加
//   - pop(): 最小要素を取り出し
//   - isEmpty(): キューが空かチェック
//   - size(): キューのサイズを取得
//
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ノードを表す構造体
struct Node {
    int id;              // ノードID
    int distance;        // 開始ノードからの距離
    bool visited;        // 訪問済みフラグ
    int prev_node;       // 前のノード（経路復元用）
};

// エッジ（辺）を表す構造体
struct Edge {
    int from;            // 出発ノード
    int to;              // 接続先のノード
    int weight;          // エッジの重み（距離・コスト）
};

// グラフを表す構造体
struct Graph {
    int node_count;      // ノード数
    int edge_count;      // エッジ数
    int max_edges;       // 最大エッジ数
};

// 優先度キュー本体の構造体
// 注: 配列要素の構造体メンバーアクセスの制限により、平坦な配列を使用
struct PriorityQueueData {
    int[8] node_ids;      // ノードIDの配列
    int[8] priorities;    // 優先度の配列
    int queue_size;       // 現在のサイズ
    int capacity;         // 最大容量
};

// 優先度キューのinterface定義
interface PriorityQueue {
    int getSize();
    bool checkEmpty();
    int getCapacity();
};

// 優先度キューの実装
impl PriorityQueue for PriorityQueueData {
    // キューのサイズを取得
    int getSize() {
        PriorityQueueData pq = self;
        return pq.queue_size;
    }
    
    // キューが空かチェック
    bool checkEmpty() {
        PriorityQueueData pq = self;
        return pq.queue_size == 0;
    }
    
    // キューの容量を取得
    int getCapacity() {
        PriorityQueueData pq = self;
        return pq.capacity;
    }
};

// 無限大を表す定数
const int INF = 999999;
const int MAX_NODES = 8;
const int MAX_EDGES = 30;

// グローバル変数でグラフデータを管理
Graph graph;
Node[8] nodes;
Edge[30] edges;
PriorityQueueData pq_data;  // 優先度キューのデータ
int[64] adjacency_matrix;

// 優先度キューの初期化
void init_priority_queue() {
    pq_data.queue_size = 0;
    pq_data.capacity = 8;
}

// 優先度キューに要素を追加（ラッパー関数）
void pq_push(int node_id, int priority) {
    if (pq_data.queue_size >= pq_data.capacity) {
        println("Error: Priority queue is full");
        return;
    }
    
    // 新しい要素を末尾に追加
    int insert_pos = pq_data.queue_size;
    pq_data.node_ids[insert_pos] = node_id;
    pq_data.priorities[insert_pos] = priority;
    pq_data.queue_size = pq_data.queue_size + 1;
    
    // 挿入ソートで適切な位置に移動
    int i = insert_pos;
    while (i > 0) {
        int prev = i - 1;
        if (pq_data.priorities[i] < pq_data.priorities[prev]) {
            // スワップ
            int temp_id = pq_data.node_ids[i];
            int temp_pri = pq_data.priorities[i];
            pq_data.node_ids[i] = pq_data.node_ids[prev];
            pq_data.priorities[i] = pq_data.priorities[prev];
            pq_data.node_ids[prev] = temp_id;
            pq_data.priorities[prev] = temp_pri;
            i = prev;
        } else {
            break;
        }
    }
}

// 優先度キューから最小要素を取り出す（ラッパー関数）
int pq_pop() {
    if (pq_data.queue_size == 0) {
        return -1;
    }
    
    int min_node = pq_data.node_ids[0];
    int new_size = pq_data.queue_size - 1;
    
    // 要素を前に詰める
    for (int i = 0; i < new_size; i = i + 1) {
        int next = i + 1;
        pq_data.node_ids[i] = pq_data.node_ids[next];
        pq_data.priorities[i] = pq_data.priorities[next];
    }
    
    pq_data.queue_size = new_size;
    return min_node;
}

// 優先度キューが空かチェック（interface経由）
bool pq_isEmpty() {
    PriorityQueue pq_interface = pq_data;
    return pq_interface.checkEmpty();
}

// 優先度キューのサイズを取得（interface経由）
int pq_size() {
    PriorityQueue pq_interface = pq_data;
    return pq_interface.getSize();
}

// グラフの初期化
void init_graph(int num_nodes) {
    graph.node_count = num_nodes;
    graph.edge_count = 0;
    graph.max_edges = MAX_EDGES;
    
    // ノードの初期化
    for (int i = 0; i < MAX_NODES; i = i + 1) {
        nodes[i].id = i;
        nodes[i].distance = INF;
        nodes[i].visited = false;
        nodes[i].prev_node = -1;
    }
    
    // 隣接行列を初期化（INFで埋める）
    for (int i = 0; i < 64; i = i + 1) {
        adjacency_matrix[i] = INF;
    }
    
    // 対角線要素は0（自分自身への距離）
    for (int i = 0; i < MAX_NODES; i = i + 1) {
        adjacency_matrix[i * MAX_NODES + i] = 0;
    }
    
    // 優先度キューの初期化
    init_priority_queue();
}

// エッジの追加
void add_edge(int from, int to, int weight) {
    // 隣接行列に重みを設定
    adjacency_matrix[from * MAX_NODES + to] = weight;
    
    // エッジ配列にも記録
    int idx = graph.edge_count;
    edges[idx].from = from;
    edges[idx].to = to;
    edges[idx].weight = weight;
    graph.edge_count = graph.edge_count + 1;
}

// ノードの距離を更新
void update_node_distance(int node_id, int new_dist, int prev) {
    nodes[node_id].distance = new_dist;
    nodes[node_id].prev_node = prev;
}

// ダイクストラ法の実行（interface版優先度キューを使用）
void dijkstra(int start) {
    // 開始ノードの距離を0に設定
    update_node_distance(start, 0, -1);
    
    println("Starting Dijkstra from node %d", start);
    println("Using interface-based priority queue\n");
    
    // 優先度キューに開始ノードを追加
    pq_push(start, 0);
    
    int iteration = 0;
    
    // 優先度キューが空になるまで繰り返し
    while (!pq_isEmpty()) {
        // 最小距離のノードを取り出す
        int current = pq_pop();
        
        if (current == -1) break;
        
        // 既に訪問済みならスキップ
        if (nodes[current].visited) continue;
        
        nodes[current].visited = true;
        iteration = iteration + 1;
        
        println("Iteration %d: Processing node %d (distance: %d)", 
                iteration, current, nodes[current].distance);
        
        // 隣接ノードの距離を更新
        for (int neighbor = 0; neighbor < graph.node_count; neighbor = neighbor + 1) {
            int weight = adjacency_matrix[current * MAX_NODES + neighbor];
            
            if (!nodes[neighbor].visited && weight != INF) {
                int new_distance = nodes[current].distance + weight;
                
                if (new_distance < nodes[neighbor].distance) {
                    update_node_distance(neighbor, new_distance, current);
                    pq_push(neighbor, new_distance);
                    println("  -> Updated node %d: distance = %d (via node %d)", 
                            neighbor, new_distance, current);
                }
            }
        }
    }
    
    println("Algorithm completed in %d iterations", iteration);
}

// 経路の復元と表示
void print_path(int start, int end) {
    if (nodes[end].distance == INF) {
        println("No path exists from %d to %d", start, end);
        return;
    }
    
    println("Path from %d to %d (distance: %d):", start, end, nodes[end].distance);
    
    // 経路を配列に格納（逆順）
    int[8] path;
    int path_length = 0;
    int current = end;
    
    while (current != -1) {
        path[path_length] = current;
        path_length = path_length + 1;
        current = nodes[current].prev_node;
    }
    
    // 正順で表示
    print("  ");
    for (int i = path_length - 1; i >= 0; i = i - 1) {
        print("%d", path[i]);
        if (i > 0) print(" -> ");
    }
    println("");
}

// 結果の表示
void print_results(int start) {
    println("\n=== Dijkstra's Algorithm Results ===");
    println("Starting from node: %d", start);
    println("\nShortest distances:");
    
    for (int i = 0; i < graph.node_count; i = i + 1) {
        if (nodes[i].distance == INF) {
            println("Node %d: UNREACHABLE", i);
        } else {
            println("Node %d: distance = %d", i, nodes[i].distance);
        }
    }
    
    println("\nShortest paths:");
    for (int i = 0; i < graph.node_count; i = i + 1) {
        if (i != start && nodes[i].distance != INF) {
            print_path(start, i);
        }
    }
}

// グラフの構造を表示
void print_graph() {
    println("=== Graph Structure ===");
    println("Nodes: %d, Edges: %d", graph.node_count, graph.edge_count);
    println("\nEdge list:");
    
    for (int i = 0; i < graph.edge_count; i = i + 1) {
        println("  Edge %d: %d -> %d (weight: %d)", 
                i, edges[i].from, edges[i].to, edges[i].weight);
    }
    
    println("\nAdjacency information:");
    for (int i = 0; i < graph.node_count; i = i + 1) {
        print("Node %d connects to: ", i);
        bool has_edge = false;
        
        for (int j = 0; j < graph.node_count; j = j + 1) {
            int weight = adjacency_matrix[i * MAX_NODES + j];
            if (weight != INF && weight != 0) {
                if (has_edge) print(", ");
                print("%d(w:%d)", j, weight);
                has_edge = true;
            }
        }
        
        if (!has_edge) print("none");
        println("");
    }
    println("");
}

int main() {
    println("=== Dijkstra's Shortest Path Algorithm ===");
    println("Interface/Impl pattern implementation\n");
    
    // グラフの初期化（7ノード）
    init_graph(7);
    
    println("Building graph...");
    add_edge(0, 1, 4);   // 0 -> 1: cost 4
    add_edge(0, 6, 7);   // 0 -> 6: cost 7
    add_edge(1, 2, 9);   // 1 -> 2: cost 9
    add_edge(1, 6, 11);  // 1 -> 6: cost 11
    add_edge(2, 3, 6);   // 2 -> 3: cost 6
    add_edge(2, 5, 2);   // 2 -> 5: cost 2
    add_edge(3, 4, 8);   // 3 -> 4: cost 8
    add_edge(4, 6, 5);   // 4 -> 6: cost 5
    add_edge(5, 3, 7);   // 5 -> 3: cost 7
    add_edge(5, 4, 4);   // 5 -> 4: cost 4
    add_edge(6, 5, 1);   // 6 -> 5: cost 1
    
    println("Graph created with %d nodes and %d edges\n", graph.node_count, graph.edge_count);
    
    // グラフ構造の表示
    print_graph();
    
    // ダイクストラ法の実行
    int start_node = 0;
    println("Executing Dijkstra's algorithm from node %d...", start_node);
    dijkstra(start_node);
    
    // 結果の表示
    print_results(start_node);
    
    // 統計情報
    println("\n=== Graph Statistics ===");
    int reachable = 0;
    for (int i = 0; i < graph.node_count; i = i + 1) {
        if (nodes[i].distance != INF) {
            reachable = reachable + 1;
        }
    }
    println("Reachable nodes: %d / %d", reachable, graph.node_count);
    println("Total edges: %d", graph.edge_count);
    
    // パフォーマンス情報
    println("\n=== Implementation Details ===");
    println("Design Pattern: Interface/Implementation separation");
    println("Data structures:");
    println("  - PriorityQueue interface: defines queue operations");
    println("  - PriorityQueueData struct: implements the interface");
    println("  - Node struct: stores node information");
    println("  - Edge struct: stores edge information");
    println("  - Graph struct: stores graph metadata");
    println("\nInterface methods:");
    println("  - push(node_id, priority): add element to queue");
    println("  - pop(): remove and return minimum element");
    println("  - isEmpty(): check if queue is empty");
    println("  - size(): get current queue size");
    println("\nAlgorithm: Dijkstra with interface-based priority queue");
    println("Time Complexity: O((V+E) log V)");
    println("Space Complexity: O(V^2) for adjacency matrix + O(E) for edges");
    
    return 0;
}
