// Map<K, V> - Binary Search Tree implementation
// 
// 構造:
//   - 各ノードは key, value を持つ
//   - left_ptr, right_ptr で左右の子ノードを指す (void* で管理、nullptrで子なしを判定)
//   - 再帰的な挿入・検索により任意の深さの木構造をサポート
// 
// 計算量 (バランスされていない場合):
//   - insert: 平均 O(log n)、最悪 O(n)
//   - get: 平均 O(log n)、最悪 O(n)
//   - contains: 平均 O(log n)、最悪 O(n)
//   - remove: O(1) - 簡易実装（has_valueをfalseにするのみ）
// 
// 制限事項:
//   - 平衡機能なし（AVL木やRed-Black木ではない）
//   - 完全な削除は未実装（メモリリークの可能性あり）
//   - 挿入順によっては木が偏る可能性あり
// 
export interface MapOps<K, V> {
    // Public API
    void insert(K key, V value);
    V get(K key);
    bool contains(K key);
    void remove(K key);
    int size();
    bool is_empty();
    void clear();
    
    // Internal helper methods (AVL implementation details - will be private in impl)
    int get_height(void* node);
    void update_height(void* node);
    int get_balance(void* node);
    void* rotate_right(void* y);
    void* rotate_left(void* x);
    void* create_node(K key, V value);
    void* insert_to_node(void* node, K key, V value);
    V get_from_node(void* node, K key);
    bool contains_in_node(void* node, K key);
}

export struct Map<K, V> {
    long root;  // ルートノードへのポインタのアドレス（0で空のMapを表す）
    long count;   // 要素数（longに変更してメモリアライメント問題を回避）
};

impl MapOps<K, V> for Map<K, V> {
    // Private: ノードの高さを取得
    private int get_height(void* node) {
        if (node == nullptr) {
            return 0;
        }
        // height at offset 24
        int* height_ptr = (int*)((long)node + 24);
        return *height_ptr;
    }
    
    // Private: ノードの高さを更新
    private void update_height(void* node) {
        if (node == nullptr) {
            return;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        void** left_ptr_loc = (void**)((long)node + left_ptr_offset);
        void** right_ptr_loc = (void**)((long)node + right_ptr_offset);
        void* left_child = *left_ptr_loc;
        void* right_child = *right_ptr_loc;
        
        int left_h = self.get_height(left_child);
        int right_h = self.get_height(right_child);
        int max_h = left_h;
        if (right_h > left_h) {
            max_h = right_h;
        }
        
        // height offset
        long height_offset = sizeof(K) + sizeof(V) + sizeof(int);
        int* height_ptr = (int*)((long)node + height_offset);
        *height_ptr = max_h + 1;
    }
    
    // Private: バランス因子を計算
    private int get_balance(void* node) {
        if (node == nullptr) {
            return 0;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        void** left_ptr_loc = (void**)((long)node + left_ptr_offset);
        void** right_ptr_loc = (void**)((long)node + right_ptr_offset);
        void* left_child = *left_ptr_loc;
        void* right_child = *right_ptr_loc;
        
        return self.get_height(left_child) - self.get_height(right_child);
    }
    
    // Private: 右回転
    private void* rotate_right(void* y) {
        if (y == nullptr) {
            return nullptr;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        void** y_left_loc = (void**)((long)y + left_ptr_offset);
        void* x = *y_left_loc;
        
        if (x == nullptr) {
            return y;
        }
        
        void** x_right_loc = (void**)((long)x + right_ptr_offset);
        void* T2 = *x_right_loc;
        
        // 回転実行
        *x_right_loc = y;
        *y_left_loc = T2;
        
        // 高さ更新
        self.update_height(y);
        self.update_height(x);
        
        return x;
    }
    
    // Private: 左回転
    private void* rotate_left(void* x) {
        if (x == nullptr) {
            return nullptr;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        void** x_right_loc = (void**)((long)x + right_ptr_offset);
        void* y = *x_right_loc;
        
        if (y == nullptr) {
            return x;
        }
        
        void** y_left_loc = (void**)((long)y + left_ptr_offset);
        void* T2 = *y_left_loc;
        
        // 回転実行
        *y_left_loc = x;
        *x_right_loc = T2;
        
        // 高さ更新
        self.update_height(x);
        self.update_height(y);
        
        return y;
    }
    
    // Private: ノード作成
    private void* create_node(K key, V value) {
        // Cbインタプリタは8バイト境界アライメントが必須
        // すべてのフィールドを8バイト境界に配置する
        int total_size = 56;  // 7 fields * 8 bytes each
        void* new_node = malloc(total_size);
        
        // すべてのフィールドを8バイト境界に配置
        // key (offset 0)
        K* key_ptr = (K*)new_node;
        *key_ptr = key;
        
        // value (offset 8)
        V* value_ptr = (V*)((long)new_node + 8);
        *value_ptr = value;
        
        // has_value = true (offset 16)
        int* has_value_ptr = (int*)((long)new_node + 16);
        *has_value_ptr = 1;
        
        // height = 1 (offset 24)
        int* height_ptr = (int*)((long)new_node + 24);
        *height_ptr = 1;
        
        // left_ptr = nullptr (offset 32)
        void** left_loc = (void**)((long)new_node + 32);
        *left_loc = nullptr;
        
        // right_ptr = nullptr (offset 40)
        void** right_loc = (void**)((long)new_node + 40);
        *right_loc = nullptr;
        
        // count = 1 (offset 48)
        int* count_ptr = (int*)((long)new_node + 48);
        *count_ptr = 1;
        
        return new_node;
    }
    
    // Private: 再帰的に子ノードへ挿入（AVLバランシング付き）
    private void* insert_to_node(void* node, K key, V value) {
        // ベースケース: ノードが空なら新しいノードを作成
        if (node == nullptr) {
            return self.create_node(key, value);
        }
        
        K* node_key_ptr = (K*)node;
        K node_key = *node_key_ptr;
        
        // キーが等しい場合は値を更新
        if (key == node_key) {
            // value offset
            long value_offset = sizeof(K);
            V* value_ptr = (V*)((long)node + value_offset);
            *value_ptr = value;
            return node;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        void** left_ptr_loc = (void**)((long)node + left_ptr_offset);
        void** right_ptr_loc = (void**)((long)node + right_ptr_offset);
        
        // 再帰的に挿入
        if (key < node_key) {
            void* new_left = self.insert_to_node(*left_ptr_loc, key, value);
            *left_ptr_loc = new_left;
        } else {
            void* new_right = self.insert_to_node(*right_ptr_loc, key, value);
            *right_ptr_loc = new_right;
        }
        
        // TODO: AVL balancing temporarily disabled for debugging
        // self.update_height(node);
        // int balance = self.get_balance(node);
        // ... rotation logic ...
        
        return node;
    }
    
    // Private: ノードからの取得
    private V get_from_node(void* node, K key) {
        if (node == nullptr) {
            V default_value;
            return default_value;
        }
        
        K* node_key_ptr = (K*)node;
        K node_key = *node_key_ptr;
        if (key == node_key) {
            // value offset
            long value_offset = sizeof(K);
            V* node_value_ptr = (V*)((long)node + value_offset);
            return *node_value_ptr;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        if (key < node_key) {
            long child_addr = (long)node + left_ptr_offset;
            void** child_ptr_loc = (void**)child_addr;
            void* child_node = *child_ptr_loc;
            return self.get_from_node(child_node, key);
        } else {
            long child_addr = (long)node + right_ptr_offset;
            void** child_ptr_loc = (void**)child_addr;
            void* child_node = *child_ptr_loc;
            return self.get_from_node(child_node, key);
        }
    }
    
    // Private: ノードに含まれるかチェック
    private bool contains_in_node(void* node, K key) {
        if (node == nullptr) {
            return false;
        }
        
        K* node_key_ptr = (K*)node;
        K node_key = *node_key_ptr;
        if (key == node_key) {
            // has_value offset
            long has_value_offset = sizeof(K) + sizeof(V);
            int* has_value_ptr = (int*)((long)node + has_value_offset);
            return *has_value_ptr != 0;
        }
        
        // left_ptr and right_ptr offsets
        long left_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int);
        long right_ptr_offset = sizeof(K) + sizeof(V) + sizeof(int) + sizeof(int) + sizeof(void*);
        
        if (key < node_key) {
            long child_addr = (long)node + left_ptr_offset;
            void** child_ptr_loc = (void**)child_addr;
            void* child_node = *child_ptr_loc;
            return self.contains_in_node(child_node, key);
        } else {
            long child_addr = (long)node + right_ptr_offset;
            void** child_ptr_loc = (void**)child_addr;
            void* child_node = *child_ptr_loc;
            return self.contains_in_node(child_node, key);
        }
    }
    
    // Public: 挿入
    void insert(K key, V value) {
        void* root_ptr = (void*)self.root;
        void* new_root = self.insert_to_node(root_ptr, key, value);
        self.root = (long)new_root;
        // TODO: countの正確なカウントは後で実装（現在は概算）
        self.count = self.count + 1;
    }
    
    // Public: 取得
    V get(K key) {
        void* root_ptr = (void*)self.root;
        return self.get_from_node(root_ptr, key);
    }
    
    // Public: 含まれるかチェック
    bool contains(K key) {
        void* root_ptr = (void*)self.root;
        return self.contains_in_node(root_ptr, key);
    }
    
    // Public: 削除（簡易実装：完全な削除は未実装）
    void remove(K key) {
        // TODO: 完全な削除実装（ノードの削除とAVLリバランス）
        if (self.count > 0) {
            self.count = self.count - 1;
        }
    }
    
    // Public: サイズ取得
    int size() {
        return self.count;
    }
    
    // Public: 空かチェック
    bool is_empty() {
        return self.root == 0;
    }
    
    // Public: クリア
    void clear() {
        // TODO: 全ノードのfree()
        self.root = 0;
        self.count = 0;
    }
}

// ジェネリックコンストラクタとデストラクタ
impl Map<K, V> {
    // デフォルトコンストラクタ
    self() {
        self.root = 0;
        self.count = 0;
    }
    
    // デストラクタ
    ~self() {
        // TODO: 全ノードのfree()を再帰的に実行
        self.root = 0;
        self.count = 0;
    }
}
