// Map<K, V> - 二分探索木（BST）ベースの連想配列
// 各Mapノード自体がキー・値のペアと左右の子を持つ木構造
// 基本操作: insert, get, contains は O(log n) (平均)、O(n) (最悪)

// Map操作のインターフェース
export interface MapOps<K, V> {
    void insert(K key, V value);
    V get(K key);
    bool contains(K key);
    void remove(K key);
    int size();
    bool is_empty();
    void clear();
}

// Map構造体 - 木構造のノード
// left と right は Map 型そのものを保持（値型）
export struct Map<K, V> {
    K key;
    V value;
    bool has_value;     // このノードが有効なエントリかどうか
    bool has_left;      // 左の子が存在するか
    bool has_right;     // 右の子が存在するか
    void* left_ptr;     // 左の子ノードへのポインタ（内部的にMap<K,V>*）
    void* right_ptr;    // 右の子ノードへのポインタ（内部的にMap<K,V>*）
    int count;          // このサブツリーの要素数
};

// MapOpsインターフェースの実装
impl MapOps<K, V> for Map<K, V> {
    // キー・値のペアを挿入または更新
    void insert(K key, V value) {
        map_insert<K, V>(self, key, value);
    }
    
    
    V get(K key) {
        return map_get<K, V>(self, key);
    }
    
    bool contains(K key) {
        return map_contains<K, V>(self, key);
    }
    
    void remove(K key) {
        map_remove<K, V>(self, key);
    }
    
    int size() {
        return map_size<K, V>(self);
    }
    
    bool is_empty() {
        return map_is_empty<K, V>(self);
    }
    
    void clear() {
        map_clear<K, V>(self);
    }
}

// コンストラクタとデストラクタ
impl Map<K, V> {
    // デフォルトコンストラクタ - 空のマップを作成
    self() {
        self.has_value = false;
        self.has_left = false;
        self.has_right = false;
        self.left_ptr = nullptr;
        self.right_ptr = nullptr;
        self.count = 0;
    }
    
    // デストラクタ - すべての子ノードを解放
    ~self() {
        if (self.has_left) {
            Map<K, V>& left_node = map_ptr_to_ref<K, V>(self.left_ptr);
            map_clear<K, V>(left_node);
            free(self.left_ptr);
        }
        
        if (self.has_right) {
            Map<K, V>& right_node = map_ptr_to_ref<K, V>(self.right_ptr);
            map_clear<K, V>(right_node);
            free(self.right_ptr);
        }
    }
}

// ヘルパー関数: ポインタから各フィールドにアクセス
// Map<K, V> のメモリレイアウト:
// [K key][V value][bool has_value][bool has_left][bool has_right][void* left_ptr][void* right_ptr][int count]

export K map_node_get_key<K, V>(void* node) {
    return array_get(node, 0);
}

export V map_node_get_value<K, V>(void* node) {
    void* value_ptr = node + sizeof(K);
    return array_get(value_ptr, 0);
}

export void map_node_set_value<K, V>(void* node, V value) {
    void* value_ptr = node + sizeof(K);
    array_set(value_ptr, 0, value);
}

export bool map_node_get_has_value<K, V>(void* node) {
    void* has_value_ptr = node + sizeof(K) + sizeof(V);
    return array_get_int(has_value_ptr, 0) != 0;
}

export void map_node_set_has_value<K, V>(void* node, bool value) {
    void* has_value_ptr = node + sizeof(K) + sizeof(V);
    array_set_int(has_value_ptr, 0, value ? 1 : 0);
}

export bool map_node_get_has_left<K, V>(void* node) {
    void* has_left_ptr = node + sizeof(K) + sizeof(V) + 4;
    return array_get_int(has_left_ptr, 0) != 0;
}

export void map_node_set_has_left<K, V>(void* node, bool value) {
    void* has_left_ptr = node + sizeof(K) + sizeof(V) + 4;
    array_set_int(has_left_ptr, 0, value ? 1 : 0);
}

export bool map_node_get_has_right<K, V>(void* node) {
    void* has_right_ptr = node + sizeof(K) + sizeof(V) + 8;
    return array_get_int(has_right_ptr, 0) != 0;
}

export void map_node_set_has_right<K, V>(void* node, bool value) {
    void* has_right_ptr = node + sizeof(K) + sizeof(V) + 8;
    array_set_int(has_right_ptr, 0, value ? 1 : 0);
}

export void* map_node_get_left_ptr<K, V>(void* node) {
    void* left_ptr_loc = node + sizeof(K) + sizeof(V) + 12;
    return array_get(left_ptr_loc, 0);
}

export void map_node_set_left_ptr<K, V>(void* node, void* left) {
    void* left_ptr_loc = node + sizeof(K) + sizeof(V) + 12;
    array_set(left_ptr_loc, 0, left);
}

export void* map_node_get_right_ptr<K, V>(void* node) {
    void* right_ptr_loc = node + sizeof(K) + sizeof(V) + 12 + 8;
    return array_get(right_ptr_loc, 0);
}

export void map_node_set_right_ptr<K, V>(void* node, void* right) {
    void* right_ptr_loc = node + sizeof(K) + sizeof(V) + 12 + 8;
    array_set(right_ptr_loc, 0, right);
}

export int map_node_get_count<K, V>(void* node) {
    void* count_ptr = node + sizeof(K) + sizeof(V) + 12 + 16;
    return array_get_int(count_ptr, 0);
}

export void map_node_set_count<K, V>(void* node, int count) {
    void* count_ptr = node + sizeof(K) + sizeof(V) + 12 + 16;
    array_set_int(count_ptr, 0, count);
}

// void* ノードを使った再帰ヘルパー関数
export void map_insert_into_node<K, V>(void* node, K key, V value) {
    K node_key = map_node_get_key<K, V>(node);
    bool has_value = map_node_get_has_value<K, V>(node);
    
    if (!has_value) {
        // このノードが空の場合
        array_set(node, 0, key);
        map_node_set_value<K, V>(node, value);
        map_node_set_has_value<K, V>(node, true);
        map_node_set_count<K, V>(node, 1);
    } else if (key == node_key) {
        // キーが一致、値を更新
        map_node_set_value<K, V>(node, value);
    } else if (key < node_key) {
        // 左の子へ
        bool has_left = map_node_get_has_left<K, V>(node);
        if (!has_left) {
            // 新しい左の子を作成
            void* left = malloc(sizeof(Map<K, V>));
            array_set(left, 0, key);
            map_node_set_value<K, V>(left, value);
            map_node_set_has_value<K, V>(left, true);
            map_node_set_has_left<K, V>(left, false);
            map_node_set_has_right<K, V>(left, false);
            map_node_set_left_ptr<K, V>(left, nullptr);
            map_node_set_right_ptr<K, V>(left, nullptr);
            map_node_set_count<K, V>(left, 1);
            
            map_node_set_left_ptr<K, V>(node, left);
            map_node_set_has_left<K, V>(node, true);
            
            int count = map_node_get_count<K, V>(node);
            map_node_set_count<K, V>(node, count + 1);
        } else {
            // 再帰的に左の子に挿入
            void* left = map_node_get_left_ptr<K, V>(node);
            int old_count = map_node_get_count<K, V>(left);
            map_insert_into_node<K, V>(left, key, value);
            int new_count = map_node_get_count<K, V>(left);
            if (new_count > old_count) {
                int count = map_node_get_count<K, V>(node);
                map_node_set_count<K, V>(node, count + 1);
            }
        }
    } else {
        // 右の子へ
        bool has_right = map_node_get_has_right<K, V>(node);
        if (!has_right) {
            // 新しい右の子を作成
            void* right = malloc(sizeof(Map<K, V>));
            array_set(right, 0, key);
            map_node_set_value<K, V>(right, value);
            map_node_set_has_value<K, V>(right, true);
            map_node_set_has_left<K, V>(right, false);
            map_node_set_has_right<K, V>(right, false);
            map_node_set_left_ptr<K, V>(right, nullptr);
            map_node_set_right_ptr<K, V>(right, nullptr);
            map_node_set_count<K, V>(right, 1);
            
            map_node_set_right_ptr<K, V>(node, right);
            map_node_set_has_right<K, V>(node, true);
            
            int count = map_node_get_count<K, V>(node);
            map_node_set_count<K, V>(node, count + 1);
        } else {
            // 再帰的に右の子に挿入
            void* right = map_node_get_right_ptr<K, V>(node);
            int old_count = map_node_get_count<K, V>(right);
            map_insert_into_node<K, V>(right, key, value);
            int new_count = map_node_get_count<K, V>(right);
            if (new_count > old_count) {
                int count = map_node_get_count<K, V>(node);
                map_node_set_count<K, V>(node, count + 1);
            }
        }
    }
}

// グローバル関数（interface メソッドと同じ実装を直接提供）
export void map_insert<K, V>(Map<K, V>& m, K key, V value) {
    if (!m.has_value) {
        // ルートノードが空の場合、ここに格納
        m.key = key;
        m.value = value;
        m.has_value = true;
        m.count = 1;
    } else if (key == m.key) {
        // キーが一致、値を更新
        m.value = value;
    } else if (key < m.key) {
        // 左の子へ
        if (!m.has_left) {
            // 新しい左の子を作成
            m.left_ptr = malloc(sizeof(Map<K, V>));
            map_insert_into_node<K, V>(m.left_ptr, key, value);
            m.has_left = true;
            m.count = m.count + 1;
        } else {
            // 再帰的に左の子に挿入
            int old_count = map_node_get_count<K, V>(m.left_ptr);
            map_insert_into_node<K, V>(m.left_ptr, key, value);
            int new_count = map_node_get_count<K, V>(m.left_ptr);
            if (new_count > old_count) {
                m.count = m.count + 1;
            }
        }
    } else {
        // 右の子へ
        if (!m.has_right) {
            // 新しい右の子を作成
            m.right_ptr = malloc(sizeof(Map<K, V>));
            map_insert_into_node<K, V>(m.right_ptr, key, value);
            m.has_right = true;
            m.count = m.count + 1;
        } else {
            // 再帰的に右の子に挿入
            int old_count = map_node_get_count<K, V>(m.right_ptr);
            map_insert_into_node<K, V>(m.right_ptr, key, value);
            int new_count = map_node_get_count<K, V>(m.right_ptr);
            if (new_count > old_count) {
                m.count = m.count + 1;
            }
        }
    }
}

export V map_get_from_node<K, V>(void* node, K key) {
    bool has_value = map_node_get_has_value<K, V>(node);
    if (!has_value) {
        V dummy;
        return dummy;
    }
    
    K node_key = map_node_get_key<K, V>(node);
    if (key == node_key) {
        return map_node_get_value<K, V>(node);
    } else if (key < node_key) {
        bool has_left = map_node_get_has_left<K, V>(node);
        if (has_left) {
            void* left = map_node_get_left_ptr<K, V>(node);
            return map_get_from_node<K, V>(left, key);
        }
    } else {
        bool has_right = map_node_get_has_right<K, V>(node);
        if (has_right) {
            void* right = map_node_get_right_ptr<K, V>(node);
            return map_get_from_node<K, V>(right, key);
        }
    }
    
    V dummy;
    return dummy;
}

export V map_get<K, V>(Map<K, V>& m, K key) {
    if (!m.has_value) {
        V dummy;
        return dummy;
    }
    
    if (key == m.key) {
        return m.value;
    } else if (key < m.key && m.has_left) {
        return map_get_from_node<K, V>(m.left_ptr, key);
    } else if (key > m.key && m.has_right) {
        return map_get_from_node<K, V>(m.right_ptr, key);
    }
    
    V dummy;
    return dummy;
}

export bool map_contains_in_node<K, V>(void* node, K key) {
    bool has_value = map_node_get_has_value<K, V>(node);
    if (!has_value) {
        return false;
    }
    
    K node_key = map_node_get_key<K, V>(node);
    if (key == node_key) {
        return true;
    } else if (key < node_key) {
        bool has_left = map_node_get_has_left<K, V>(node);
        if (has_left) {
            void* left = map_node_get_left_ptr<K, V>(node);
            return map_contains_in_node<K, V>(left, key);
        }
    } else {
        bool has_right = map_node_get_has_right<K, V>(node);
        if (has_right) {
            void* right = map_node_get_right_ptr<K, V>(node);
            return map_contains_in_node<K, V>(right, key);
        }
    }
    
    return false;
}

export bool map_contains<K, V>(Map<K, V>& m, K key) {
    if (!m.has_value) {
        return false;
    }
    
    if (key == m.key) {
        return true;
    } else if (key < m.key && m.has_left) {
        return map_contains_in_node<K, V>(m.left_ptr, key);
    } else if (key > m.key && m.has_right) {
        return map_contains_in_node<K, V>(m.right_ptr, key);
    }
    
    return false;
}

export void map_remove<K, V>(Map<K, V>& m, K key) {
    if (m.has_value && key == m.key) {
        m.has_value = false;
        m.count = m.count - 1;
    } else if (key < m.key && m.has_left) {
        Map<K, V>& left_node = map_ptr_to_ref<K, V>(m.left_ptr);
        int old_count = left_node.count;
        map_remove<K, V>(left_node, key);
        if (left_node.count < old_count) {
            m.count = m.count - 1;
        }
    } else if (key > m.key && m.has_right) {
        Map<K, V>& right_node = map_ptr_to_ref<K, V>(m.right_ptr);
        int old_count = right_node.count;
        map_remove<K, V>(right_node, key);
        if (right_node.count < old_count) {
            m.count = m.count - 1;
        }
    }
}

export int map_size<K, V>(Map<K, V>& m) {
    if (m.has_value) {
        return m.count;
    }
    return 0;
}

export bool map_is_empty<K, V>(Map<K, V>& m) {
    return !m.has_value || m.count == 0;
}

export void map_clear<K, V>(Map<K, V>& m) {
    if (m.has_left) {
        Map<K, V>& left_node = map_ptr_to_ref<K, V>(m.left_ptr);
        map_clear<K, V>(left_node);
        free(m.left_ptr);
        m.left_ptr = nullptr;
        m.has_left = false;
    }
    
    if (m.has_right) {
        Map<K, V>& right_node = map_ptr_to_ref<K, V>(m.right_ptr);
        map_clear<K, V>(right_node);
        free(m.right_ptr);
        m.right_ptr = nullptr;
        m.has_right = false;
    }
    
    m.has_value = false;
    m.count = 0;
}
