// AVL Tree implementation of Map<K, V>
// 
// 特徴:
// - ジェネリック型パラメータK（キー）とV（値）
// - AVL木による自動バランシング（高さバランス保証）
//   - left, right で左右の子ノードを指す
//   - 再帰的な挿入と回転により木の高さを O(log n) に保つ
// 
// 計算量 (AVLバランシングあり):
//   - insert: O(log n) - 保証（回転によるバランシング）
//   - get: O(log n) - 保証
//   - contains: O(log n) - 保証
//   - remove: O(1) - 簡易実装（has_valueをfalseにするのみ）
//   - get_tree_height: O(1) - ルートの高さフィールドを返す
// 
// 制限事項:
//   - 完全な削除は未実装（メモリリークの可能性あり）
//   - remove時のバランシング未実装（削除は論理削除のみ）
// 

// ノード構造体の定義
export struct MapNode<K, V> {
    K key;
    V value;
    bool has_value;
    int height;
    MapNode<K, V>* left;   // 左の子ノード
    MapNode<K, V>* right;  // 右の子ノード
};

export interface MapOps<K, V> {
    // Public API
    void insert(K key, V value);
    V get(K key, V default_val);            // 見つからない場合は指定したデフォルト値を返す
    bool contains(K key);                   // キーの存在確認(エラーハンドリング用)
    void remove(K key);
    int size();
    bool is_empty();
    void clear();
    
    // Enhanced API (v0.11.0+)
    bool try_remove(K key);             // 削除成功でtrue
    int get_tree_height();              // AVL木の高さを取得（バランシング確認用）
    
    // Internal helper methods (private in impl)
    int get_height(MapNode<K, V>* node);
    void update_height(MapNode<K, V>* node);
    int get_balance(MapNode<K, V>* node);
    MapNode<K, V>* create_node(K key, V value);
    MapNode<K, V>* insert_to_node(MapNode<K, V>* node, K key, V value);
    V get_from_node(MapNode<K, V>* node, K key);
    bool contains_in_node(MapNode<K, V>* node, K key);
}

export struct Map<K, V> {
    MapNode<K, V>* root;  // ルートノード
    int count;            // 要素数
};

impl MapOps<K, V> for Map<K, V> {
    // Private: ノードの高さを取得
    private int get_height(MapNode<K, V>* node) {
        if (node == nullptr) {
            return 0;
        }
        return node->height;
    }
    
    // Private: ノードの高さを更新
    private void update_height(MapNode<K, V>* node) {
        if (node == nullptr) {
            return;
        }
        
        int left_h = self.get_height(node->left);
        int right_h = self.get_height(node->right);
        int max_h = left_h;
        if (right_h > left_h) {
            max_h = right_h;
        }
        
        node->height = max_h + 1;
    }
    
    // Private: バランス因子を計算
    private int get_balance(MapNode<K, V>* node) {
        if (node == nullptr) {
            return 0;
        }
        
        return self.get_height(node->left) - self.get_height(node->right);
    }
    
    // Private: 右回転 (AVL用)
    private MapNode<K, V>* rotate_right(MapNode<K, V>* y) {
        if (y == nullptr) {
            return nullptr;
        }
        
        MapNode<K, V>* x = y->left;
        if (x == nullptr) {
            return y;
        }
        
        MapNode<K, V>* T2 = x->right;
        
        // 回転実行
        x->right = y;
        y->left = T2;
        
        // 高さ更新
        self.update_height(y);
        self.update_height(x);
        
        return x;
    }
    
    // Private: 左回転 (AVL用)
    private MapNode<K, V>* rotate_left(MapNode<K, V>* x) {
        if (x == nullptr) {
            return nullptr;
        }
        
        MapNode<K, V>* y = x->right;
        if (y == nullptr) {
            return x;
        }
        
        MapNode<K, V>* T2 = y->left;
        
        // 回転実行
        y->left = x;
        x->right = T2;
        
        // 高さ更新
        self.update_height(x);
        self.update_height(y);
        
        return y;
    }
    
    // Private: ノード作成
    private MapNode<K, V>* create_node(K key, V value) {
        int node_size = sizeof(MapNode<K, V>);
        void* mem = malloc(node_size);
        MapNode<K, V>* new_node = (MapNode<K, V>*)mem;
        
        new_node->key = key;
        new_node->value = value;
        new_node->has_value = true;
        new_node->height = 1;
        new_node->left = nullptr;
        new_node->right = nullptr;
        
        return new_node;
    }
    
    // Private: AVLバランシング付き再帰的挿入
    // AVL木として平衡を保つため、O(log n)の深さを保証
    private MapNode<K, V>* insert_to_node(MapNode<K, V>* node, K key, V value) {
        // ベースケース: ノードが空なら新しいノードを作成
        if (node == nullptr) {
            int node_size = sizeof(MapNode<K, V>);
            void* mem = malloc(node_size);
            MapNode<K, V>* new_node = (MapNode<K, V>*)mem;
            new_node->key = key;
            new_node->value = value;
            new_node->has_value = true;
            new_node->height = 1;
            new_node->left = nullptr;
            new_node->right = nullptr;
            return new_node;
        }
        
        K node_key = node->key;
        
        // キーが等しい場合は値を更新
        if (key == node_key) {
            node->value = value;
            node->has_value = true;
            return node;
        }
        
        // 再帰的に挿入
        if (key < node_key) {
            MapNode<K, V>* left_child = node->left;
            node->left = self.insert_to_node(left_child, key, value);
        } else {
            MapNode<K, V>* right_child = node->right;
            node->right = self.insert_to_node(right_child, key, value);
        }
        
        // 高さを更新
        self.update_height(node);
        
        // バランス因子を取得
        int balance = self.get_balance(node);
        
        // 左部分木が高すぎる場合
        if (balance > 1) {
            MapNode<K, V>* left_child = node->left;
            if (left_child != nullptr) {
                int left_balance = self.get_balance(left_child);
                if (left_balance >= 0) {
                    // 左左ケース - 右回転
                    MapNode<K, V>* x = left_child;
                    MapNode<K, V>* T2 = x->right;
                    x->right = node;
                    node->left = T2;
                    self.update_height(node);
                    self.update_height(x);
                    return x;
                } else {
                    // 左右ケース - 左回転してから右回転
                    MapNode<K, V>* child_y = left_child->right;
                    if (child_y != nullptr) {
                        MapNode<K, V>* child_T2 = child_y->left;
                        child_y->left = left_child;
                        left_child->right = child_T2;
                        self.update_height(left_child);
                        self.update_height(child_y);
                        node->left = child_y;
                    }
                    // 次に右回転
                    MapNode<K, V>* x2 = node->left;
                    if (x2 != nullptr) {
                        MapNode<K, V>* T2_2 = x2->right;
                        x2->right = node;
                        node->left = T2_2;
                        self.update_height(node);
                        self.update_height(x2);
                        return x2;
                    }
                }
            }
        }
        
        // 右部分木が高すぎる場合
        if (balance < -1) {
            MapNode<K, V>* right_child = node->right;
            if (right_child != nullptr) {
                int right_balance = self.get_balance(right_child);
                if (right_balance <= 0) {
                    // 右右ケース - 左回転
                    MapNode<K, V>* y = right_child;
                    MapNode<K, V>* T2 = y->left;
                    y->left = node;
                    node->right = T2;
                    self.update_height(node);
                    self.update_height(y);
                    return y;
                } else {
                    // 右左ケース - 右回転してから左回転
                    MapNode<K, V>* child_x = right_child->left;
                    if (child_x != nullptr) {
                        MapNode<K, V>* child_T2 = child_x->right;
                        child_x->right = right_child;
                        right_child->left = child_T2;
                        self.update_height(right_child);
                        self.update_height(child_x);
                        node->right = child_x;
                    }
                    // 次に左回転
                    MapNode<K, V>* y2 = node->right;
                    if (y2 != nullptr) {
                        MapNode<K, V>* T2_2 = y2->left;
                        y2->left = node;
                        node->right = T2_2;
                        self.update_height(node);
                        self.update_height(y2);
                        return y2;
                    }
                }
            }
        }
        
        return node;
    }
    
    // Private: ノードからの取得
    private V get_from_node(MapNode<K, V>* node, K key) {
        if (node == nullptr) {
            V default_value;
            return default_value;
        }
        
        K node_key = node->key;
        if (key == node_key) {
            V node_value = node->value;
            return node_value;
        }
        
        if (key < node_key) {
            MapNode<K, V>* left_child = node->left;
            return self.get_from_node(left_child, key);
        } else {
            MapNode<K, V>* right_child = node->right;
            return self.get_from_node(right_child, key);
        }
    }
    
    // Private: ノードに含まれるかチェック
    private bool contains_in_node(MapNode<K, V>* node, K key) {
        if (node == nullptr) {
            return false;
        }
        
        K node_key = node->key;
        
        if (key == node_key) {
            bool has_val = node->has_value;
            return has_val;
        }
        
        if (key < node_key) {
            MapNode<K, V>* left_child = node->left;
            return self.contains_in_node(left_child, key);
        } else {
            MapNode<K, V>* right_child = node->right;
            return self.contains_in_node(right_child, key);
        }
    }
    
    // Public: 挿入
    void insert(K key, V value) {
        // Check if key already exists BEFORE insertion
        bool key_exists = self.contains(key);
        
        // Insert node (will create new or update existing)
        self.root = self.insert_to_node(self.root, key, value);
        
        // Increment count only if this was a NEW insertion
        if (!key_exists) {
            self.count = self.count + 1;
        }
    }
    
    // Public: 取得(デフォルト値指定版)
    V get(K key, V default_value) {
        MapNode<K, V>* node = self.root;
        
        while (node != nullptr) {
            K node_key = node->key;
            
            if (key == node_key) {
                bool has_val = node->has_value;
                if (has_val) {
                    V the_value = node->value;
                    return the_value;
                }
                return default_value;
            }
            
            if (key < node_key) {
                node = node->left;
            } else {
                node = node->right;
            }
        }
        
        return default_value;
    }
    
    // Public: 含まれるかチェック
    bool contains(K key) {
        // Inline implementation to avoid private method call
        MapNode<K, V>* node = self.root;
        
        // Iterative search instead of recursive
        while (node != nullptr) {
            K node_key = node->key;
            
            if (key == node_key) {
                // Check if the value is marked as present (not deleted)
                bool has_val = node->has_value;
                return has_val;
            }
            
            if (key < node_key) {
                node = node->left;
            } else {
                node = node->right;
            }
        }
        
        return false;
    }
    
    // Public: 削除（簡易実装：has_valueをfalseにする）
    void remove(K key) {
        MapNode<K, V>* node = self.root;
        
        // Iterative search for the key
        while (node != nullptr) {
            K node_key = node->key;
            
            if (key == node_key) {
                // Found the key - mark as deleted if it had a value
                bool had_value = node->has_value;
                if (had_value) {
                    node->has_value = false;
                    if (self.count > 0) {
                        self.count = self.count - 1;
                    }
                }
                return;
            }
            
            if (key < node_key) {
                node = node->left;
            } else {
                node = node->right;
            }
        }
        // Key not found - do nothing
    }
    
    // Public: サイズ取得
    int size() {
        return self.count;
    }
    
    // Public: 空かチェック
    bool is_empty() {
        return self.count == 0;
    }
    
    // Public: クリア
    void clear() {
        // TODO: 全ノードのfree()
        self.root = nullptr;
        self.count = 0;
    }
    
    // Public: 木の高さを取得（AVLバランシング確認用）
    int get_tree_height() {
        return self.get_height(self.root);
    }
    
    // ===== Enhanced API (v0.11.0+) =====
    
    // try_remove: キーを削除し、成功したらtrueを返す
    bool try_remove(K key) {
        MapNode<K, V>* node = self.root;
        
        while (node != nullptr) {
            K node_key = node->key;
            
            if (key == node_key) {
                bool had_value = node->has_value;
                if (had_value) {
                    node->has_value = false;
                    if (self.count > 0) {
                        self.count = self.count - 1;
                    }
                    return true;
                }
                // Key exists but already deleted
                return false;
            }
            
            if (key < node_key) {
                node = node->left;
            } else {
                node = node->right;
            }
        }
        
        // Key not found
        return false;
    }
}

// ジェネリックコンストラクタとデストラクタ
impl Map<K, V> {
    // デフォルトコンストラクタ
    self() {
        self.root = nullptr;
        self.count = 0;
    }
    
    // デストラクタ
    ~self() {
        // TODO: 全ノードのfree()を再帰的に実行
        self.root = nullptr;
        self.count = 0;
    }
}
