// Queue<T> - Generic Dynamic Queue with Linked List
// Part of v0.11.0 Week 3 Day 1: Event Loop Implementation
//
// リンクリスト実装のジェネリックキュー
// - 任意の型Tに対応（int, string, struct, interface, typedefなど）
// - malloc/freeによる動的メモリ管理
// - ノードベースのリンクリストで動的なサイズ
// - デストラクタによる自動メモリ解放
//
// 使用例:
//   Queue<int> int_queue;
//   Queue<string> str_queue;
//   Queue<Point> point_queue;

// キューのノード構造
export struct QueueNode<T> {
    T data;
    void* next;  // 次のノードへのポインタ（void*として扱う）
};

export struct Queue<T> {
    void* front;   // 先頭ノードへのポインタ
    void* rear;    // 末尾ノードへのポインタ
    int length;    // 現在の要素数
};

export interface QueueOps<T> {
    // C++ std::queue style API
    void push(T value);
    T pop();
    T top();
    bool empty();
    int size();
    void clear();
    void destroy();
    
    // Backward compatibility (deprecated but supported)
    void enqueue(T value);
    T dequeue();
    T peek();
    bool is_empty();
}

// =============================================================================
// Queue<T> ジェネリック実装（リンクリスト）
// =============================================================================

impl QueueOps<T> for Queue<T> {
    void push(T value) {
        // 新しいノードのメモリ確保
        // WORKAROUND: sizeof(QueueNode<T>)がvoid*を含めないバグがあるため手動計算
        int node_size = sizeof(T) + sizeof(void*);
        void* node_mem = malloc(node_size);
        
        // ノードのデータ領域にアクセス（構造体レイアウト: data, next）
        // data: オフセット0
        // next: オフセット sizeof(T)
        
        // dataメンバーに値を設定（array_setを使用）
        array_set(node_mem, 0, value);
        
        // nextメンバーにnullptrを設定（オフセット計算）
        int data_size = sizeof(T);
        long node_addr = (long)node_mem;
        long next_addr = node_addr + data_size;
        void** next_ptr = (void**)next_addr;
        *next_ptr = nullptr;
        
        // キューが空の場合
        if (self.rear == nullptr) {
            self.front = node_mem;
            self.rear = node_mem;
        } else {
            // 現在の末尾ノードのnextポインタを更新
            long rear_addr = (long)self.rear;
            long rear_next_addr = rear_addr + data_size;
            void** rear_next_ptr = (void**)rear_next_addr;
            *rear_next_ptr = node_mem;
            
            self.rear = node_mem;
        }
        
        self.length = self.length + 1;
    }
    
    T pop() {
        if (self.length <= 0 || self.front == nullptr) {
            // 空の場合はゼロ初期化された値を返す
            T dummy;
            return dummy;
        }
        
        // array_getでデータを読み取る（array_setと対になる）
        T result = array_get(self.front, 0);
        
        // 次のノードへのポインタを取得
        int data_size = sizeof(T);
        long front_addr = (long)self.front;
        long next_addr = front_addr + data_size;
        void** next_ptr = (void**)next_addr;
        void* next_node = *next_ptr;
        
        // 古い先頭ノードを解放
        free(self.front);
        
        // 先頭を次のノードに更新
        self.front = next_node;
        
        // キューが空になった場合
        if (self.front == nullptr) {
            self.rear = nullptr;
        }
        
        self.length = self.length - 1;
        
        return result;
    }
    
    T top() {
        if (self.length <= 0 || self.front == nullptr) {
            // 空の場合はゼロ初期化された値を返す
            T dummy;
            return dummy;
        }
        
        // frontノードのデータを返す（C++のstd::queue::front()と同じ）
        return array_get(self.front, 0);
    }
    
    bool empty() {
        return self.length == 0;
    }
    
    int size() {
        return self.length;
    }
    
    void clear() {
        // 全ノードを手動で解放
        while (self.front != nullptr) {
            // nextフィールドの位置を計算
            // ノードレイアウト: [T data][void* next]
            int data_size = sizeof(T);
            
            // self.frontはmalloc()が返したアドレスを指すVariable*
            // nextフィールドはdata_sizeオフセットに配置されている
            long node_addr = (long)self.front;
            long next_field_addr = node_addr + data_size;
            
            void** next_field_ptr = (void**)next_field_addr;
            void* next_node = *next_field_ptr;
            
            free(self.front);
            self.front = next_node;
            self.length = self.length - 1;
        }
        
        self.rear = nullptr;
        self.length = 0;
    }
    
    void destroy() {
        // clearと同じ処理
        while (self.front != nullptr) {
            int data_size = sizeof(T);
            long front_addr = (long)self.front;
            long next_addr = front_addr + data_size;
            void** next_ptr = (void**)next_addr;
            void* next_node = *next_ptr;
            
            free(self.front);
            self.front = next_node;
        }
        
        self.rear = nullptr;
        self.length = 0;
    }
    
    // ========================================
    // 後方互換性のためのエイリアス
    // ========================================
    void enqueue(T value) {
        // push()と同じ実装
        int node_size = sizeof(T) + sizeof(void*);
        void* node_mem = malloc(node_size);
        array_set(node_mem, 0, value);
        
        int data_size = sizeof(T);
        long node_addr = (long)node_mem;
        long next_addr = node_addr + data_size;
        void** next_ptr = (void**)next_addr;
        *next_ptr = nullptr;
        
        if (self.rear == nullptr) {
            self.front = node_mem;
            self.rear = node_mem;
        } else {
            long rear_addr = (long)self.rear;
            long rear_next_addr = rear_addr + data_size;
            void** rear_next_ptr = (void**)rear_next_addr;
            *rear_next_ptr = node_mem;
            self.rear = node_mem;
        }
        
        self.length = self.length + 1;
    }
    
    T dequeue() {
        // pop()と同じ実装
        if (self.length <= 0 || self.front == nullptr) {
            T dummy;
            return dummy;
        }
        
        // array_getでデータを読み取る（array_setと対になる）
        T result = array_get(self.front, 0);
        
        int data_size = sizeof(T);
        long front_addr = (long)self.front;
        long next_addr = front_addr + data_size;
        void** next_ptr = (void**)next_addr;
        void* next_node = *next_ptr;
        
        free(self.front);
        self.front = next_node;
        
        if (self.front == nullptr) {
            self.rear = nullptr;
        }
        
        self.length = self.length - 1;
        
        return result;
    }
    
    T peek() {
        // top()と同じ実装
        if (self.length <= 0 || self.front == nullptr) {
            T dummy;
            return dummy;
        }
        
        return array_get(self.front, 0);
    }
    
    bool is_empty() {
        // empty()と同じ実装
        return self.length == 0;
    }
}

// コンストラクタ/デストラクタ：メモリ管理を自動化
impl Queue<T> {
    self() {
        self.front = nullptr;
        self.rear = nullptr;
        self.length = 0;
    }
    ~self() {
        // v0.13.1: デストラクタは現在無効化
        // 
        // 進捗:
        // - void**書き込み機能は実装完了 ✅
        // - デストラクタ内の各ステートメント後にwriteback実装 ✅
        // - ASAN版では正常動作 ✅
        // 
        // 残る問題:
        // - 通常版でセグフォールト発生（最適化関連の未定義動作？）
        // - generic_containers_comprehensiveテストが失敗
        //
        // 回避策:
        // - ユーザーは明示的に clear() または destroy() を呼ぶ
        // - clear()メソッドは正常に動作する
        //
        // TODO v0.14.0: 通常版でのセグフォールト原因を特定して修正
    }
}
