// Vector<T, A: Allocator> - Dynamic array with custom allocator
// Part of Week 2: Vector Implementation
//
// A generic dynamic array that uses a custom allocator for memory management
// This enables:
// - OS environments: Use SystemAllocator (malloc/free)
// - Bare-metal: Use BumpAllocator or custom allocators
// - Zero-cost abstraction: Compile-time dispatch

export interface Allocator {
    void* allocate(int size);
    void deallocate(void* ptr);
}

export struct SystemAllocator {
    int allocation_count;
};

impl Allocator for SystemAllocator {
    void* allocate(int size) {
        println("[SystemAllocator] Allocate %d bytes", size);
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        println("[SystemAllocator] Deallocate");
    }
}

export struct BumpAllocator {
    int buffer_size;
    int current_offset;
};

impl Allocator for BumpAllocator {
    void* allocate(int size) {
        println("[BumpAllocator] Allocate %d bytes (offset=%d)", size, 0);
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        println("[BumpAllocator] Deallocate ignored");
    }
}

// Vector structure with allocator type parameter
export struct Vector<T, A: Allocator> {
    int capacity;
    int length;
    void* data;        // データ領域（将来的に実際のメモリを指す）
};

// VectorOps interface - defines operations for Vector
export interface VectorOps {
    void init(int initial_capacity);
    void push(int value);
    int pop();
    void resize(int new_capacity);
    void info();
    int get_length();
    int get_capacity();
    bool is_empty();
}

// Implementation of VectorOps for Vector<int, SystemAllocator>
impl VectorOps for Vector<int, SystemAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        
        // 実メモリを確保
        self.data = new int[initial_capacity];
        
        println("[Vector<int, SystemAllocator>] Initialized with capacity={initial_capacity}");
        println("[Vector] Allocated memory at {hex(self.data)}");
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            // 容量が足りない場合は自動的にリサイズ
            int new_capacity = self.capacity * 2;
            println("[Vector] Capacity full! Auto-resizing from {self.capacity} to {new_capacity}");
            self.resize(new_capacity);
        }
        
        // 配列に値を書き込み
        array_set_int(self.data, self.length, value);
        self.length = self.length + 1;
        
        println("[Vector] Pushed value={value} at index={self.length - 1}");
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector] Empty! Cannot pop");
            return 0;
        }
        
        self.length = self.length - 1;
        int value = array_get_int(self.data, self.length);
        
        println("[Vector] Popped value={value} from index={self.length}");
        return value;
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector] New capacity {new_capacity} <= current {self.capacity}, no resize needed");
            return;
        }
        
        println("[Vector] Resizing from capacity={self.capacity} to {new_capacity}");
        
        // 新しい配列を確保
        void* new_data = new int[new_capacity];
        
        // 既存データをコピー (memcpyを使用)
        int copy_size = self.length * sizeof(int);
        memcpy(new_data, self.data, copy_size);
        
        println("[Vector] Copied {self.length} elements ({copy_size} bytes)");
        
        // 古い配列を解放
        delete self.data;
        
        // 新しい配列に切り替え
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector] Resize complete (new capacity={new_capacity}, memory at {hex(self.data)})");
    }
    
    void info() {
        println("[Vector] length={self.length}, capacity={self.capacity}, data={hex(self.data)}");
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
}

// Implementation of VectorOps for Vector<int, BumpAllocator>
impl VectorOps for Vector<int, BumpAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        self.data = nullptr;
        println("[Vector<int, BumpAllocator>] Initialized with capacity=%d", initial_capacity);
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            println("[Vector] Capacity full! Need resize (current=%d)", self.capacity);
            return;
        }
        
        println("[Vector] Push value=%d at index=%d", value, self.length);
        self.length = self.length + 1;
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector] Empty! Cannot pop");
            return 0;
        }
        
        self.length = self.length - 1;
        println("[Vector] Pop from index=%d", self.length);
        return 0;  // プレースホルダー
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector] New capacity %d <= current %d, no resize needed", 
                    new_capacity, self.capacity);
            return;
        }
        
        println("[Vector] Resizing from capacity=%d to %d", self.capacity, new_capacity);
        self.capacity = new_capacity;
        println("[Vector] Resize complete (new capacity=%d", new_capacity);
    }
    
    void info() {
        println("[Vector] length=%d, capacity=%d", self.length, self.capacity);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
}

void test_vector_basic() {
    println("=== Testing Vector<T, A: Allocator> ===");
    
    // Test 1: Vector with SystemAllocator
    println("\n--- Test 1: Vector with SystemAllocator ---");
    Vector<int, SystemAllocator> vec1;
    vec1.init(10);
    vec1.info();
    
    vec1.length = 5;
    vec1.capacity = 10;
    vec1.info();
    
    // Test 2: Vector with BumpAllocator
    println("\n--- Test 2: Vector with BumpAllocator ---");
    Vector<int, BumpAllocator> vec2;
    vec2.init(20);
    vec2.info();
    
    vec2.length = 8;
    vec2.capacity = 20;
    vec2.info();
    
    // Test 3: Multiple vectors with different allocators
    println("\n--- Test 3: Multiple vectors coexisting ---");
    Vector<int, SystemAllocator> sys_vec;
    Vector<int, BumpAllocator> bump_vec;
    
    sys_vec.init(5);
    bump_vec.init(15);
    
    println("SystemAllocator vector:");
    sys_vec.info();
    println("BumpAllocator vector:");
    bump_vec.info();
    
    println("\nVector basic test complete");
}

void test_vector_operations() {
    println("\n=== Testing Vector Operations ===");
    
    // Test 1: Push operations
    println("\n--- Test 1: Push operations ---");
    Vector<int, SystemAllocator> vec;
    vec.init(5);
    
    vec.push(10);
    vec.push(20);
    vec.push(30);
    vec.info();
    
    // Test 2: Pop operations
    println("\n--- Test 2: Pop operations ---");
    int val1 = vec.pop();
    int val2 = vec.pop();
    vec.info();
    
    // Test 3: Capacity full scenario
    println("\n--- Test 3: Capacity full ---");
    Vector<int, SystemAllocator> small_vec;
    small_vec.init(3);
    
    small_vec.push(1);
    small_vec.push(2);
    small_vec.push(3);
    small_vec.info();
    
    println("Trying to push when full:");
    small_vec.push(4);  // これでリサイズが発生
    
    // Note: Cbの構造体は値渡しなので、メソッド内のresize()による
    // 変更が呼び出し元に反映されない制限があります
    
    // Test 4: Manual resize operation (新しいベクター使用)
    println("\n--- Test 4: Manual resize operation ---");
    Vector<int, SystemAllocator> resize_vec;
    resize_vec.init(2);
    
    println("Before resize:");
    resize_vec.info();
    
    resize_vec.resize(10);
    
    println("After resize:");
    resize_vec.info();
    
    // Test 5: Pop from empty
    println("\n--- Test 5: Pop from empty ---");
    Vector<int, BumpAllocator> empty_vec;
    empty_vec.init(5);
    
    println("Trying to pop from empty vector:");
    int val = empty_vec.pop();
    
    println("\nVector operations test complete");
}

void test_vector_with_allocators() {
    println("\n=== Testing Vector with Different Allocators ===");
    
    println("\n--- SystemAllocator Vector ---");
    Vector<int, SystemAllocator> sys_vec;
    sys_vec.init(3);
    
    sys_vec.push(100);
    sys_vec.push(200);
    sys_vec.info();
    
    println("\n--- BumpAllocator Vector ---");
    Vector<int, BumpAllocator> bump_vec;
    bump_vec.init(3);
    
    bump_vec.push(100);
    bump_vec.push(200);
    bump_vec.info();
    
    println("\nBoth allocators work with same operations!");
    println("Allocator test complete");
}

void main() {
    test_vector_basic();
    test_vector_operations();
    test_vector_with_allocators();
    
    println("\n╔════════════════════════════════════════════════════════════╗");
    println("║  All Vector tests completed successfully!                 ║");
    println("╚════════════════════════════════════════════════════════════╝");
}
