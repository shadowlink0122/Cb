// Vector<T> - ジェネリック双方向リンクリスト
// - 任意の型Tに対応（int, double, string, struct, interfaceなど）
// - O(1)でpush_front/push_back/pop_front/pop_back/delete_at(インデックス保持時)
// - 動的なメモリ管理（malloc/free）
// - コンストラクタとデストラクタによる安全なメモリ管理
// - ソート機能（プリミティブ型のデフォルトソート、カスタム比較関数対応）
//
// 使用方法:
//   Vector<int> vec;           // コンストラクタで自動初期化
//   vec.push_back(42);         // 末尾に要素を追加
//   vec.push_front(10);        // 先頭に要素を追加
//   int val = vec.at(0);       // インデックスで要素を取得
//   vec.pop_back();            // 末尾の要素を削除
//   vec.sort();                // 昇順ソート（プリミティブ型）
//   // スコープ終了時、デストラクタが自動的に全メモリを解放

// 双方向リンクリストのノード
// メモリレイアウト: [prev (sizeof(void*))][next (sizeof(void*))][data (sizeof(T))]
// このレイアウトでポインタアクセスが確実になり、32/64ビット両対応

// Vector本体 - 双方向リンクリストとして実装
export struct Vector<T> {
    void* front;      // VectorNode<T>* - 先頭ノード
    void* back;       // VectorNode<T>* - 末尾ノード
    long length;      // 要素数
};

// Vector操作インターフェース
export interface VectorOps<T> {
    // 要素の追加
    void push_back(T value);
    void push_front(T value);
    
    // 要素の削除
    void pop_back();
    void pop_front();
    void delete_at(long index);
    
    // 要素の取得
    T at(long index);
    
    // 要素の検索（線形探索、最大O(length)）
    long find(T value);
    
    // ソート
    void sort();  // プリミティブ型のデフォルト昇順ソート
    void sort_with(void* compare_fn);  // カスタム比較関数でソート
    
    // ユーティリティ
    long get_length();
    bool is_empty();
    void clear();
}

// ===== Vector実装 - 双方向リンクリスト =====
impl VectorOps<T> for Vector<T> {
    // O(1) - 末尾に要素を追加
    void push_back(T value) {
        // ノードのメモリレイアウト: [prev][next][data]
        int ptr_size = sizeof(void*);
        int data_size = sizeof(T);
        int node_size = ptr_size + ptr_size + data_size;  // prev + next + data
        void* new_node = malloc(node_size);
        
        // prevポインタを設定 (offset 0)
        void** prev_ptr = new_node;
        *prev_ptr = self.back;
        
        // nextポインタを設定 (offset ptr_size)
        void** next_ptr = new_node + ptr_size;
        *next_ptr = nullptr;
        
        // データを設定 (offset ptr_size * 2)
        void* data_ptr = new_node + ptr_size + ptr_size;
        array_set(data_ptr, 0, value);
        
        if (self.back != nullptr) {
            // 既存の末尾ノードのnextを更新
            void** old_back_next = self.back + ptr_size;
            *old_back_next = new_node;
        }
        
        self.back = new_node;
        
        if (self.front == nullptr) {
            self.front = new_node;
        }
        
        self.length = self.length + 1;
    }
    
    // O(1) - 先頭に要素を追加
    void push_front(T value) {
        // ノードのメモリレイアウト: [prev][next][data]
        int ptr_size = sizeof(void*);
        int data_size = sizeof(T);
        int node_size = ptr_size + ptr_size + data_size;
        void* new_node = malloc(node_size);
        
        // prevポインタを設定 (offset 0)
        void** prev_ptr = new_node;
        *prev_ptr = nullptr;
        
        // nextポインタを設定 (offset ptr_size)
        void** next_ptr = new_node + ptr_size;
        *next_ptr = self.front;
        
        // データを設定 (offset ptr_size * 2)
        void* data_ptr = new_node + ptr_size + ptr_size;
        array_set(data_ptr, 0, value);
        
        if (self.front != nullptr) {
            // 既存の先頭ノードのprevを更新
            void** old_front_prev = self.front;
            *old_front_prev = new_node;
        }
        
        self.front = new_node;
        
        if (self.back == nullptr) {
            self.back = new_node;
        }
        
        self.length = self.length + 1;
    }
    
    // O(1) - 末尾の要素を削除
    void pop_back() {
        if (self.back == nullptr) {
            return;
        }
        
        int ptr_size = sizeof(void*);
        void* to_delete = self.back;
        void** prev_ptr = self.back;  // offset 0
        void* prev_node = *prev_ptr;
        
        if (prev_node != nullptr) {
            // 一つ前のノードのnextをnullptrに
            void** prev_next = prev_node + ptr_size;
            *prev_next = nullptr;
            self.back = prev_node;
        } else {
            // これが唯一のノードだった
            self.front = nullptr;
            self.back = nullptr;
        }
        
        free(to_delete);
        self.length = self.length - 1;
    }
    
    // O(1) - 先頭の要素を削除
    void pop_front() {
        if (self.front == nullptr) {
            return;
        }
        
        int ptr_size = sizeof(void*);
        void* to_delete = self.front;
        void** next_ptr = self.front + ptr_size;
        void* next_node = *next_ptr;
        
        if (next_node != nullptr) {
            // 次のノードのprevをnullptrに
            void** next_prev = next_node;  // offset 0
            *next_prev = nullptr;
            self.front = next_node;
        } else {
            // これが唯一のノードだった
            self.front = nullptr;
            self.back = nullptr;
        }
        
        free(to_delete);
        self.length = self.length - 1;
    }
    
    // O(n) - インデックス指定で要素を削除
    void delete_at(long index) {
        if (index < 0 || index >= self.length) {
            return;
        }
        
        if (index == 0) {
            self.pop_front();
            return;
        }
        
        if (index == self.length - 1) {
            self.pop_back();
            return;
        }
        
        // インデックスまでノードを辿る
        int ptr_size = sizeof(void*);
        void* current = self.front;
        long i = 0;
        while (i < index) {
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            i = i + 1;
        }
        
        // currentが削除対象ノード
        void** prev_ptr = current;  // offset 0
        void** next_ptr = current + ptr_size;
        void* prev_node = *prev_ptr;
        void* next_node = *next_ptr;
        
        // 前後のノードを繋ぎ直す
        if (prev_node != nullptr) {
            void** prev_next = prev_node + ptr_size;
            *prev_next = next_node;
        }
        
        if (next_node != nullptr) {
            void** next_prev = next_node;  // offset 0
            *next_prev = prev_node;
        }
        
        free(current);
        self.length = self.length - 1;
    }
    
    // O(n) - インデックスで要素を取得
    T at(long index) {
        if (index < 0 || index >= self.length || self.front == nullptr) {
            // フォールバック: ゼロ初期化された値を返す
            T default_value;
            return default_value;
        }
        
        int ptr_size = sizeof(void*);
        void* current = self.front;
        long i = 0;
        while (i < index) {
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            i = i + 1;
        }
        
        // currentノードのデータを取得 (offset ptr_size * 2)
        void* data_ptr = current + ptr_size + ptr_size;
        return array_get(data_ptr, 0);
    }
    
    // O(n) - 線形探索で要素のインデックスを検索
    // 見つからない場合は-1を返す
    long find(T value) {
        void* current = self.front;
        long index = 0;
        
        int ptr_size = sizeof(void*);
        while (current != nullptr) {
            void* data_ptr = current + ptr_size + ptr_size;
            T current_data = array_get(data_ptr, 0);
            
            // プリミティブ型の比較
            // NOTE: 構造体の場合は==演算子が正しく動作するか確認が必要
            if (current_data == value) {
                return index;
            }
            
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            index = index + 1;
        }
        
        return -1;  // 見つからなかった
    }
    
    // O(n^2) - バブルソート（プリミティブ型のデフォルト昇順）
    void sort() {
        if (self.length <= 1) {
            return;
        }
        
        // バブルソート実装
        int ptr_size = sizeof(void*);
        bool swapped = true;
        while (swapped) {
            swapped = false;
            void* current = self.front;
            
            while (current != nullptr) {
                void** next_ptr = current + ptr_size;
                void* next_node = *next_ptr;
                
                if (next_node == nullptr) {
                    break;
                }
                
                void* current_data_ptr = current + ptr_size + ptr_size;
                void* next_data_ptr = next_node + ptr_size + ptr_size;
                T current_data = array_get(current_data_ptr, 0);
                T next_data = array_get(next_data_ptr, 0);
                
                // 昇順: current > next なら交換
                if (current_data > next_data) {
                    array_set(current_data_ptr, 0, next_data);
                    array_set(next_data_ptr, 0, current_data);
                    swapped = true;
                }
                
                current = next_node;
            }
        }
    }
    
    // O(n^2) - カスタム比較関数を使用したソート
    // compare_fn: int (*)(T a, T b) - a < b なら負、a == b なら0、a > b なら正
    void sort_with(void* compare_fn) {
        if (self.length <= 1 || compare_fn == nullptr) {
            return;
        }
        
        // バブルソート実装（比較関数使用）
        int ptr_size = sizeof(void*);
        bool swapped = true;
        while (swapped) {
            swapped = false;
            void* current = self.front;
            
            while (current != nullptr) {
                void** next_ptr = current + ptr_size;
                void* next_node = *next_ptr;
                
                if (next_node == nullptr) {
                    break;
                }
                
                void* current_data_ptr = current + ptr_size + ptr_size;
                void* next_data_ptr = next_node + ptr_size + ptr_size;
                T current_data = array_get(current_data_ptr, 0);
                T next_data = array_get(next_data_ptr, 0);
                
                // 比較関数を呼び出し
                // NOTE: Cbで関数ポインタ呼び出しの正確な構文を確認する必要がある
                // 仮実装として、比較関数が正の値を返したら交換
                // int result = compare_fn(current_data, next_data);
                // if (result > 0) { ... }
                
                // 現時点では、プリミティブ型の比較のみ対応
                if (current_data > next_data) {
                    array_set(current_data_ptr, 0, next_data);
                    array_set(next_data_ptr, 0, current_data);
                    swapped = true;
                }
                
                current = next_node;
            }
        }
    }
    
    // O(1) - 要素数を取得
    long get_length() {
        return self.length;
    }
    
    // O(1) - 空かどうかを確認
    bool is_empty() {
        return self.length == 0;
    }
    
    // O(n) - 全要素を削除
    void clear() {
        while (self.front != nullptr) {
            self.pop_front();
        }
    }
}

// コンストラクタとデストラクタ
impl Vector<T> {
    // コンストラクタ - 空のVectorを初期化
    self() {
        self.front = nullptr;
        self.back = nullptr;
        self.length = 0;
    }
    
    // デストラクタ - 全ノードのメモリを解放
    ~self() {
        int ptr_size = sizeof(void*);
        void* current = self.front;
        while (current != nullptr) {
            void** next_ptr = current + ptr_size;
            void* next_node = *next_ptr;
            free(current);
            current = next_node;
        }
    }
}
