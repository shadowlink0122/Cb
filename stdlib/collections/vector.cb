// Vector<T> - TRUE GENERIC IMPLEMENTATION
// impl VectorOps<T> for Vector<T> - Single generic implementation for all types!

export struct Vector<T> {
    void* data;
    int length;
    int capacity;
};

export interface VectorOps<T> {
    void init(int initial_capacity);
    void push(T value);
    T pop();
    T get(int index);
    void* get_ptr(int index);
    void* get_data();
    void set(int index, T value);
    int get_length();
    int get_capacity();
    void clear();
    bool is_empty();
    void reserve(int new_capacity);
}

// ===== TRUE GENERIC IMPLEMENTATION =====
// This single implementation works for ALL types: int, double, string, custom structs!
impl VectorOps<T> for Vector<T> {
    void init(int initial_capacity) {
        // sizeof(T) - Type-aware size calculation
        int element_size = sizeof(T);
        self.data = malloc(initial_capacity * element_size);
        self.length = 0;
        self.capacity = initial_capacity;
    }
    
    void push(T value) {
        if (self.length >= self.capacity) {
            self.reserve(self.capacity * 2);
        }
        // array_set - Generic array operation
        array_set(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    T pop() {
        if (self.length <= 0) {
            // Return first element as fallback
            return array_get(self.data, 0);
        }
        self.length = self.length - 1;
        return array_get(self.data, self.length);
    }
    
    T get(int index) {
        if (index < 0 || index >= self.length) {
            // Return first element as fallback
            return array_get(self.data, 0);
        }
        return array_get(self.data, index);
    }
    
    void* get_ptr(int index) {
        if (index < 0 || index >= self.length) {
            return nullptr;
        }
        int element_size = sizeof(T);
        int offset = index * element_size;
        return self.data + offset;
    }
    
    void* get_data() {
        return self.data;
    }
    
    void set(int index, T value) {
        if (index < 0 || index >= self.length) {
            return;
        }
        array_set(self.data, index, value);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    void clear() {
        self.length = 0;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void reserve(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        int element_size = sizeof(T);
        void* new_data = malloc(new_capacity * element_size);
        memcpy(new_data, self.data, self.length * element_size);
        free(self.data);
        
        self.data = new_data;
        self.capacity = new_capacity;
    }
}

// Generic destructor - works for all types!
impl Vector<T> {
    ~self() {
        if (self.data != nullptr) {
            free(self.data);
        }
    }
}
