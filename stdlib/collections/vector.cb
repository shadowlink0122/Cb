// Vector<T> - ジェネリック動的配列
// - 任意の型Tに対応（int, double, string, struct, interfaceなど）
// - 動的なメモリ管理（malloc/free）
// - 自動リサイズ機能
// - デフォルトコンストラクタとデストラクタによる安全なメモリ管理
//
// 使用方法:
//   Vector<int> vec;      // デフォルトコンストラクタで安全に初期化
//   vec.init(10);         // 初期容量10で初期化
//   vec.push(42);         // 要素を追加
//   int val = vec.pop();  // 要素を取得
//   // スコープ終了時、デストラクタが自動的にメモリを解放

export struct Vector<T> {
    void* data;
    int length;
    int capacity;
};

export interface VectorOps<T> {
    void init(int initial_capacity);
    void push(T value);
    T pop();
    T get(int index);
    void* get_ptr(int index);
    void* get_data();
    void set(int index, T value);
    int get_length();
    int get_capacity();
    bool is_empty();
    void reserve(int new_capacity);
}

// ===== TRUE GENERIC IMPLEMENTATION =====
// This single implementation works for ALL types: int, double, string, custom structs!
impl VectorOps<T> for Vector<T> {
    void init(int initial_capacity) {
        // sizeof(T) - Type-aware size calculation
        int element_size = sizeof(T);
        self.data = malloc(initial_capacity * element_size);
        self.length = 0;
        self.capacity = initial_capacity;
    }
    
    void push(T value) {
        if (self.length >= self.capacity) {
            self.reserve(self.capacity * 2);
        }
        // array_set - Generic array operation
        array_set(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    T pop() {
        if (self.length <= 0) {
            // Return first element as fallback
            return array_get(self.data, 0);
        }
        self.length = self.length - 1;
        return array_get(self.data, self.length);
    }
    
    T get(int index) {
        if (index < 0 || index >= self.length) {
            // Return first element as fallback
            return array_get(self.data, 0);
        }
        return array_get(self.data, index);
    }
    
    void* get_ptr(int index) {
        if (index < 0 || index >= self.length) {
            return nullptr;
        }
        int element_size = sizeof(T);
        int offset = index * element_size;
        return self.data + offset;
    }
    
    void* get_data() {
        return self.data;
    }
    
    void set(int index, T value) {
        if (index < 0 || index >= self.length) {
            return;
        }
        array_set(self.data, index, value);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void reserve(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        int element_size = sizeof(T);
        void* new_data = malloc(new_capacity * element_size);
        memcpy(new_data, self.data, self.length * element_size);
        free(self.data);
        
        self.data = new_data;
        self.capacity = new_capacity;
    }
}

// ジェネリックコンストラクタとデストラクタ - すべての型で動作
impl Vector<T> {
    // デフォルトコンストラクタ
    // - 変数宣言時に自動的に呼ばれる
    // - フィールドをnullptrやゼロで安全に初期化
    // - 使用前に必ずinit()を呼ぶ必要がある
    self() {
        self.data = nullptr;
        self.length = 0;
        self.capacity = 0;
    }
    
    // デストラクタ
    // - スコープを抜ける際に自動的に呼ばれる
    // - メモリを自動的に解放（手動でdestroy()を呼ぶ必要なし）
    ~self() {
        if (self.data != nullptr) {
            free(self.data);
        }
    }
}
