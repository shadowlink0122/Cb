// Vector<T> - ジェネリック双方向リンクリスト
// - 任意の型Tに対応（int, double, string, struct, interfaceなど）
// - O(1)でpush_front/push_back/pop_front/pop_back/delete_at(インデックス保持時)
// - 動的なメモリ管理（malloc/free）
// - コンストラクタとデストラクタによる安全なメモリ管理
// - ソート機能（プリミティブ型のデフォルトソート、カスタム比較関数対応）
//
// 計算量:
//   - push_back/push_front: O(1)
//   - pop_back/pop_front: O(1)
//   - delete_at: O(n)
//   - at: O(n)
//   - find: O(n)
//   - sort: O(n log n) - マージソート
//   - get_length/is_empty: O(1)
//   - clear: O(n)
//
// v0.11.0 改善点:
//   - sort()をバブルソート(O(n²))からマージソート(O(n log n))に改善
//
// 使用方法:
//   Vector<int> vec;           // コンストラクタで自動初期化
//   vec.push_back(42);         // 末尾に要素を追加
//   vec.push_front(10);        // 先頭に要素を追加
//   int val = vec.at(0);       // インデックスで要素を取得
//   vec.pop_back();            // 末尾の要素を削除
//   vec.sort();                // 昇順ソート（プリミティブ型）
//   // スコープ終了時、デストラクタが自動的に全メモリを解放

// 双方向リンクリストのノード
// メモリレイアウト: [prev (sizeof(void*))][next (sizeof(void*))][data (sizeof(T))]
// このレイアウトでポインタアクセスが確実になり、32/64ビット両対応

// Vector本体 - 双方向リンクリストとして実装
export struct Vector<T> {
    void* front;      // VectorNode<T>* - 先頭ノード
    void* back;       // VectorNode<T>* - 末尾ノード
    long length;      // 要素数
};

// Vector操作インターフェース
export interface VectorOps<T> {
    // 要素の追加
    void push_back(T value);
    void push_front(T value);
    
    // 要素の削除
    void pop_back();
    void pop_front();
    void delete_at(long index);
    
    // 要素の取得
    T at(long index);
    
    // 要素の検索（線形探索、最大O(length)）
    long find(T value);
    
    // ソート
    void sort();  // O(n log n) マージソート
    void sort_with(void* compare_fn);  // カスタム比較関数でソート
    
    // ユーティリティ
    long get_length();
    bool is_empty();
    void clear();
    
    // Private helpers for merge sort
    void* merge_sort_list(void* head, long length);
    void* merge_two_lists(void* left, void* right);
}

// ===== Vector実装 - 双方向リンクリスト =====
impl VectorOps<T> for Vector<T> {
    // O(1) - 末尾に要素を追加
    void push_back(T value) {
        // ノードのメモリレイアウト: [prev][next][data]
        int ptr_size = sizeof(void*);
        int data_size = sizeof(T);
        int node_size = ptr_size + ptr_size + data_size;  // prev + next + data
        void* new_node = malloc(node_size);
        
        // prevポインタを設定 (offset 0)
        void** prev_ptr = new_node;
        *prev_ptr = self.back;
        
        // nextポインタを設定 (offset ptr_size)
        void** next_ptr = new_node + ptr_size;
        *next_ptr = nullptr;
        
        // データを設定 (offset ptr_size * 2)
        void* data_ptr = new_node + ptr_size + ptr_size;
        array_set(data_ptr, 0, value);
        
        if (self.back != nullptr) {
            // 既存の末尾ノードのnextを更新
            void** old_back_next = self.back + ptr_size;
            *old_back_next = new_node;
        }
        
        self.back = new_node;
        
        if (self.front == nullptr) {
            self.front = new_node;
        }
        
        self.length = self.length + 1;
    }
    
    // O(1) - 先頭に要素を追加
    void push_front(T value) {
        // ノードのメモリレイアウト: [prev][next][data]
        int ptr_size = sizeof(void*);
        int data_size = sizeof(T);
        int node_size = ptr_size + ptr_size + data_size;
        void* new_node = malloc(node_size);
        
        // prevポインタを設定 (offset 0)
        void** prev_ptr = new_node;
        *prev_ptr = nullptr;
        
        // nextポインタを設定 (offset ptr_size)
        void** next_ptr = new_node + ptr_size;
        *next_ptr = self.front;
        
        // データを設定 (offset ptr_size * 2)
        void* data_ptr = new_node + ptr_size + ptr_size;
        array_set(data_ptr, 0, value);
        
        if (self.front != nullptr) {
            // 既存の先頭ノードのprevを更新
            void** old_front_prev = self.front;
            *old_front_prev = new_node;
        }
        
        self.front = new_node;
        
        if (self.back == nullptr) {
            self.back = new_node;
        }
        
        self.length = self.length + 1;
    }
    
    // O(1) - 末尾の要素を削除
    void pop_back() {
        if (self.back == nullptr) {
            return;
        }
        
        int ptr_size = sizeof(void*);
        void* to_delete = self.back;
        void** prev_ptr = self.back;  // offset 0
        void* prev_node = *prev_ptr;
        
        if (prev_node != nullptr) {
            // 一つ前のノードのnextをnullptrに
            void** prev_next = prev_node + ptr_size;
            *prev_next = nullptr;
            self.back = prev_node;
        } else {
            // これが唯一のノードだった
            self.front = nullptr;
            self.back = nullptr;
        }
        
        free(to_delete);
        self.length = self.length - 1;
    }
    
    // O(1) - 先頭の要素を削除
    void pop_front() {
        if (self.front == nullptr) {
            return;
        }
        
        int ptr_size = sizeof(void*);
        void* to_delete = self.front;
        void** next_ptr = self.front + ptr_size;
        void* next_node = *next_ptr;
        
        if (next_node != nullptr) {
            // 次のノードのprevをnullptrに
            void** next_prev = next_node;  // offset 0
            *next_prev = nullptr;
            self.front = next_node;
        } else {
            // これが唯一のノードだった
            self.front = nullptr;
            self.back = nullptr;
        }
        
        free(to_delete);
        self.length = self.length - 1;
    }
    
    // O(n) - インデックス指定で要素を削除
    void delete_at(long index) {
        if (index < 0 || index >= self.length) {
            return;
        }
        
        if (index == 0) {
            self.pop_front();
            return;
        }
        
        if (index == self.length - 1) {
            self.pop_back();
            return;
        }
        
        // インデックスまでノードを辿る
        int ptr_size = sizeof(void*);
        void* current = self.front;
        long i = 0;
        while (i < index) {
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            i = i + 1;
        }
        
        // currentが削除対象ノード
        void** prev_ptr = current;  // offset 0
        void** next_ptr = current + ptr_size;
        void* prev_node = *prev_ptr;
        void* next_node = *next_ptr;
        
        // 前後のノードを繋ぎ直す
        if (prev_node != nullptr) {
            void** prev_next = prev_node + ptr_size;
            *prev_next = next_node;
        }
        
        if (next_node != nullptr) {
            void** next_prev = next_node;  // offset 0
            *next_prev = prev_node;
        }
        
        free(current);
        self.length = self.length - 1;
    }
    
    // O(n) - インデックスで要素を取得
    T at(long index) {
        if (index < 0 || index >= self.length || self.front == nullptr) {
            // フォールバック: ゼロ初期化された値を返す
            T default_value;
            return default_value;
        }
        
        int ptr_size = sizeof(void*);
        void* current = self.front;
        long i = 0;
        while (i < index) {
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            i = i + 1;
        }
        
        // currentノードのデータを取得 (offset ptr_size * 2)
        void* data_ptr = current + ptr_size + ptr_size;
        return array_get(data_ptr, 0);
    }
    
    // O(n) - 線形探索で要素のインデックスを検索
    // 見つからない場合は-1を返す
    long find(T value) {
        void* current = self.front;
        long index = 0;
        
        int ptr_size = sizeof(void*);
        while (current != nullptr) {
            void* data_ptr = current + ptr_size + ptr_size;
            T current_data = array_get(data_ptr, 0);
            
            // プリミティブ型の比較
            // NOTE: 構造体の場合は==演算子が正しく動作するか確認が必要
            if (current_data == value) {
                return index;
            }
            
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            index = index + 1;
        }
        
        return -1;  // 見つからなかった
    }
    
    // Private: 2つのソート済みリストをマージ
    private void* merge_two_lists(void* left, void* right) {
        if (left == nullptr) {
            return right;
        }
        if (right == nullptr) {
            return left;
        }
        
        int ptr_size = sizeof(void*);
        void* left_data_ptr = left + ptr_size + ptr_size;
        void* right_data_ptr = right + ptr_size + ptr_size;
        T left_data = array_get(left_data_ptr, 0);
        T right_data = array_get(right_data_ptr, 0);
        
        void* result = nullptr;
        
        if (left_data <= right_data) {
            result = left;
            void** left_next_ptr = left + ptr_size;
            void* left_next = *left_next_ptr;
            void* merged = self.merge_two_lists(left_next, right);
            *left_next_ptr = merged;
            if (merged != nullptr) {
                void** merged_prev_ptr = merged;
                *merged_prev_ptr = result;
            }
        } else {
            result = right;
            void** right_next_ptr = right + ptr_size;
            void* right_next = *right_next_ptr;
            void* merged = self.merge_two_lists(left, right_next);
            *right_next_ptr = merged;
            if (merged != nullptr) {
                void** merged_prev_ptr = merged;
                *merged_prev_ptr = result;
            }
        }
        
        return result;
    }
    
    // Private: マージソート（リンクリスト版）
    private void* merge_sort_list(void* head, long length) {
        if (length <= 1 || head == nullptr) {
            return head;
        }
        
        // リストを2つに分割
        long mid = length / 2;
        int ptr_size = sizeof(void*);
        void* current = head;
        long i = 0;
        
        // mid-1番目のノードまで進む
        while (i < mid - 1) {
            void** next_ptr = current + ptr_size;
            current = *next_ptr;
            i = i + 1;
        }
        
        // currentの次が右半分の開始
        void** current_next_ptr = current + ptr_size;
        void* right_head = *current_next_ptr;
        
        // 左半分と右半分を切り離す
        *current_next_ptr = nullptr;
        if (right_head != nullptr) {
            void** right_prev_ptr = right_head;
            *right_prev_ptr = nullptr;
        }
        
        // 再帰的にソート
        void* left = self.merge_sort_list(head, mid);
        void* right = self.merge_sort_list(right_head, length - mid);
        
        // マージ
        return self.merge_two_lists(left, right);
    }
    
    // O(n log n) - マージソート（プリミティブ型のデフォルト昇順）
    void sort() {
        if (self.length <= 1) {
            return;
        }
        
        // マージソート実行
        self.front = self.merge_sort_list(self.front, self.length);
        
        // backポインタを更新
        int ptr_size = sizeof(void*);
        void* current = self.front;
        while (current != nullptr) {
            void** next_ptr = current + ptr_size;
            void* next_node = *next_ptr;
            if (next_node == nullptr) {
                self.back = current;
                break;
            }
            current = next_node;
        }
    }
    
    // O(n log n) - カスタム比較関数を使用したソート
    // compare_fn: int (*)(T a, T b) - a < b なら負、a == b なら0、a > b なら正
    // NOTE: 現在は関数ポインタ呼び出しが未実装のため、デフォルト比較を使用
    void sort_with(void* compare_fn) {
        if (self.length <= 1) {
            return;
        }
        
        // 現時点では、プリミティブ型のデフォルト比較を使用
        // 将来的に関数ポインタ呼び出しが実装されたら、
        // merge_two_listsとmerge_sort_listに比較関数を渡すように変更する
        self.sort();
    }
    
    // O(1) - 要素数を取得
    long get_length() {
        return self.length;
    }
    
    // O(1) - 空かどうかを確認
    bool is_empty() {
        return self.length == 0;
    }
    
    // O(n) - 全要素を削除
    void clear() {
        while (self.front != nullptr) {
            self.pop_front();
        }
    }
}

// コンストラクタとデストラクタ
impl Vector<T> {
    // コンストラクタ - 空のVectorを初期化
    self() {
        self.front = nullptr;
        self.back = nullptr;
        self.length = 0;
    }
    
    // デストラクタ - 全ノードのメモリを解放
    ~self() {
        int ptr_size = sizeof(void*);
        void* current = self.front;
        while (current != nullptr) {
            void** next_ptr = current + ptr_size;
            void* next_node = *next_ptr;
            free(current);
            current = next_node;
        }
    }
}
