// Vector<T> - 真のジェネリック動的配列
// 汎用array_get/array_set関数を使用した統一実装

export struct Vector<T> {
    void* data;
    int length;
    int capacity;
}

export interface VectorOps<T> {
    void init(int initial_capacity);
    void push(T value);
    T pop();
    T get(int index);
    void set(int index, T value);
    int get_length();
    int get_capacity();
    void clear();
    bool is_empty();
    void reserve(int new_capacity);
}

// ===== Vector<int> の実装 =====
impl VectorOps<int> for Vector<int> {
    void init(int initial_capacity) {
        int element_size = sizeof(int);
        self.data = malloc(initial_capacity * element_size);
        self.length = 0;
        self.capacity = initial_capacity;
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            self.reserve(self.capacity * 2);
        }
        array_set(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector<int>] Error: Empty vector");
            return 0;
        }
        self.length = self.length - 1;
        return array_get(self.data, self.length);
    }
    
    int get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<int>] Error: Index out of bounds");
            return 0;
        }
        return array_get(self.data, index);
    }
    
    void set(int index, int value) {
        if (index < 0 || index >= self.length) {
            println("[Vector<int>] Error: Index out of bounds");
            return;
        }
        array_set(self.data, index, value);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    void clear() {
        self.length = 0;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void reserve(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        int element_size = sizeof(int);
        void* new_data = malloc(new_capacity * element_size);
        memcpy(new_data, self.data, self.length * element_size);
        free(self.data);
        
        self.data = new_data;
        self.capacity = new_capacity;
    }
}

impl Vector<int> {
    ~self() {
        free(self.data);
    }
}

// ===== Vector<double> の実装 =====
impl VectorOps<double> for Vector<double> {
    void init(int initial_capacity) {
        int element_size = sizeof(double);
        self.data = malloc(initial_capacity * element_size);
        self.length = 0;
        self.capacity = initial_capacity;
    }
    
    void push(double value) {
        if (self.length >= self.capacity) {
            self.reserve(self.capacity * 2);
        }
        array_set(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    double pop() {
        if (self.length <= 0) {
            println("[Vector<double>] Error: Empty vector");
            return 0.0;
        }
        self.length = self.length - 1;
        return array_get(self.data, self.length);
    }
    
    double get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<double>] Error: Index out of bounds");
            return 0.0;
        }
        return array_get(self.data, index);
    }
    
    void set(int index, double value) {
        if (index < 0 || index >= self.length) {
            println("[Vector<double>] Error: Index out of bounds");
            return;
        }
        array_set(self.data, index, value);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    void clear() {
        self.length = 0;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void reserve(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        int element_size = sizeof(double);
        void* new_data = malloc(new_capacity * element_size);
        memcpy(new_data, self.data, self.length * element_size);
        free(self.data);
        
        self.data = new_data;
        self.capacity = new_capacity;
    }
}

impl Vector<double> {
    ~self() {
        free(self.data);
    }
}

// ===== Vector<string> の実装 =====
impl VectorOps<string> for Vector<string> {
    void init(int initial_capacity) {
        int element_size = sizeof(string);
        self.data = malloc(initial_capacity * element_size);
        self.length = 0;
        self.capacity = initial_capacity;
    }
    
    void push(string value) {
        if (self.length >= self.capacity) {
            self.reserve(self.capacity * 2);
        }
        array_set(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    string pop() {
        if (self.length <= 0) {
            println("[Vector<string>] Error: Empty vector");
            return "";
        }
        self.length = self.length - 1;
        return array_get(self.data, self.length);
    }
    
    string get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<string>] Error: Index out of bounds");
            return "";
        }
        return array_get(self.data, index);
    }
    
    void set(int index, string value) {
        if (index < 0 || index >= self.length) {
            println("[Vector<string>] Error: Index out of bounds");
            return;
        }
        array_set(self.data, index, value);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    void clear() {
        self.length = 0;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void reserve(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        int element_size = sizeof(string);
        void* new_data = malloc(new_capacity * element_size);
        memcpy(new_data, self.data, self.length * element_size);
        free(self.data);
        
        self.data = new_data;
        self.capacity = new_capacity;
    }
}

impl Vector<string> {
    ~self() {
        free(self.data);
    }
}
