// Map<K, V> - シンプルな連想配列実装（線形探索）
// AVL木での問題を回避するため、単純な配列ベースの実装を使用

export struct MapEntry<K, V> {
    K key;
    V value;
    bool occupied;
};

export struct Map<K, V> {
    void* entries;  // MapEntry<K, V>の配列
    int capacity;
    int count;
};

// マップの初期化
export void map_init<K, V>(Map<K, V>& m) {
    m.capacity = 16;
    m.count = 0;
    // MapEntry<K, V> = K + V + bool
    // boolは4バイトとして扱われることが多い
    long entry_size = sizeof(K) + sizeof(V) + 4;
    m.entries = malloc(entry_size * m.capacity);
    
    // すべてのエントリをoccupied=falseで初期化
    int i = 0;
    while (i < m.capacity) {
        void* entry_ptr = m.entries + (i * entry_size);
        // occupiedフィールドはKとVの後にあるので、そのオフセットを計算
        long occupied_offset = sizeof(K) + sizeof(V);
        void* occupied_ptr = entry_ptr + occupied_offset;
        array_set_int(occupied_ptr, 0, 0);  // false
        i = i + 1;
    }
}

// マップのクリーンアップ
export void map_cleanup<K, V>(Map<K, V>& m) {
    if (m.entries != nullptr) {
        free(m.entries);
        m.entries = nullptr;
    }
    m.count = 0;
    m.capacity = 0;
}

// キーの検索（インデックスを返す、見つからない場合は-1）
export int map_find_index<K, V>(Map<K, V>& m, K key) {
    long entry_size = sizeof(K) + sizeof(V) + 4;
    
    int i = 0;
    while (i < m.capacity) {
        void* entry_ptr = m.entries + (i * entry_size);
        long occupied_offset = sizeof(K) + sizeof(V);
        void* occupied_ptr = entry_ptr + occupied_offset;
        int occupied = array_get_int(occupied_ptr, 0);
        
        if (occupied != 0) {
            // キーを取得して比較
            K entry_key = array_get(entry_ptr, 0);
            if (entry_key == key) {
                return i;
            }
        }
        i = i + 1;
    }
    
    return -1;
}

// 空のスロットを見つける
export int map_find_empty_slot<K, V>(Map<K, V>& m) {
    long entry_size = sizeof(K) + sizeof(V) + 4;
    
    int i = 0;
    while (i < m.capacity) {
        void* entry_ptr = m.entries + (i * entry_size);
        long occupied_offset = sizeof(K) + sizeof(V);
        void* occupied_ptr = entry_ptr + occupied_offset;
        int occupied = array_get_int(occupied_ptr, 0);
        
        if (occupied == 0) {
            return i;
        }
        i = i + 1;
    }
    
    return -1;
}

// 挿入または更新
export void map_insert<K, V>(Map<K, V>& m, K key, V value) {
    long entry_size = sizeof(K) + sizeof(V) + 4;
    
    // 既存のキーを探す
    int existing_idx = map_find_index<K, V>(m, key);
    
    if (existing_idx >= 0) {
        // 更新
        void* entry_ptr = m.entries + (existing_idx * entry_size);
        void* value_ptr = entry_ptr + sizeof(K);
        array_set(value_ptr, 0, value);
    } else {
        // 新規挿入
        int empty_idx = map_find_empty_slot<K, V>(m);
        
        if (empty_idx < 0) {
            // 容量不足 - エラー処理（今回は簡略化のため無視）
            return;
        }
        
        void* entry_ptr = m.entries + (empty_idx * entry_size);
        
        // キーを設定
        array_set(entry_ptr, 0, key);
        
        // 値を設定
        void* value_ptr = entry_ptr + sizeof(K);
        array_set(value_ptr, 0, value);
        
        // occupiedを設定
        long occupied_offset = sizeof(K) + sizeof(V);
        void* occupied_ptr = entry_ptr + occupied_offset;
        array_set_int(occupied_ptr, 0, 1);  // true
        
        m.count = m.count + 1;
    }
}

// 取得
export V map_get<K, V>(Map<K, V>& m, K key) {
    long entry_size = sizeof(K) + sizeof(V) + 4;
    int idx = map_find_index<K, V>(m, key);
    
    if (idx >= 0) {
        void* entry_ptr = m.entries + (idx * entry_size);
        void* value_ptr = entry_ptr + sizeof(K);
        return array_get(value_ptr, 0);
    }
    
    // 見つからない場合はデフォルト値を返す
    V dummy;
    return dummy;
}

// 存在チェック
export bool map_contains<K, V>(Map<K, V>& m, K key) {
    return map_find_index<K, V>(m, key) >= 0;
}

// サイズ
export int map_size<K, V>(Map<K, V>& m) {
    return m.count;
}

// 空かどうか
export bool map_is_empty<K, V>(Map<K, V>& m) {
    return m.count == 0;
}

// クリア
export void map_clear<K, V>(Map<K, V>& m) {
    long entry_size = sizeof(K) + sizeof(V) + 4;
    
    // すべてのエントリをoccupied=falseで初期化
    int i = 0;
    while (i < m.capacity) {
        void* entry_ptr = m.entries + (i * entry_size);
        long occupied_offset = sizeof(K) + sizeof(V);
        void* occupied_ptr = entry_ptr + occupied_offset;
        array_set_int(occupied_ptr, 0, 0);  // false
        i = i + 1;
    }
    
    m.count = 0;
}

// デフォルトコンストラクタ
impl Map<K, V> {
    self() {
        self.entries = nullptr;
        self.capacity = 0;
        self.count = 0;
        map_init<K, V>(self);
    }
    
    ~self() {
        map_cleanup<K, V>(self);
    }
}
