// Vector<T> - Type-safe dynamic array (Simplified Generic Version)
// v0.11.0: ジェネリック対応版
//
// 設計方針：
// - 完全なジェネリック実装は現在のインタプリタの制約により困難
// - 型ごとに特殊化された実装を提供（int, double, string）
// - アロケータパラメータは将来の拡張のため保留
// - 実用性重視の設計

// VectorOps<T> - Vector操作のインターフェース
export interface VectorOps<T> {
    void init(int initial_capacity);
    void push(T value);
    T pop();
    T get(int index);
    void set(int index, T value);
    void resize(int new_capacity);
    void clear();
    int length();
    int capacity();
    bool is_empty();
    void destroy();
}

// Vector<T> - 動的配列構造体
export struct Vector<T> {
    int capacity;
    int length;
    void* data;
};

// ============================================================================
// Vector<int> Implementation
// ============================================================================

impl VectorOps<int> for Vector<int> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        self.data = new int[initial_capacity];
        
        println("[Vector<int>] init: capacity={initial_capacity}, memory={hex(self.data)}");
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            println("[Vector<int>] Error: Capacity full! Call resize() first");
            return;
        }
        
        array_set_int(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector<int>] Error: Empty vector");
            return 0;
        }
        
        self.length = self.length - 1;
        return array_get_int(self.data, self.length);
    }
    
    int get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<int>] Error: Index {index} out of bounds (length={self.length})");
            return 0;
        }
        
        return array_get_int(self.data, index);
    }
    
    void set(int index, int value) {
        if (index < 0 || index >= self.length) {
            println("[Vector<int>] Error: Index {index} out of bounds (length={self.length})");
            return;
        }
        
        array_set_int(self.data, index, value);
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        void* new_data = new int[new_capacity];
        
        // データをコピー
        int copy_size = self.length * sizeof(int);
        memcpy(new_data, self.data, copy_size);
        
        // 古いメモリを解放
        delete self.data;
        
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector<int>] resized: capacity={new_capacity}");
    }
    
    void clear() {
        self.length = 0;
    }
    
    int length() {
        return self.length;
    }
    
    int capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void destroy() {
        if (self.data != nullptr) {
            delete self.data;
            self.data = nullptr;
            self.length = 0;
            self.capacity = 0;
        }
    }
}

// Destructor for Vector<int>
impl Vector<int> {
    ~self() {
        if (self.data != nullptr) {
            println("[Vector<int>] Destructor: freeing memory");
            delete self.data;
        }
    }
}

// ============================================================================
// Vector<double> Implementation
// ============================================================================

impl VectorOps<double> for Vector<double> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        self.data = new double[initial_capacity];
        
        println("[Vector<double>] init: capacity={initial_capacity}");
    }
    
    void push(double value) {
        if (self.length >= self.capacity) {
            println("[Vector<double>] Error: Capacity full! Call resize() first");
            return;
        }
        
        array_set_double(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    double pop() {
        if (self.length <= 0) {
            println("[Vector<double>] Error: Empty vector");
            return 0.0;
        }
        
        self.length = self.length - 1;
        return array_get_double(self.data, self.length);
    }
    
    double get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<double>] Error: Index out of bounds");
            return 0.0;
        }
        
        return array_get_double(self.data, index);
    }
    
    void set(int index, double value) {
        if (index < 0 || index >= self.length) {
            println("[Vector<double>] Error: Index out of bounds");
            return;
        }
        
        array_set_double(self.data, index, value);
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        void* new_data = new double[new_capacity];
        
        int copy_size = self.length * sizeof(double);
        memcpy(new_data, self.data, copy_size);
        
        delete self.data;
        
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector<double>] resized: capacity={new_capacity}");
    }
    
    void clear() {
        self.length = 0;
    }
    
    int length() {
        return self.length;
    }
    
    int capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void destroy() {
        if (self.data != nullptr) {
            delete self.data;
            self.data = nullptr;
            self.length = 0;
            self.capacity = 0;
        }
    }
}

// Destructor for Vector<double>
impl Vector<double> {
    ~self() {
        if (self.data != nullptr) {
            println("[Vector<double>] Destructor: freeing memory");
            delete self.data;
        }
    }
}

// ============================================================================
// Vector<string> Implementation
// ============================================================================

impl VectorOps<string> for Vector<string> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        
        int string_size = 8;  // ポインタサイズ
        self.data = malloc(initial_capacity * string_size);
        
        println("[Vector<string>] init: capacity={initial_capacity}");
    }
    
    void push(string value) {
        if (self.length >= self.capacity) {
            println("[Vector<string>] Error: Capacity full! Call resize() first");
            return;
        }
        
        array_set_string(self.data, self.length, value);
        self.length = self.length + 1;
    }
    
    string pop() {
        if (self.length <= 0) {
            println("[Vector<string>] Error: Empty vector");
            return "";
        }
        
        self.length = self.length - 1;
        return array_get_string(self.data, self.length);
    }
    
    string get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<string>] Error: Index out of bounds");
            return "";
        }
        
        return array_get_string(self.data, index);
    }
    
    void set(int index, string value) {
        if (index < 0 || index >= self.length) {
            println("[Vector<string>] Error: Index out of bounds");
            return;
        }
        
        array_set_string(self.data, index, value);
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            return;
        }
        
        int string_size = 8;
        void* new_data = malloc(new_capacity * string_size);
        
        // 文字列をコピー
        int i = 0;
        while (i < self.length) {
            string value = array_get_string(self.data, i);
            array_set_string(new_data, i, value);
            i = i + 1;
        }
        
        free(self.data);
        
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector<string>] resized: capacity={new_capacity}");
    }
    
    void clear() {
        self.length = 0;
    }
    
    int length() {
        return self.length;
    }
    
    int capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void destroy() {
        if (self.data != nullptr) {
            free(self.data);
            self.data = nullptr;
            self.length = 0;
            self.capacity = 0;
        }
    }
}

// Destructor for Vector<string>
impl Vector<string> {
    ~self() {
        if (self.data != nullptr) {
            println("[Vector<string>] Destructor: freeing memory");
            free(self.data);
        }
    }
}
