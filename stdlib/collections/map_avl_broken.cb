// stdlib/collections/map.cb
// Map<K, V> - 平衡二分木（AVL木）による連想配列
// O(log n) の検索・挿入・削除を実現
//
// 使用方法:
//   Map<int, string> map;
//   map_insert<int, string>(map, 1, "one");
//   string val = map_get<int, string>(map, 1);
//   map_remove<int, string>(map, 1);

// Map本体
export struct Map<K, V> {
    void* root;      // AVL木のルートノード
    long count;      // 要素数
};

impl Map<K, V> {
    self() {
        self.root = nullptr;
        self.count = 0;
    }
    
    ~self() {
        // メモリリークを防ぐため、ノードを再帰的に解放
        // （map_clearは呼び出せないため、直接実装）
        if (self.root != nullptr) {
            map_clear_recursive<K, V>(self.root);
        }
    }
}

// ========================================
// AVL木ノード構造
// メモリレイアウト: [key (sizeof(K))][value (sizeof(V))][left* (void*)][right* (void*)][height (int)]
// ========================================

// ノードを作成
export void* map_create_node<K, V>(K key, V value) {
    int key_size = sizeof(K);
    int value_size = sizeof(V);
    int ptr_size = sizeof(void*);
    int node_size = key_size + value_size + ptr_size + ptr_size + sizeof(int);
    
    void* node = malloc(node_size);
    
    // キーを設定
    array_set(node, 0, key);
    
    // 値を設定
    void* value_ptr = node + key_size;
    array_set(value_ptr, 0, value);
    
    // 左ポインタを nullptr に設定
    void* left_ptr = node + key_size + value_size;
    array_set(left_ptr, 0, nullptr);
    
    // 右ポインタを nullptr に設定
    void* right_ptr = node + key_size + value_size + ptr_size;
    array_set(right_ptr, 0, nullptr);
    
    // 高さを 1 に設定
    void* height_ptr = node + key_size + value_size + ptr_size + ptr_size;
    array_set_int(height_ptr, 0, 1);
    
    return node;
}

// キーを取得
export K map_node_get_key<K, V>(void* node) {
    return array_get(node, 0);
}

// 値を取得
export V map_node_get_value<K, V>(void* node) {
    int key_size = sizeof(K);
    void* value_ptr = node + key_size;
    return array_get(value_ptr, 0);
}

// 値を設定
export void map_node_set_value<K, V>(void* node, V value) {
    int key_size = sizeof(K);
    void* value_ptr = node + key_size;
    array_set(value_ptr, 0, value);
}

// 左の子ノードを取得
export void* map_node_get_left<K, V>(void* node) {
    long key_size = sizeof(K);
    long value_size = sizeof(V);
    
    void* left_ptr = node + key_size + value_size;
    return array_get(left_ptr, 0);
}

// 左子ノードを設定
// 左の子ノードを設定
export void map_node_set_left<K, V>(void* node, void* left) {
    long key_size = sizeof(K);
    long value_size = sizeof(V);
    
    void* left_ptr = node + key_size + value_size;
    array_set(left_ptr, 0, left);
}

// 右子ノードを取得
export void* map_node_get_right<K, V>(void* node) {
    long key_size = sizeof(K);
    long value_size = sizeof(V);
    long ptr_size = sizeof(void*);
    
    void* right_ptr = node + key_size + value_size + ptr_size;
    return array_get(right_ptr, 0);
}

// 右子ノードを設定
export void map_node_set_right<K, V>(void* node, void* right) {
    long key_size = sizeof(K);
    long value_size = sizeof(V);
    long ptr_size = sizeof(void*);
    
    void* right_ptr = node + key_size + value_size + ptr_size;
    array_set(right_ptr, 0, right);
}

// 高さを取得
export int map_node_get_height<K, V>(void* node) {
    if (node == nullptr) {
        return 0;
    }
    int key_size = sizeof(K);
    int value_size = sizeof(V);
    int ptr_size = sizeof(void*);
    void* height_ptr = node + key_size + value_size + ptr_size + ptr_size;
    return array_get_int(height_ptr, 0);
}

// 高さを設定
export void map_node_set_height<K, V>(void* node, int height) {
    int key_size = sizeof(K);
    int value_size = sizeof(V);
    int ptr_size = sizeof(void*);
    void* height_ptr = node + key_size + value_size + ptr_size + ptr_size;
    array_set_int(height_ptr, 0, height);
}

// 高さを更新
export void map_node_update_height<K, V>(void* node) {
    if (node == nullptr) {
        return;
    }
    void* left = map_node_get_left<K, V>(node);
    void* right = map_node_get_right<K, V>(node);
    int left_height = map_node_get_height<K, V>(left);
    int right_height = map_node_get_height<K, V>(right);
    int new_height = (left_height > right_height ? left_height : right_height) + 1;
    map_node_set_height<K, V>(node, new_height);
}

// バランスファクターを取得
export int map_node_get_balance<K, V>(void* node) {
    if (node == nullptr) {
        return 0;
    }
    void* left = map_node_get_left<K, V>(node);
    void* right = map_node_get_right<K, V>(node);
    return map_node_get_height<K, V>(left) - map_node_get_height<K, V>(right);
}

// ========================================
// AVL木の回転操作
// ========================================

// 右回転
export void* map_rotate_right<K, V>(void* y) {
    void* x = map_node_get_left<K, V>(y);
    void* T2 = map_node_get_right<K, V>(x);
    
    // 回転実行
    map_node_set_right<K, V>(x, y);
    map_node_set_left<K, V>(y, T2);
    
    // 高さ更新
    map_node_update_height<K, V>(y);
    map_node_update_height<K, V>(x);
    
    return x;
}

// 左回転
export void* map_rotate_left<K, V>(void* x) {
    void* y = map_node_get_right<K, V>(x);
    void* T2 = map_node_get_left<K, V>(y);
    
    // 回転実行
    map_node_set_left<K, V>(y, x);
    map_node_set_right<K, V>(x, T2);
    
    // 高さ更新
    map_node_update_height<K, V>(x);
    map_node_update_height<K, V>(y);
    
    return y;
}

// ========================================
// 挿入（再帰）
// ========================================

export void* map_insert_recursive<K, V>(void* node, K key, V value, bool& inserted) {
    // ベースケース: 新しいノードを作成
    if (node == nullptr) {
        inserted = true;
        return map_create_node<K, V>(key, value);
    }
    
    K node_key = map_node_get_key<K, V>(node);
    
    // 再帰的に挿入
    if (key < node_key) {
        void* left = map_node_get_left<K, V>(node);
        void* new_left = map_insert_recursive<K, V>(left, key, value, inserted);
        map_node_set_left<K, V>(node, new_left);
    } else if (key > node_key) {
        void* right = map_node_get_right<K, V>(node);
        void* new_right = map_insert_recursive<K, V>(right, key, value, inserted);
        map_node_set_right<K, V>(node, new_right);
    } else {
        // 既存のキー: 値を更新
        map_node_set_value<K, V>(node, value);
        inserted = false;
        return node;
    }
    
    // 高さを更新
    map_node_update_height<K, V>(node);
    
    // バランスファクターを取得
    int balance = map_node_get_balance<K, V>(node);
    
    void* left = map_node_get_left<K, V>(node);
    void* right = map_node_get_right<K, V>(node);
    
    // Left Left Case
    if (balance > 1 && left != nullptr && key < map_node_get_key<K, V>(left)) {
        return map_rotate_right<K, V>(node);
    }
    
    // Right Right Case
    if (balance < -1 && right != nullptr && key > map_node_get_key<K, V>(right)) {
        return map_rotate_left<K, V>(node);
    }
    
    // Left Right Case
    if (balance > 1 && left != nullptr && key > map_node_get_key<K, V>(left)) {
        void* new_left = map_rotate_left<K, V>(left);
        map_node_set_left<K, V>(node, new_left);
        return map_rotate_right<K, V>(node);
    }
    
    // Right Left Case
    if (balance < -1 && right != nullptr && key < map_node_get_key<K, V>(right)) {
        void* new_right = map_rotate_right<K, V>(right);
        map_node_set_right<K, V>(node, new_right);
        return map_rotate_left<K, V>(node);
    }
    
    return node;
}

// ========================================
// 検索
// ========================================

export V map_get_recursive<K, V>(void* node, K key) {
    if (node == nullptr) {
        V default_val;
        return default_val;
    }
    
    K node_key = map_node_get_key<K, V>(node);
    
    if (key == node_key) {
        return map_node_get_value<K, V>(node);
    } else if (key < node_key) {
        void* left = map_node_get_left<K, V>(node);
        return map_get_recursive<K, V>(left, key);
    } else {
        void* right = map_node_get_right<K, V>(node);
        return map_get_recursive<K, V>(right, key);
    }
}

export bool map_contains_recursive<K, V>(void* node, K key) {
    if (node == nullptr) {
        return false;
    }
    
    K node_key = map_node_get_key<K, V>(node);
    
    if (key == node_key) {
        return true;
    } else if (key < node_key) {
        void* left = map_node_get_left<K, V>(node);
        return map_contains_recursive<K, V>(left, key);
    } else {
        void* right = map_node_get_right<K, V>(node);
        return map_contains_recursive<K, V>(right, key);
    }
}

// ========================================
// 削除
// ========================================

// 最小ノードを取得
export void* map_get_min_node<K, V>(void* node) {
    void* current = node;
    void* left = map_node_get_left<K, V>(current);
    while (left != nullptr) {
        current = left;
        left = map_node_get_left<K, V>(current);
    }
    return current;
}

export void* map_remove_recursive<K, V>(void* node, K key, bool& removed) {
    if (node == nullptr) {
        removed = false;
        return nullptr;
    }
    
    K node_key = map_node_get_key<K, V>(node);
    
    // 再帰的に削除
    if (key < node_key) {
        void* left = map_node_get_left<K, V>(node);
        void* new_left = map_remove_recursive<K, V>(left, key, removed);
        map_node_set_left<K, V>(node, new_left);
    } else if (key > node_key) {
        void* right = map_node_get_right<K, V>(node);
        void* new_right = map_remove_recursive<K, V>(right, key, removed);
        map_node_set_right<K, V>(node, new_right);
    } else {
        // ノードが見つかった
        removed = true;
        
        void* left = map_node_get_left<K, V>(node);
        void* right = map_node_get_right<K, V>(node);
        
        // 子が1つ以下の場合
        if (left == nullptr || right == nullptr) {
            void* temp = left;
            if (temp == nullptr) {
                temp = right;
            }
            
            if (temp == nullptr) {
                // 子がない場合
                free(node);
                return nullptr;
            } else {
                // 子が1つの場合
                free(node);
                return temp;
            }
        } else {
            // 子が2つの場合: 右部分木の最小ノードで置き換え
            void* temp = map_get_min_node<K, V>(right);
            K temp_key = map_node_get_key<K, V>(temp);
            V temp_value = map_node_get_value<K, V>(temp);
            
            array_set(node, 0, temp_key);
            map_node_set_value<K, V>(node, temp_value);
            
            bool dummy = false;
            void* new_right = map_remove_recursive<K, V>(right, temp_key, dummy);
            map_node_set_right<K, V>(node, new_right);
        }
    }
    
    if (node == nullptr) {
        return nullptr;
    }
    
    // 高さを更新
    map_node_update_height<K, V>(node);
    
    // バランスファクターを取得
    int balance = map_node_get_balance<K, V>(node);
    
    void* left = map_node_get_left<K, V>(node);
    void* right = map_node_get_right<K, V>(node);
    
    // Left Left Case
    if (balance > 1 && left != nullptr && map_node_get_balance<K, V>(left) >= 0) {
        return map_rotate_right<K, V>(node);
    }
    
    // Left Right Case
    if (balance > 1 && left != nullptr && map_node_get_balance<K, V>(left) < 0) {
        void* new_left = map_rotate_left<K, V>(left);
        map_node_set_left<K, V>(node, new_left);
        return map_rotate_right<K, V>(node);
    }
    
    // Right Right Case
    if (balance < -1 && right != nullptr && map_node_get_balance<K, V>(right) <= 0) {
        return map_rotate_left<K, V>(node);
    }
    
    // Right Left Case
    if (balance < -1 && right != nullptr && map_node_get_balance<K, V>(right) > 0) {
        void* new_right = map_rotate_right<K, V>(right);
        map_node_set_right<K, V>(node, new_right);
        return map_rotate_left<K, V>(node);
    }
    
    return node;
}

// ========================================
// クリア
// ========================================

export void map_clear_recursive<K, V>(void* node) {
    if (node == nullptr) {
        return;
    }
    
    void* left = map_node_get_left<K, V>(node);
    void* right = map_node_get_right<K, V>(node);
    
    map_clear_recursive<K, V>(left);
    map_clear_recursive<K, V>(right);
    
    free(node);
}

// ========================================
// パブリックAPI
// ========================================

export void map_insert<K, V>(Map<K, V>& m, K key, V value) {
    bool inserted = false;
    m.root = map_insert_recursive<K, V>(m.root, key, value, inserted);
    if (inserted) {
        m.count = m.count + 1;
    }
}

export V map_get<K, V>(Map<K, V>& m, K key) {
    return map_get_recursive<K, V>(m.root, key);
}

export bool map_contains<K, V>(Map<K, V>& m, K key) {
    return map_contains_recursive<K, V>(m.root, key);
}

export void map_remove<K, V>(Map<K, V>& m, K key) {
    bool removed = false;
    m.root = map_remove_recursive<K, V>(m.root, key, removed);
    if (removed) {
        m.count = m.count - 1;
    }
}

export long map_size<K, V>(Map<K, V>& m) {
    return m.count;
}

export bool map_is_empty<K, V>(Map<K, V>& m) {
    return m.count == 0;
}

export void map_clear<K, V>(Map<K, V>& m) {
    map_clear_recursive<K, V>(m.root);
    m.root = nullptr;
    m.count = 0;
}
