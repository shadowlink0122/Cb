// Vector<T, A: Allocator> - Dynamic array with custom allocator
// Part of Week 2: Vector Implementation
//
// A generic dynamic array that uses a custom allocator for memory management
// This enables:
// - OS environments: Use SystemAllocator (malloc/free)
// - Bare-metal: Use BumpAllocator or custom allocators
// - Zero-cost abstraction: Compile-time dispatch

export interface Allocator {
    void* allocate(int size);
    void deallocate(void* ptr);
}

export struct SystemAllocator {
    int allocation_count;
};

impl Allocator for SystemAllocator {
    void* allocate(int size) {
        println("[SystemAllocator] Allocate %d bytes", size);
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        println("[SystemAllocator] Deallocate");
    }
}

export struct BumpAllocator {
    int buffer_size;
    int current_offset;
};

impl Allocator for BumpAllocator {
    void* allocate(int size) {
        println("[BumpAllocator] Allocate %d bytes (offset=%d)", size, 0);
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        println("[BumpAllocator] Deallocate ignored");
    }
}

// Vector structure with allocator type parameter
export struct Vector<T, A: Allocator> {
    int capacity;
    int length;
    void* data;        // データ領域（将来的に実際のメモリを指す）
};

// VectorOps interface - defines operations for Vector
// v0.11.0+: ジェネリックinterfaceに対応
export interface VectorOps<T> {
    void init(int initial_capacity);
    void push(T value);
    T pop();
    T get(int index);
    void resize(int new_capacity);
    void info();
    int get_length();
    int get_capacity();
    bool is_empty();
    void destroy();  // 明示的なメモリ解放メソッド（後方互換性のため残存、~self()が自動的に呼ばれる）
}

// ============================================================================
// Generic Implementation for Vector<T, SystemAllocator>
// ============================================================================
// NOTE: 真のジェネリック実装は現在のインタプリタでは完全にサポートされていないため、
// 型ごとの実装が必要です。将来的にはコード生成による統一実装を目指します。

// Implementation of VectorOps<int> for Vector<int, SystemAllocator>
impl VectorOps<int> for Vector<int, SystemAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        
        // 実メモリを確保
        self.data = new int[initial_capacity];
        
        println("[Vector<int, SystemAllocator>] Initialized with capacity={initial_capacity}");
        println("[Vector] Allocated memory at {hex(self.data)}");
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            // 容量が足りない場合はエラー（呼び出し側でリサイズ管理）
            println("[Vector] Error: Capacity full! (size={self.length}, capacity={self.capacity})");
            println("[Vector] Please call resize() before push");
            return;
        }
        
        // 配列に値を書き込み
        array_set_int(self.data, self.length, value);
        self.length = self.length + 1;
        
        println("[Vector] Pushed value={value} at index={self.length - 1}");
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector] Empty! Cannot pop");
            return 0;
        }
        
        self.length = self.length - 1;
        int value = array_get_int(self.data, self.length);
        
        println("[Vector] Popped value={value} from index={self.length}");
        return value;
    }
    
    int get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector] Error: Index out of bounds (index={index}, length={self.length})");
            return 0;
        }
        
        int value = array_get_int(self.data, index);
        return value;
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector] New capacity {new_capacity} <= current {self.capacity}, no resize needed");
            return;
        }
        
        println("[Vector] Resizing from capacity={self.capacity} to {new_capacity}");
        
        // 新しい配列を確保
        void* new_data = new int[new_capacity];
        
        // 既存データをコピー (memcpyを使用)
        int copy_size = self.length * sizeof(int);
        memcpy(new_data, self.data, copy_size);
        
        println("[Vector] Copied {self.length} elements ({copy_size} bytes)");
        
        // 古い配列を解放
        delete self.data;
        
        // 新しい配列に切り替え
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector] Resize complete (new capacity={new_capacity}, memory at {hex(self.data)})");
    }
    
    void info() {
        println("[Vector] length={self.length}, capacity={self.capacity}, data={hex(self.data)}");
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    // 明示的なメモリ解放メソッド（デストラクタの代わり）
    // Note: ジェネリクス構造体は~self()デストラクタをサポートしていないため
    void destroy() {
        if (self.data != nullptr) {
            println("[Vector] destroy(): Freeing memory at {hex(self.data)}");
            delete self.data;
            self.data = nullptr;
            self.length = 0;
            self.capacity = 0;
        }
    }
}

// Destructor for Vector<int, SystemAllocator>
// 自動メモリ管理：スコープを抜ける時に自動的にメモリを解放
impl Vector<int, SystemAllocator> {
    ~self() {
        if (self.data != nullptr) {
            println("[Vector<int, SystemAllocator>] Destructor: Freeing memory at {hex(self.data)}");
            delete self.data;
        }
    }
}

// Implementation of VectorOps for Vector<int, BumpAllocator>
impl VectorOps<int> for Vector<int, BumpAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        self.data = nullptr;
        println("[Vector<int, BumpAllocator>] Initialized with capacity=%d", initial_capacity);
    }
    
    void push(int value) {
        if (self.length >= self.capacity) {
            println("[Vector] Capacity full! Need resize (current=%d)", self.capacity);
            return;
        }
        
        println("[Vector] Push value=%d at index=%d", value, self.length);
        self.length = self.length + 1;
    }
    
    int pop() {
        if (self.length <= 0) {
            println("[Vector] Empty! Cannot pop");
            return 0;
        }
        
        self.length = self.length - 1;
        println("[Vector] Pop from index=%d", self.length);
        return 0;  // プレースホルダー
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector] New capacity %d <= current %d, no resize needed", 
                    new_capacity, self.capacity);
            return;
        }
        
        println("[Vector] Resizing from capacity=%d to %d", self.capacity, new_capacity);
        self.capacity = new_capacity;
        println("[Vector] Resize complete (new capacity=%d", new_capacity);
    }
    
    void info() {
        println("[Vector] length=%d, capacity=%d", self.length, self.capacity);
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    // BumpAllocatorではメモリ解放は何もしない（バンプアロケータの特性）
    void destroy() {
        println("[Vector<BumpAllocator>] destroy(): BumpAllocator does not free individual allocations");
        self.length = 0;
        self.capacity = 0;
        self.data = nullptr;
    }
}

// ============================================================================
// Vector<string> Implementation
// ============================================================================

impl VectorOps<string> for Vector<string, SystemAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        // stringのサイズを考慮して確保 (現在はvoid*として扱う)
        int string_size = 8;  // ポインタサイズ
        self.data = malloc(initial_capacity * string_size);
        
        println("[Vector<string>] Initialized with capacity={initial_capacity}");
        println("[Vector<string>] Allocated memory at {hex(self.data)}");
    }
    
    void push(string value) {
        if (self.length >= self.capacity) {
            println("[Vector<string>] Error: Capacity full! (size={self.length}, capacity={self.capacity})");
            return;
        }
        
        array_set_string(self.data, self.length, value);
        self.length = self.length + 1;
        
        println("[Vector<string>] Pushed value={value} at index={self.length - 1}");
    }
    
    string pop() {
        if (self.length <= 0) {
            println("[Vector<string>] Empty! Cannot pop");
            return "";
        }
        
        self.length = self.length - 1;
        string value = array_get_string(self.data, self.length);
        
        println("[Vector<string>] Popped value={value} from index={self.length}");
        return value;
    }
    
    string get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<string>] Error: Index out of bounds (index={index}, length={self.length})");
            return "";
        }
        
        string value = array_get_string(self.data, index);
        return value;
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector<string>] No resize needed");
            return;
        }
        
        println("[Vector<string>] Resizing from {self.capacity} to {new_capacity}");
        
        int string_size = 8;
        void* new_data = malloc(new_capacity * string_size);
        
        // 文字列配列のコピー
        int i = 0;
        while (i < self.length) {
            string value = array_get_string(self.data, i);
            array_set_string(new_data, i, value);
            i = i + 1;
        }
        
        free(self.data);
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector<string>] Resize complete");
    }
    
    void info() {
        println("[Vector<string>] length={self.length}, capacity={self.capacity}");
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void destroy() {
        if (self.data != nullptr) {
            println("[Vector<string>] Destructor: Freeing memory at {hex(self.data)}");
            free(self.data);
            self.data = nullptr;
        }
    }
}

// ============================================================================
// Vector<double> Implementation
// ============================================================================

impl VectorOps<double> for Vector<double, SystemAllocator> {
    void init(int initial_capacity) {
        self.capacity = initial_capacity;
        self.length = 0;
        self.data = new double[initial_capacity];
        
        println("[Vector<double>] Initialized with capacity={initial_capacity}");
        println("[Vector<double>] Allocated memory at {hex(self.data)}");
    }
    
    void push(double value) {
        if (self.length >= self.capacity) {
            println("[Vector<double>] Error: Capacity full! (size={self.length}, capacity={self.capacity})");
            return;
        }
        
        array_set_double(self.data, self.length, value);
        self.length = self.length + 1;
        
        println("[Vector<double>] Pushed value={value} at index={self.length - 1}");
    }
    
    double pop() {
        if (self.length <= 0) {
            println("[Vector<double>] Empty! Cannot pop");
            return 0.0;
        }
        
        self.length = self.length - 1;
        double value = array_get_double(self.data, self.length);
        
        println("[Vector<double>] Popped value={value} from index={self.length}");
        return value;
    }
    
    double get(int index) {
        if (index < 0 || index >= self.length) {
            println("[Vector<double>] Error: Index out of bounds (index={index}, length={self.length})");
            return 0.0;
        }
        
        double value = array_get_double(self.data, index);
        return value;
    }
    
    void resize(int new_capacity) {
        if (new_capacity <= self.capacity) {
            println("[Vector<double>] No resize needed");
            return;
        }
        
        println("[Vector<double>] Resizing from {self.capacity} to {new_capacity}");
        
        void* new_data = new double[new_capacity];
        
        int copy_size = self.length * sizeof(double);
        memcpy(new_data, self.data, copy_size);
        
        println("[Vector<double>] Copied {self.length} elements ({copy_size} bytes)");
        
        delete self.data;
        self.data = new_data;
        self.capacity = new_capacity;
        
        println("[Vector<double>] Resize complete");
    }
    
    void info() {
        println("[Vector<double>] length={self.length}, capacity={self.capacity}");
    }
    
    int get_length() {
        return self.length;
    }
    
    int get_capacity() {
        return self.capacity;
    }
    
    bool is_empty() {
        return self.length == 0;
    }
    
    void destroy() {
        if (self.data != nullptr) {
            println("[Vector<double>] Destructor: Freeing memory at {hex(self.data)}");
            delete self.data;
            self.data = nullptr;
        }
    }
}
