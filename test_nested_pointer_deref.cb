// Test: Nested pointer dereference with parentheses
// Pattern: (*(*p).value).value

struct Inner {
    int value;
    int data;
};

struct Middle {
    Inner* inner;
    int count;
};

struct Outer {
    Middle* middle;
    int id;
};

int main() {
    println("=== Nested Pointer Dereference Test ===");
    
    // Setup nested structure
    Inner i = {value: 42, data: 100};
    Middle m = {inner: &i, count: 1};
    Outer o = {middle: &m, id: 999};
    
    // Test 1: Single level dereference
    println("\nTest 1: Single level (*m.inner).value");
    int val1 = (*m.inner).value;
    println("Result:", val1);
    if (val1 != 42) {
        println("FAILED: expected 42, got", val1);
        return 1;
    }
    println("PASSED");
    
    // Test 2: Double level dereference with parentheses
    println("\nTest 2: Double level (*(*o.middle).inner).value");
    int val2 = (*(*o.middle).inner).value;
    println("Result:", val2);
    if (val2 != 42) {
        println("FAILED: expected 42, got", val2);
        return 1;
    }
    println("PASSED");
    
    // Test 3: Mixed arrow and dereference
    println("\nTest 3: Mixed o.middle->inner (then access .value)");
    Inner* innerPtr = o.middle->inner;
    int val3 = innerPtr->value;
    println("Result:", val3);
    if (val3 != 42) {
        println("FAILED: expected 42, got", val3);
        return 1;
    }
    println("PASSED");
    
    // Test 4: Write through nested dereference
    println("\nTest 4: Write (*(*o.middle).inner).value = 999");
    (*(*o.middle).inner).value = 999;
    println("i.value =", i.value);
    if (i.value != 999) {
        println("FAILED: expected 999, got", i.value);
        return 1;
    }
    println("PASSED");
    
    // Test 5: Write through intermediate pointer
    println("\nTest 5: Write via intermediate pointer");
    Inner* innerPtr2 = o.middle->inner;
    innerPtr2->value = 777;
    println("i.value =", i.value);
    if (i.value != 777) {
        println("FAILED: expected 777, got", i.value);
        return 1;
    }
    println("PASSED");
    
    // Test 6: Nested with interface methods
    println("\nTest 6: Interface methods with nested pointers");
    
    interface IInner {
        int getValue();
        void setValue(int v);
    };
    
    impl IInner for Inner {
        int getValue() {
            return self.value;
        }
        
        void setValue(int v) {
            self.value = v;
        }
    };
    
    interface IOuter {
        int getInnerValue();
        void setInnerValue(int v);
    };
    
    impl IOuter for Outer {
        int getInnerValue() {
            // Nested pointer access (use intermediate variable)
            Inner* innerPtr = self.middle->inner;
            return innerPtr->getValue();
        }
        
        void setInnerValue(int v) {
            // Nested pointer access (use intermediate variable)
            Inner* innerPtr = self.middle->inner;
            innerPtr->setValue(v);
        }
    };
    
    Inner i2 = {value: 123, data: 456};
    Middle m2 = {inner: &i2, count: 2};
    Outer o2 = {middle: &m2, id: 888};
    
    int val6 = o2.getInnerValue();
    println("Result:", val6);
    if (val6 != 123) {
        println("FAILED: expected 123, got", val6);
        return 1;
    }
    println("PASSED");
    
    println("\nTest 7: Set value through nested pointer method");
    o2.setInnerValue(555);
    println("i2.value =", i2.value);
    if (i2.value != 555) {
        println("FAILED: expected 555, got", i2.value);
        return 1;
    }
    println("PASSED");
    
    println("\n=== All Nested Pointer Tests Passed ===");
    return 0;
}
